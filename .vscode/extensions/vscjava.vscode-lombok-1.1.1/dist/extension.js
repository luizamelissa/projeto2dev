/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ([
/* 0 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.deactivate = exports.activate = void 0;
const vscode_1 = __webpack_require__(1);
const vscode_extension_telemetry_wrapper_1 = __webpack_require__(2);
const codeActionProvider_1 = __webpack_require__(131);
const util_1 = __webpack_require__(184);
const lombokChecker_1 = __webpack_require__(186);
const commands_1 = __webpack_require__(132);
let isRegistered = false;
let disposables = [];
function activate(context) {
    return __awaiter(this, void 0, void 0, function* () {
        yield (0, vscode_extension_telemetry_wrapper_1.initializeFromJsonFile)(context.asAbsolutePath('./package.json'));
        yield (0, vscode_extension_telemetry_wrapper_1.instrumentOperation)('activation', doActivate)(context);
    });
}
exports.activate = activate;
function doActivate(_operationId, context) {
    return __awaiter(this, void 0, void 0, function* () {
        const javaLanguageSupport = (0, util_1.getJavaExtension)();
        if (!javaLanguageSupport) {
            return;
        }
        if (!javaLanguageSupport.isActive) {
            yield javaLanguageSupport.activate();
        }
        const extensionApi = javaLanguageSupport.exports;
        if (!extensionApi) {
            return;
        }
        if (extensionApi.serverMode === "LightWeight" /* LanguageServerMode.LightWeight */) {
            if (extensionApi.onDidServerModeChange) {
                const onDidServerModeChange = extensionApi.onDidServerModeChange;
                context.subscriptions.push(onDidServerModeChange((mode) => __awaiter(this, void 0, void 0, function* () {
                    if (mode === "Standard" /* LanguageServerMode.Standard */) {
                        syncComponents();
                    }
                })));
            }
        }
        else {
            yield extensionApi.serverReady();
            syncComponents();
        }
        if (extensionApi.onDidClasspathUpdate) {
            const onDidClasspathUpdate = extensionApi.onDidClasspathUpdate;
            context.subscriptions.push(onDidClasspathUpdate(() => __awaiter(this, void 0, void 0, function* () {
                // workaround: wait more time to make sure Language Server has updated all caches
                setTimeout(() => {
                    syncComponents();
                }, 1000 /*ms*/);
            })));
        }
        if (extensionApi.onDidProjectsImport) {
            const onDidProjectsImport = extensionApi.onDidProjectsImport;
            context.subscriptions.push(onDidProjectsImport(() => {
                syncComponents();
            }));
        }
    });
}
function syncComponents() {
    return __awaiter(this, void 0, void 0, function* () {
        if ((0, util_1.isLombokSupportEnabled)() && (yield (0, lombokChecker_1.isLombokExists)())) {
            registerComponents();
        }
        else {
            unRegisterComponents();
        }
    });
}
function registerComponents() {
    return __awaiter(this, void 0, void 0, function* () {
        if (isRegistered) {
            return;
        }
        disposables.push((0, vscode_extension_telemetry_wrapper_1.instrumentOperationAsVsCodeCommand)(commands_1.Commands.CODEACTION_LOMBOK, (params, selectedAnnotations) => __awaiter(this, void 0, void 0, function* () {
            (0, codeActionProvider_1.lombokAction)(params, selectedAnnotations);
        })));
        disposables.push(vscode_1.languages.registerCodeActionsProvider({ scheme: 'file', language: 'java' }, new codeActionProvider_1.LombokCodeActionProvider()));
        isRegistered = true;
    });
}
function unRegisterComponents() {
    return __awaiter(this, void 0, void 0, function* () {
        if (!isRegistered) {
            return;
        }
        for (const disposable of disposables) {
            disposable.dispose();
        }
        disposables = [];
        isRegistered = false;
    });
}
function deactivate() {
    return __awaiter(this, void 0, void 0, function* () {
        for (const disposable of disposables) {
            disposable.dispose();
        }
        yield (0, vscode_extension_telemetry_wrapper_1.dispose)();
    });
}
exports.deactivate = deactivate;


/***/ }),
/* 1 */
/***/ ((module) => {

module.exports = require("vscode");

/***/ }),
/* 2 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.addReplacementRule = exports.addContextProperty = exports.dispose = exports.createUuid = exports.instrumentOperationStep = exports.sendInfo = exports.sendOperationError = exports.sendError = exports.sendOperationEnd = exports.sendOperationStart = exports.instrumentOperationAsVsCodeCommand = exports.instrumentSimpleOperation = exports.instrumentOperation = exports.setErrorCode = exports.setUserError = exports.initialize = exports.initializeFromJsonFile = void 0;
const fs = __webpack_require__(3);
const uuid = __webpack_require__(4);
const vscode = __webpack_require__(1);
const extension_telemetry_1 = __webpack_require__(20);
const event_1 = __webpack_require__(129);
const output_1 = __webpack_require__(130);
let isDebug = false;
let reporters;
const contextProperties = {};
const replacementRules = [];
const SENSITIVE_EVENTS = [event_1.EventName.ERROR, event_1.EventName.OPERATION_END, event_1.EventName.OPERATION_STEP];
function initializeFromJsonFile(jsonFilepath, options) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            yield fs.promises.access(jsonFilepath);
            const { publisher, name, aiKey } = JSON.parse(fs.readFileSync(jsonFilepath, "utf-8"));
            initialize(`${publisher}.${name}`, "", aiKey, options);
        }
        catch (error) {
            throw new Error(`The JSON file '${jsonFilepath}' does not exist.`);
        }
    });
}
exports.initializeFromJsonFile = initializeFromJsonFile;
/**
 * Initialize TelemetryReporter from given attributes.
 * @param extensionId Identifier of the extension, used as prefix of EventName in telemetry data.
 * @param version Version of the extension. (Deprecated, will not have any effect)
 * @param aiKey Key of Application Insights.
 * @param options debug: if set as true, debug information be printed to console.
 */
function initialize(extensionId, _version, aiKey, options) {
    if (reporters) {
        throw new Error("TelemetryReporter already initialized.");
    }
    if (aiKey) {
        if (aiKey instanceof Array) {
            reporters = aiKey.map((key) => new extension_telemetry_1.default(key, options === null || options === void 0 ? void 0 : options.replacementOptions));
        }
        else {
            reporters = [new extension_telemetry_1.default(aiKey, options === null || options === void 0 ? void 0 : options.replacementOptions)];
        }
    }
    output_1.Output.setExtensionId(extensionId);
    isDebug = !!(options && options.debug) || process.env.DEBUG_TELEMETRY === "true";
}
exports.initialize = initialize;
/**
 * Mark an Error instance as a user error.
 */
function setUserError(err) {
    err.isUserError = true;
}
exports.setUserError = setUserError;
/**
 * Set custom error code or an Error instance.
 * @param errorCode A custom error code.
 */
function setErrorCode(err, errorCode) {
    err.errorCode = errorCode;
}
exports.setErrorCode = setErrorCode;
/**
 * Instrument callback for a command to auto send OPERATION_START, OPERATION_END, ERROR telemetry.
 * A unique Id is created and accessible in the callback.
 * @param operationName For extension activation, use "activation", for VS Code commands, use command name.
 * @param cb The callback function **with a unique Id passed by its 1st parameter**.
 * @param thisArg The `this` context used when invoking the handler function.
 * @returns The instrumented callback.
 */
function instrumentOperation(operationName, cb, thisArg) {
    return (...args) => __awaiter(this, void 0, void 0, function* () {
        let error;
        const operationId = createUuid();
        const startAt = Date.now();
        try {
            sendOperationStart(operationId, operationName);
            return yield cb.apply(thisArg, [operationId, ...args]);
        }
        catch (e) {
            error = e;
            sendOperationError(operationId, operationName, error);
        }
        finally {
            const duration = Date.now() - startAt;
            sendOperationEnd(operationId, operationName, duration, error);
        }
    });
}
exports.instrumentOperation = instrumentOperation;
/**
 * Instrument callback for a command to auto send OPERATION_START, OPERATION_END, ERROR telemetry.
 * @param operationName For extension activation, use "activation", for VS Code commands, use command name.
 * @param cb The callback function.
 * @param thisArg The `this` context used when invoking the handler function.
 * @returns The instrumented callback.
 */
function instrumentSimpleOperation(operationName, cb, thisArg) {
    return instrumentOperation(operationName, (operationId, ...args) => __awaiter(this, void 0, void 0, function* () { return yield cb.apply(thisArg, args); }), thisArg /** unnecessary */);
}
exports.instrumentSimpleOperation = instrumentSimpleOperation;
/**
 * A shortcut to instrument and operation and register it as a VSCode command.
 * Note that operation Id will no longer be accessible in this approach.
 * @param command A unique identifier for the command.
 * @param cb A command handler function.
 * @param thisArg The `this` context used when invoking the handler function.
 */
function instrumentOperationAsVsCodeCommand(command, cb, thisArg) {
    return vscode.commands.registerCommand(command, instrumentSimpleOperation(command, cb, thisArg));
}
exports.instrumentOperationAsVsCodeCommand = instrumentOperationAsVsCodeCommand;
/**
 * Send OPERATION_START event.
 * @param operationId Unique id of the operation.
 * @param operationName Name of the operation.
 */
function sendOperationStart(operationId, operationName) {
    const event = {
        eventName: event_1.EventName.OPERATION_START,
        operationId,
        operationName,
    };
    sendEvent(event);
}
exports.sendOperationStart = sendOperationStart;
/**
 * Send OPERATION_END event.
 * @param operationId Unique id of the operation.
 * @param operationName Name of the operation.
 * @param duration Time elapsed for the operation, in milliseconds.
 * @param err An optional Error instance if occurs during the operation.
 */
function sendOperationEnd(operationId, operationName, duration, err) {
    const event = Object.assign({ eventName: event_1.EventName.OPERATION_END, operationId,
        operationName,
        duration }, extractErrorInfo(err));
    sendEvent(event);
}
exports.sendOperationEnd = sendOperationEnd;
/**
 * Send an ERROR event.
 * @param err An Error instance.
 */
function sendError(err) {
    const event = Object.assign({ eventName: event_1.EventName.ERROR }, extractErrorInfo(err));
    sendEvent(event);
}
exports.sendError = sendError;
/**
 * Send an ERROR event during an operation, carrying id and name of the operation.
 * @param operationId Unique id of the operation.
 * @param operationName Name of the operation.
 * @param err An Error instance containing details.
 */
function sendOperationError(operationId, operationName, err) {
    const event = Object.assign({ eventName: event_1.EventName.ERROR, operationId,
        operationName }, extractErrorInfo(err));
    sendEvent(event);
}
exports.sendOperationError = sendOperationError;
/**
 * Implementation of sendInfo.
 */
function sendInfo(operationId, dimensionsOrMeasurements, optionalMeasurements) {
    if (!reporters) {
        console.warn("TelemetryReporter not initialized.");
        return;
    }
    let dimensions;
    let measurements;
    if (optionalMeasurements) {
        dimensions = dimensionsOrMeasurements;
        measurements = optionalMeasurements;
    }
    else {
        dimensions = {};
        measurements = {};
        for (const key in dimensionsOrMeasurements) {
            if (typeof dimensionsOrMeasurements[key] === "string") {
                dimensions[key] = dimensionsOrMeasurements[key];
            }
            else if (typeof dimensionsOrMeasurements[key] === "number") {
                measurements[key] = dimensionsOrMeasurements[key];
            }
            else {
                // discard unsupported types.
            }
        }
    }
    sendTelemetryEvent(event_1.EventName.INFO, Object.assign(Object.assign({}, dimensions), { operationId }), measurements);
}
exports.sendInfo = sendInfo;
/**
 * Instrument callback for a procedure (regarded as a step in an operation).
 * @param operationId A unique identifier for the operation to which the step belongs.
 * @param stepName Name of the step.
 * @param cb The callback function with a unique Id passed by its 1st parameter.
 * @returns The instrumented callback.
 */
function instrumentOperationStep(operationId, stepName, cb) {
    return (...args) => __awaiter(this, void 0, void 0, function* () {
        let error;
        const startAt = Date.now();
        try {
            return yield cb(...args);
        }
        catch (e) {
            error = e;
            throw e;
        }
        finally {
            const event = Object.assign({ eventName: event_1.EventName.OPERATION_STEP, operationId,
                stepName, duration: Date.now() - startAt }, extractErrorInfo(error));
            sendEvent(event);
        }
    });
}
exports.instrumentOperationStep = instrumentOperationStep;
/**
 * Create a UUID string using uuid.v4().
 */
function createUuid() {
    return uuid.v4();
}
exports.createUuid = createUuid;
/**
 * Dispose the reporter.
 */
function dispose() {
    return __awaiter(this, void 0, void 0, function* () {
        if (reporters) {
            return yield Promise.all(reporters.map((reporter) => reporter.dispose()));
        }
    });
}
exports.dispose = dispose;
/**
 * Add a context property that will be set for all "info" events.
 * It will be overwritten by the property with the same name, if it's explicitly set in an event.
 * @param name name of context property
 * @param value value of context property
 */
function addContextProperty(name, value) {
    contextProperties[name] = value;
}
exports.addContextProperty = addContextProperty;
/**
 * @deprecated This method is deprecated. Use replacementOptions in IOptions instead.
 * Add a replacement rule that will be applied to all properties. Useful when you want to wipe sensitive data.
 *
 * Note: rules will not affect context properties.
 *
 * @param pattern RegExp pattern to search
 * @param replaceString target string to repalce matched parts
 */
function addReplacementRule(pattern, replaceString) {
    replacementRules.push({
        pattern,
        replace: replaceString !== null && replaceString !== void 0 ? replaceString : ""
    });
}
exports.addReplacementRule = addReplacementRule;
function extractErrorInfo(err) {
    if (!err) {
        return {
            errorCode: event_1.ErrorCodes.NO_ERROR,
        };
    }
    const richError = err;
    return {
        errorCode: richError.errorCode || event_1.ErrorCodes.GENERAL_ERROR,
        errorType: richError.isUserError ? event_1.ErrorType.USER_ERROR : event_1.ErrorType.SYSTEM_ERROR,
        message: err.message,
        stack: err.stack,
    };
}
function sendEvent(event) {
    if (!reporters) {
        console.warn("TelemetryReporter not initialized.");
        return;
    }
    const dimensions = {};
    for (const key of event_1.DimensionEntries) {
        const value = event[key];
        if (value !== undefined) {
            dimensions[key] = String(value);
        }
    }
    const measurements = {};
    for (const key of event_1.MeasurementEntries) {
        const value = event[key];
        if (value !== undefined) {
            measurements[key] = value;
        }
    }
    sendTelemetryEvent(event.eventName, dimensions, measurements);
}
function sendTelemetryEvent(eventName, dimensions, measurements) {
    if (!reporters) {
        console.warn("TelemetryReporter not initialized.");
        return;
    }
    // apply replacement rules
    dimensions = dimensions !== null && dimensions !== void 0 ? dimensions : {};
    for (const k of Object.keys(dimensions)) {
        dimensions[k] = applyRules(replacementRules, dimensions[k]);
    }
    // add context props
    dimensions = Object.assign(Object.assign({}, contextProperties), dimensions);
    if (eventName in SENSITIVE_EVENTS) { // for GDPR
        reporters.forEach((reporter) => {
            reporter.sendTelemetryErrorEvent(eventName, dimensions, measurements);
        });
    }
    else {
        reporters.forEach((reporter) => {
            reporter.sendTelemetryEvent(eventName, dimensions, measurements);
        });
    }
    if (isDebug) {
        output_1.Output.getInstance().appendLine(`>> ${(new Date()).toISOString()}`);
        output_1.Output.getInstance().appendLine(JSON.stringify({ eventName, dimensions, measurements }, null, 2));
    }
}
function applyRules(rules, content) {
    for (const rule of rules) {
        content = content.replace(rule.pattern, rule.replace);
    }
    return content;
}
//# sourceMappingURL=index.js.map

/***/ }),
/* 3 */
/***/ ((module) => {

module.exports = require("fs");

/***/ }),
/* 4 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NIL": () => (/* reexport safe */ _nil_js__WEBPACK_IMPORTED_MODULE_4__["default"]),
/* harmony export */   "parse": () => (/* reexport safe */ _parse_js__WEBPACK_IMPORTED_MODULE_8__["default"]),
/* harmony export */   "stringify": () => (/* reexport safe */ _stringify_js__WEBPACK_IMPORTED_MODULE_7__["default"]),
/* harmony export */   "v1": () => (/* reexport safe */ _v1_js__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   "v3": () => (/* reexport safe */ _v3_js__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   "v4": () => (/* reexport safe */ _v4_js__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   "v5": () => (/* reexport safe */ _v5_js__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   "validate": () => (/* reexport safe */ _validate_js__WEBPACK_IMPORTED_MODULE_6__["default"]),
/* harmony export */   "version": () => (/* reexport safe */ _version_js__WEBPACK_IMPORTED_MODULE_5__["default"])
/* harmony export */ });
/* harmony import */ var _v1_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5);
/* harmony import */ var _v3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(11);
/* harmony import */ var _v4_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(15);
/* harmony import */ var _v5_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(16);
/* harmony import */ var _nil_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(18);
/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(19);
/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(9);
/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(8);
/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(13);










/***/ }),
/* 5 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6);
/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8);

 // **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html

let _nodeId;

let _clockseq; // Previous uuid creation time


let _lastMSecs = 0;
let _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details

function v1(options, buf, offset) {
  let i = buf && offset || 0;
  const b = buf || new Array(16);
  options = options || {};
  let node = options.node || _nodeId;
  let clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not
  // specified.  We do this lazily to minimize issues related to insufficient
  // system entropy.  See #189

  if (node == null || clockseq == null) {
    const seedBytes = options.random || (options.rng || _rng_js__WEBPACK_IMPORTED_MODULE_0__["default"])();

    if (node == null) {
      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }

    if (clockseq == null) {
      // Per 4.2.2, randomize (14 bit) clockseq
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
    }
  } // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.


  let msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock

  let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)

  const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression

  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval


  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  } // Per 4.2.1.2 Throw error if too many uuids are requested


  if (nsecs >= 10000) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }

  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch

  msecs += 12219292800000; // `time_low`

  const tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff; // `time_mid`

  const tmh = msecs / 0x100000000 * 10000 & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff; // `time_high_and_version`

  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version

  b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)

  b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`

  b[i++] = clockseq & 0xff; // `node`

  for (let n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }

  return buf || (0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__["default"])(b);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v1);

/***/ }),
/* 6 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ rng)
/* harmony export */ });
/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7);
/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_0__);

const rnds8Pool = new Uint8Array(256); // # of random values to pre-allocate

let poolPtr = rnds8Pool.length;
function rng() {
  if (poolPtr > rnds8Pool.length - 16) {
    crypto__WEBPACK_IMPORTED_MODULE_0___default().randomFillSync(rnds8Pool);
    poolPtr = 0;
  }

  return rnds8Pool.slice(poolPtr, poolPtr += 16);
}

/***/ }),
/* 7 */
/***/ ((module) => {

module.exports = require("crypto");

/***/ }),
/* 8 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9);

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */

const byteToHex = [];

for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 0x100).toString(16).substr(1));
}

function stringify(arr, offset = 0) {
  // Note: Be careful editing this code!  It's been tuned for performance
  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
  const uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one
  // of the following:
  // - One or more input array values don't map to a hex octet (leading to
  // "undefined" in the uuid)
  // - Invalid input values for the RFC `version` or `variant` fields

  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__["default"])(uuid)) {
    throw TypeError('Stringified UUID is invalid');
  }

  return uuid;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (stringify);

/***/ }),
/* 9 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _regex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(10);


function validate(uuid) {
  return typeof uuid === 'string' && _regex_js__WEBPACK_IMPORTED_MODULE_0__["default"].test(uuid);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (validate);

/***/ }),
/* 10 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i);

/***/ }),
/* 11 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _v35_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(12);
/* harmony import */ var _md5_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(14);


const v3 = (0,_v35_js__WEBPACK_IMPORTED_MODULE_0__["default"])('v3', 0x30, _md5_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v3);

/***/ }),
/* 12 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DNS": () => (/* binding */ DNS),
/* harmony export */   "URL": () => (/* binding */ URL),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8);
/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(13);



function stringToBytes(str) {
  str = unescape(encodeURIComponent(str)); // UTF8 escape

  const bytes = [];

  for (let i = 0; i < str.length; ++i) {
    bytes.push(str.charCodeAt(i));
  }

  return bytes;
}

const DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';
const URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, version, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    if (typeof value === 'string') {
      value = stringToBytes(value);
    }

    if (typeof namespace === 'string') {
      namespace = (0,_parse_js__WEBPACK_IMPORTED_MODULE_0__["default"])(namespace);
    }

    if (namespace.length !== 16) {
      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');
    } // Compute hash of namespace and value, Per 4.3
    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =
    // hashfunc([...namespace, ... value])`


    let bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 0x0f | version;
    bytes[8] = bytes[8] & 0x3f | 0x80;

    if (buf) {
      offset = offset || 0;

      for (let i = 0; i < 16; ++i) {
        buf[offset + i] = bytes[i];
      }

      return buf;
    }

    return (0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__["default"])(bytes);
  } // Function#name is not settable on some platforms (#270)


  try {
    generateUUID.name = name; // eslint-disable-next-line no-empty
  } catch (err) {} // For CommonJS default export support


  generateUUID.DNS = DNS;
  generateUUID.URL = URL;
  return generateUUID;
}

/***/ }),
/* 13 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9);


function parse(uuid) {
  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__["default"])(uuid)) {
    throw TypeError('Invalid UUID');
  }

  let v;
  const arr = new Uint8Array(16); // Parse ########-....-....-....-............

  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 0xff;
  arr[2] = v >>> 8 & 0xff;
  arr[3] = v & 0xff; // Parse ........-####-....-....-............

  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 0xff; // Parse ........-....-####-....-............

  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 0xff; // Parse ........-....-....-####-............

  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 0xff; // Parse ........-....-....-....-############
  // (Use "/" to avoid 32-bit truncation when bit-shifting high-order bytes)

  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;
  arr[11] = v / 0x100000000 & 0xff;
  arr[12] = v >>> 24 & 0xff;
  arr[13] = v >>> 16 & 0xff;
  arr[14] = v >>> 8 & 0xff;
  arr[15] = v & 0xff;
  return arr;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (parse);

/***/ }),
/* 14 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7);
/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_0__);


function md5(bytes) {
  if (Array.isArray(bytes)) {
    bytes = Buffer.from(bytes);
  } else if (typeof bytes === 'string') {
    bytes = Buffer.from(bytes, 'utf8');
  }

  return crypto__WEBPACK_IMPORTED_MODULE_0___default().createHash('md5').update(bytes).digest();
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (md5);

/***/ }),
/* 15 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6);
/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8);



function v4(options, buf, offset) {
  options = options || {};
  const rnds = options.random || (options.rng || _rng_js__WEBPACK_IMPORTED_MODULE_0__["default"])(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`

  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

  if (buf) {
    offset = offset || 0;

    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }

    return buf;
  }

  return (0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__["default"])(rnds);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v4);

/***/ }),
/* 16 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _v35_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(12);
/* harmony import */ var _sha1_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(17);


const v5 = (0,_v35_js__WEBPACK_IMPORTED_MODULE_0__["default"])('v5', 0x50, _sha1_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v5);

/***/ }),
/* 17 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7);
/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_0__);


function sha1(bytes) {
  if (Array.isArray(bytes)) {
    bytes = Buffer.from(bytes);
  } else if (typeof bytes === 'string') {
    bytes = Buffer.from(bytes, 'utf8');
  }

  return crypto__WEBPACK_IMPORTED_MODULE_0___default().createHash('sha1').update(bytes).digest();
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (sha1);

/***/ }),
/* 18 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ('00000000-0000-0000-0000-000000000000');

/***/ }),
/* 19 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9);


function version(uuid) {
  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__["default"])(uuid)) {
    throw TypeError('Invalid UUID');
  }

  return parseInt(uuid.substr(14, 1), 16);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (version);

/***/ }),
/* 20 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


/*---------------------------------------------------------
 * Copyright (C) Microsoft Corporation. All rights reserved.
 *--------------------------------------------------------*/
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const os = __importStar(__webpack_require__(21));
const vscode = __importStar(__webpack_require__(1));
const https = __importStar(__webpack_require__(22));
const baseTelemetryReporter_1 = __webpack_require__(23);
const baseTelemetrySender_1 = __webpack_require__(24);
const util_1 = __webpack_require__(25);
const _1dsClientFactory_1 = __webpack_require__(26);
const appInsightsClientFactory_1 = __webpack_require__(88);
/**
 * Create a replacement for the XHTMLRequest object utilizing nodes HTTP module.
 * @returns A XHR override object used to override the XHTMLRequest object in the 1DS SDK
 */
function getXHROverride() {
    // Override the way events get sent since node doesn't have XHTMLRequest
    const customHttpXHROverride = {
        sendPOST: (payload, oncomplete) => {
            const options = {
                method: "POST",
                headers: {
                    ...payload.headers,
                    "Content-Type": "application/json",
                    "Content-Length": Buffer.byteLength(payload.data)
                }
            };
            try {
                const req = https.request(payload.urlString, options, res => {
                    res.on("data", function (responseData) {
                        oncomplete(res.statusCode ?? 200, res.headers, responseData.toString());
                    });
                    // On response with error send status of 0 and a blank response to oncomplete so we can retry events
                    res.on("error", function () {
                        oncomplete(0, {});
                    });
                });
                req.write(payload.data, (err) => {
                    if (err) {
                        oncomplete(0, {});
                    }
                });
                req.end();
            }
            catch {
                // If it errors out, send status of 0 and a blank response to oncomplete so we can retry events
                oncomplete(0, {});
            }
        }
    };
    return customHttpXHROverride;
}
class TelemetryReporter extends baseTelemetryReporter_1.BaseTelemetryReporter {
    constructor(key, replacementOptions) {
        let clientFactory = (key) => (0, appInsightsClientFactory_1.appInsightsClientFactory)(key, getXHROverride(), replacementOptions);
        // If key is usable by 1DS use the 1DS SDk
        if (util_1.TelemetryUtil.shouldUseOneDataSystemSDK(key)) {
            clientFactory = (key) => (0, _1dsClientFactory_1.oneDataSystemClientFactory)(key, vscode, getXHROverride());
        }
        const osShim = {
            release: os.release(),
            platform: os.platform(),
            architecture: os.arch(),
        };
        const sender = new baseTelemetrySender_1.BaseTelemetrySender(key, clientFactory);
        if (key && key.indexOf("AIF-") === 0) {
            throw new Error("AIF keys are no longer supported. Please switch to 1DS keys for 1st party extensions");
        }
        super(sender, vscode, { additionalCommonProperties: util_1.TelemetryUtil.getAdditionalCommonProperties(osShim) });
    }
}
exports["default"] = TelemetryReporter;
//# sourceMappingURL=telemetryReporter.js.map

/***/ }),
/* 21 */
/***/ ((module) => {

module.exports = require("os");

/***/ }),
/* 22 */
/***/ ((module) => {

module.exports = require("https");

/***/ }),
/* 23 */
/***/ ((__unused_webpack_module, exports) => {


/*---------------------------------------------------------
 * Copyright (C) Microsoft Corporation. All rights reserved.
 *--------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BaseTelemetryReporter = void 0;
class BaseTelemetryReporter {
    constructor(telemetrySender, vscodeAPI, initializationOptions) {
        this.telemetrySender = telemetrySender;
        this.vscodeAPI = vscodeAPI;
        this.userOptIn = false;
        this.errorOptIn = false;
        this.disposables = [];
        this._onDidChangeTelemetryLevel = new this.vscodeAPI.EventEmitter();
        this.onDidChangeTelemetryLevel = this._onDidChangeTelemetryLevel.event;
        this.telemetryLogger = this.vscodeAPI.env.createTelemetryLogger(this.telemetrySender, initializationOptions);
        // Keep track of the user's opt-in status
        this.updateUserOptIn();
        this.telemetryLogger.onDidChangeEnableStates(() => {
            this.updateUserOptIn();
        });
    }
    /**
     * Updates the user's telemetry opt-in status
     */
    updateUserOptIn() {
        this.errorOptIn = this.telemetryLogger.isErrorsEnabled;
        this.userOptIn = this.telemetryLogger.isUsageEnabled;
        // The sender is lazy loaded so if telemetry is off it's not loaded in
        if (this.telemetryLogger.isErrorsEnabled || this.telemetryLogger.isUsageEnabled) {
            this.telemetrySender.instantiateSender();
        }
        this._onDidChangeTelemetryLevel.fire(this.telemetryLevel);
    }
    get telemetryLevel() {
        if (this.errorOptIn && this.userOptIn) {
            return "all";
        }
        else if (this.errorOptIn) {
            return "error";
        }
        else {
            return "off";
        }
    }
    /**
     * Internal function which logs telemetry events and takes extra options.
     * @param eventName The name of the event
     * @param properties The properties of the event
     * @param measurements The measurements (numeric values) to send with the event
     * @param sanitize Whether or not to sanitize to the properties and measures
     * @param dangerous Whether or not to ignore telemetry level
     */
    internalSendTelemetryEvent(eventName, properties, measurements, dangerous) {
        // If it's dangerous we skip going through the logger as the logger checks opt-in status, etc.
        if (dangerous) {
            this.telemetrySender.sendEventData(eventName, { properties, measurements });
        }
        else {
            this.telemetryLogger.logUsage(eventName, { properties, measurements });
        }
    }
    /**
     * Given an event name, some properties, and measurements sends a telemetry event.
     * Properties are sanitized on best-effort basis to remove sensitive data prior to sending.
     * @param eventName The name of the event
     * @param properties The properties to send with the event
     * @param measurements The measurements (numeric values) to send with the event
     */
    sendTelemetryEvent(eventName, properties, measurements) {
        this.internalSendTelemetryEvent(eventName, properties, measurements, false);
    }
    /**
     * Sends a raw (unsanitized) telemetry event with the given properties and measurements.
     * NOTE: This will not be logged to the output channel due to API limitations.
     * @param eventName The name of the event
     * @param properties The set of properties to add to the event in the form of a string key value pair
     * @param measurements The set of measurements to add to the event in the form of a string key  number value pair
     */
    sendRawTelemetryEvent(eventName, properties, measurements) {
        const modifiedProperties = { ...properties };
        for (const propertyKey of Object.keys(modifiedProperties ?? {})) {
            const propertyValue = modifiedProperties[propertyKey];
            if (typeof propertyKey === "string" && propertyValue !== undefined) {
                // Trusted values are not sanitized, which is what we want for raw telemetry
                modifiedProperties[propertyKey] = new this.vscodeAPI.TelemetryTrustedValue(typeof propertyValue === "string" ? propertyValue : propertyValue.value);
            }
        }
        this.sendTelemetryEvent(eventName, modifiedProperties, measurements);
    }
    /**
     * **DANGEROUS** Given an event name, some properties, and measurements sends a telemetry event without checking telemetry setting
     * Do not use unless in a controlled environment i.e. sending telmetry from a CI pipeline or testing during development
     * @param eventName The name of the event
     * @param properties The properties to send with the event
     * @param measurements The measurements (numeric values) to send with the event
     * @param sanitize Whether or not to sanitize to the properties and measures, defaults to true
     */
    sendDangerousTelemetryEvent(eventName, properties, measurements) {
        // Since telemetry is probably off when sending dangerously, we must start the sender
        this.telemetrySender.instantiateSender();
        this.internalSendTelemetryEvent(eventName, properties, measurements, true);
    }
    /**
     * Internal function which logs telemetry error events and takes extra options.
     * @param eventName The name of the event
     * @param properties The properties of the event
     * @param measurements The measurements (numeric values) to send with the event
     * @param sanitize Whether or not to sanitize to the properties and measures
     * @param dangerous Whether or not to ignore telemetry level
     */
    internalSendTelemetryErrorEvent(eventName, properties, measurements, dangerous) {
        if (dangerous) {
            this.telemetrySender.sendEventData(eventName, { properties, measurements });
        }
        else {
            this.telemetryLogger.logError(eventName, { properties, measurements });
        }
    }
    /**
     * Given an event name, some properties, and measurements sends an error event
     * @param eventName The name of the event
     * @param properties The properties to send with the event
     * @param measurements The measurements (numeric values) to send with the event
     */
    sendTelemetryErrorEvent(eventName, properties, measurements) {
        this.internalSendTelemetryErrorEvent(eventName, properties, measurements, false);
    }
    /**
     * **DANGEROUS** Given an event name, some properties, and measurements sends a telemetry error event without checking telemetry setting
     * Do not use unless in a controlled environment i.e. sending telmetry from a CI pipeline or testing during development
     * @param eventName The name of the event
     * @param properties The properties to send with the event
     * @param measurements The measurements (numeric values) to send with the event
     * @param sanitize Whether or not to run the properties and measures through sanitiziation, defaults to true
     */
    sendDangerousTelemetryErrorEvent(eventName, properties, measurements) {
        // Since telemetry is probably off when sending dangerously, we must start the sender
        this.telemetrySender.instantiateSender();
        this.internalSendTelemetryErrorEvent(eventName, properties, measurements, true);
    }
    /**
     * Disposes of the telemetry reporter
     */
    async dispose() {
        await this.telemetrySender.dispose();
        this.telemetryLogger.dispose();
        return Promise.all(this.disposables.map(d => d.dispose()));
    }
}
exports.BaseTelemetryReporter = BaseTelemetryReporter;
//# sourceMappingURL=baseTelemetryReporter.js.map

/***/ }),
/* 24 */
/***/ ((__unused_webpack_module, exports) => {


/*---------------------------------------------------------
 * Copyright (C) Microsoft Corporation. All rights reserved.
 *--------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BaseTelemetrySender = void 0;
var InstantiationStatus;
(function (InstantiationStatus) {
    InstantiationStatus[InstantiationStatus["NOT_INSTANTIATED"] = 0] = "NOT_INSTANTIATED";
    InstantiationStatus[InstantiationStatus["INSTANTIATING"] = 1] = "INSTANTIATING";
    InstantiationStatus[InstantiationStatus["INSTANTIATED"] = 2] = "INSTANTIATED";
})(InstantiationStatus || (InstantiationStatus = {}));
class BaseTelemetrySender {
    constructor(key, clientFactory) {
        // Whether or not the client has been instantiated
        this._instantiationStatus = InstantiationStatus.NOT_INSTANTIATED;
        // Queues used to store events until the sender is ready
        this._eventQueue = [];
        this._exceptionQueue = [];
        this._clientFactory = clientFactory;
        this._key = key;
    }
    /**
     * Sends the event to the passed in telemetry client
     * The sender does no telemetry level checks as those are done by the reporter.
     * @param eventName The name of the event to log
     * @param data The data contanied in the event
     */
    sendEventData(eventName, data) {
        if (!this._telemetryClient) {
            if (this._instantiationStatus !== InstantiationStatus.INSTANTIATED) {
                this._eventQueue.push({ eventName, data });
            }
            return;
        }
        this._telemetryClient.logEvent(eventName, data);
    }
    /**
     * Sends an exception to the passed in telemetry client
     * The sender does no telemetry level checks as those are done by the reporter.
     * @param exception The exception to collect
     * @param data Data associated with the exception
     */
    sendErrorData(exception, data) {
        if (!this._telemetryClient) {
            if (this._instantiationStatus !== InstantiationStatus.INSTANTIATED) {
                this._exceptionQueue.push({ exception, data });
            }
            return;
        }
        const errorData = { stack: exception.stack, message: exception.message, name: exception.name };
        if (data) {
            const errorProperties = data.properties || data;
            data.properties = { ...errorProperties, ...errorData };
        }
        else {
            data = { properties: errorData };
        }
        this._telemetryClient.logEvent("unhandlederror", data);
    }
    /**
     * Flushes the buffered telemetry data
     */
    async flush() {
        return this._telemetryClient?.flush();
    }
    async dispose() {
        if (this._telemetryClient) {
            await this._telemetryClient.dispose();
            this._telemetryClient = undefined;
        }
        return;
    }
    /**
     * Flushes the queued events that existed before the client was instantiated
     */
    _flushQueues() {
        this._eventQueue.forEach(({ eventName, data }) => this.sendEventData(eventName, data));
        this._eventQueue = [];
        this._exceptionQueue.forEach(({ exception, data }) => this.sendErrorData(exception, data));
        this._exceptionQueue = [];
    }
    /**
     * Instantiates the telemetry client to make the sender "active"
     */
    instantiateSender() {
        if (this._instantiationStatus !== InstantiationStatus.NOT_INSTANTIATED) {
            return;
        }
        this._instantiationStatus = InstantiationStatus.INSTANTIATING;
        // Call the client factory to get the client and then let it know it's instatntiated
        this._clientFactory(this._key).then(client => {
            this._telemetryClient = client;
            this._instantiationStatus = InstantiationStatus.INSTANTIATED;
            this._flushQueues();
        }).catch(err => {
            console.error(err);
            // If it failed to instntiate, then we don't want to try again.
            // So we mark it as instantiated. See #94
            this._instantiationStatus = InstantiationStatus.INSTANTIATED;
        });
    }
}
exports.BaseTelemetrySender = BaseTelemetrySender;
//# sourceMappingURL=baseTelemetrySender.js.map

/***/ }),
/* 25 */
/***/ ((__unused_webpack_module, exports) => {


/*---------------------------------------------------------
 * Copyright (C) Microsoft Corporation. All rights reserved.
 *--------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TelemetryUtil = void 0;
class TelemetryUtil {
    static applyReplacements(data, replacementOptions) {
        for (const key of Object.keys(data)) {
            for (const option of replacementOptions) {
                if (option.lookup.test(key)) {
                    if (option.replacementString !== undefined) {
                        data[key] = option.replacementString;
                    }
                    else {
                        delete data[key];
                    }
                }
            }
        }
    }
    /**
     * Given a key checks if it is a valid 1DS key
     * @param key The key to check if it's a valid 1DS key
     */
    static shouldUseOneDataSystemSDK(key) {
        // Simple to check to ensure the key is the right length and the dashes are in the right spot
        return (key.length === 74 &&
            key[32] === "-" &&
            key[41] === "-" &&
            key[46] === "-" &&
            key[51] === "-" &&
            key[56] === "-" &&
            key[69] === "-");
    }
    // This also includes the common properties which core mixes in
    // __GDPR__COMMON__ "common.os" : { "classification": "SystemMetaData", "purpose": "FeatureInsight" }
    // __GDPR__COMMON__ "common.nodeArch" : { "classification": "SystemMetaData", "purpose": "FeatureInsight" }
    // __GDPR__COMMON__ "common.platformversion" : { "classification": "SystemMetaData", "purpose": "FeatureInsight" }
    // __GDPR__COMMON__ "common.extname" : { "classification": "PublicNonPersonalData", "purpose": "FeatureInsight" }
    // __GDPR__COMMON__ "common.extversion" : { "classification": "PublicNonPersonalData", "purpose": "FeatureInsight" }
    // __GDPR__COMMON__ "common.vscodemachineid" : { "endPoint": "MacAddressHash", "classification": "EndUserPseudonymizedInformation", "purpose": "FeatureInsight" }
    // __GDPR__COMMON__ "common.vscodesessionid" : { "classification": "SystemMetaData", "purpose": "FeatureInsight" }
    // __GDPR__COMMON__ "common.vscodeversion" : { "classification": "SystemMetaData", "purpose": "FeatureInsight" }
    // __GDPR__COMMON__ "common.uikind" : { "classification": "SystemMetaData", "purpose": "FeatureInsight" }
    // __GDPR__COMMON__ "common.remotename" : { "classification": "SystemMetaData", "purpose": "FeatureInsight" }
    // __GDPR__COMMON__ "common.isnewappinstall" : { "classification": "SystemMetaData", "purpose": "FeatureInsight" }
    // __GDPR__COMMON__ "common.product" : { "classification": "SystemMetaData", "purpose": "FeatureInsight" }
    // __GDPR__COMMON__ "common.telemetryclientversion" : { "classification": "SystemMetaData", "purpose": "FeatureInsight" }
    static getAdditionalCommonProperties(osShim) {
        return {
            "common.os": osShim.platform,
            "common.nodeArch": osShim.architecture,
            "common.platformversion": (osShim.release || "").replace(/^(\d+)(\.\d+)?(\.\d+)?(.*)/, "$1$2$3"),
            // Do not change this string as it gets found and replaced upon packaging
            "common.telemetryclientversion": "0.9.6"
        };
    }
    // Get singleton instance of TelemetryUtil
    static getInstance() {
        if (!TelemetryUtil._instance) {
            TelemetryUtil._instance = new TelemetryUtil();
        }
        return TelemetryUtil._instance;
    }
}
exports.TelemetryUtil = TelemetryUtil;
//# sourceMappingURL=util.js.map

/***/ }),
/* 26 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.oneDataSystemClientFactory = void 0;
/**
 * Configures 1DS properly and returns the core client object
 * @param key The ingestion key
 * @param xhrOverride An optional override to use for requests instead of the XHTMLRequest object. Useful for node environments
 * @returns The AI core object
 */
const getAICore = async (key, vscodeAPI, xhrOverride) => {
    const oneDs = await Promise.resolve().then(() => __importStar(__webpack_require__(/* webpackMode: "eager" */ 27)));
    const postPlugin = await Promise.resolve().then(() => __importStar(__webpack_require__(/* webpackMode: "eager" */ 76)));
    const appInsightsCore = new oneDs.AppInsightsCore();
    const collectorChannelPlugin = new postPlugin.PostChannel();
    // Configure the app insights core to send to collector++ and disable logging of debug info
    const coreConfig = {
        instrumentationKey: key,
        endpointUrl: "https://mobile.events.data.microsoft.com/OneCollector/1.0",
        loggingLevelTelemetry: 0,
        loggingLevelConsole: 0,
        disableCookiesUsage: true,
        disableDbgExt: true,
        disableInstrumentationKeyValidation: true,
        channels: [[
                collectorChannelPlugin
            ]]
    };
    if (xhrOverride) {
        coreConfig.extensionConfig = {};
        // Configure the channel to use a XHR Request override since it's not available in node
        const channelConfig = {
            alwaysUseXhrOverride: true,
            httpXHROverride: xhrOverride
        };
        coreConfig.extensionConfig[collectorChannelPlugin.identifier] = channelConfig;
    }
    const config = vscodeAPI.workspace.getConfiguration("telemetry");
    const internalTesting = config.get("internalTesting");
    appInsightsCore.initialize(coreConfig, []);
    appInsightsCore.addTelemetryInitializer((envelope) => {
        envelope["ext"] = envelope["ext"] ?? {};
        envelope["ext"]["web"] = envelope["ext"]["web"] ?? {};
        envelope["ext"]["web"]["consentDetails"] = "{\"GPC_DataSharingOptIn\":false}";
        // Only add the remaining flags when `telemetry.internalTesting` is enabled
        if (!internalTesting) {
            return;
        }
        envelope["ext"]["utc"] = envelope["ext"]["utc"] ?? {};
        // Sets it to be internal only based on Windows UTC flagging
        envelope["ext"]["utc"]["flags"] = 0x0000811ECD;
    });
    return appInsightsCore;
};
/**
 * Configures and creates a telemetry client using the 1DS sdk
 * @param key The ingestion key
 * @param xhrOverride An optional override to use for requests instead of the XHTMLRequest object. Useful for node environments
 */
const oneDataSystemClientFactory = async (key, vscodeAPI, xhrOverride) => {
    let appInsightsCore = await getAICore(key, vscodeAPI, xhrOverride);
    const flushOneDS = async () => {
        try {
            const flushPromise = new Promise((resolve, reject) => {
                if (!appInsightsCore) {
                    resolve();
                    return;
                }
                appInsightsCore.flush(true, (completedFlush) => {
                    if (!completedFlush) {
                        reject("Failed to flush app 1DS!");
                        return;
                    }
                });
            });
            return flushPromise;
        }
        catch (e) {
            throw new Error("Failed to flush 1DS!\n" + e.message);
        }
    };
    // Shape the app insights core from 1DS into a standard format
    const telemetryClient = {
        logEvent: (eventName, data) => {
            try {
                appInsightsCore?.track({
                    name: eventName,
                    baseData: { name: eventName, properties: data?.properties, measurements: data?.measurements }
                });
            }
            catch (e) {
                throw new Error("Failed to log event to app insights!\n" + e.message);
            }
        },
        flush: flushOneDS,
        dispose: async () => {
            const disposePromise = new Promise((resolve) => {
                if (!appInsightsCore) {
                    resolve();
                    return;
                }
                appInsightsCore.unload(false, () => {
                    resolve();
                    appInsightsCore = undefined;
                    return;
                }, 1000);
            });
            return disposePromise;
        }
    };
    return telemetryClient;
};
exports.oneDataSystemClientFactory = oneDataSystemClientFactory;
//# sourceMappingURL=1dsClientFactory.js.map

/***/ }),
/* 27 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AppInsightsCore": () => (/* reexport safe */ _AppInsightsCore__WEBPACK_IMPORTED_MODULE_1__.AppInsightsCore),
/* harmony export */   "BaseTelemetryPlugin": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_4__.BaseTelemetryPlugin),
/* harmony export */   "DiagnosticLogger": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_8__.DiagnosticLogger),
/* harmony export */   "EventLatency": () => (/* reexport safe */ _Enums__WEBPACK_IMPORTED_MODULE_0__.EventLatency),
/* harmony export */   "EventPersistence": () => (/* reexport safe */ _Enums__WEBPACK_IMPORTED_MODULE_0__.EventPersistence),
/* harmony export */   "EventPropertyType": () => (/* reexport safe */ _Enums__WEBPACK_IMPORTED_MODULE_0__.EventPropertyType),
/* harmony export */   "EventsDiscardedReason": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_7__.EventsDiscardedReason),
/* harmony export */   "FullVersionString": () => (/* reexport safe */ _Utils__WEBPACK_IMPORTED_MODULE_29__.FullVersionString),
/* harmony export */   "InternalAppInsightsCore": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_11__.AppInsightsCore),
/* harmony export */   "LoggingSeverity": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_9__.LoggingSeverity),
/* harmony export */   "MinChannelPriorty": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_6__.MinChannelPriorty),
/* harmony export */   "NotificationManager": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_3__.NotificationManager),
/* harmony export */   "PerfEvent": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_10__.PerfEvent),
/* harmony export */   "PerfManager": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_10__.PerfManager),
/* harmony export */   "ProcessTelemetryContext": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_5__.ProcessTelemetryContext),
/* harmony export */   "SenderPostManager": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_26__.SenderPostManager),
/* harmony export */   "TraceLevel": () => (/* reexport safe */ _Enums__WEBPACK_IMPORTED_MODULE_0__.TraceLevel),
/* harmony export */   "Undefined": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_19__.strShimUndefined),
/* harmony export */   "ValueKind": () => (/* reexport safe */ _Enums__WEBPACK_IMPORTED_MODULE_0__.ValueKind),
/* harmony export */   "ValueSanitizer": () => (/* reexport safe */ _ValueSanitizer__WEBPACK_IMPORTED_MODULE_2__.ValueSanitizer),
/* harmony export */   "Version": () => (/* reexport safe */ _Utils__WEBPACK_IMPORTED_MODULE_29__.Version),
/* harmony export */   "_InternalLogMessage": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_8__._InternalLogMessage),
/* harmony export */   "__getRegisteredEvents": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_14__.__getRegisteredEvents),
/* harmony export */   "_appendHeader": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_15__._appendHeader),
/* harmony export */   "_getAllResponseHeaders": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_15__._getAllResponseHeaders),
/* harmony export */   "_logInternalMessage": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_8__._logInternalMessage),
/* harmony export */   "_testHookMaxUnloadHooksCb": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_28__._testHookMaxUnloadHooksCb),
/* harmony export */   "_throwInternal": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_8__._throwInternal),
/* harmony export */   "_warnToConsole": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_8__._warnToConsole),
/* harmony export */   "addEventHandler": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_14__.addEventHandler),
/* harmony export */   "addEventListeners": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_14__.addEventListeners),
/* harmony export */   "addPageHideEventListener": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_14__.addPageHideEventListener),
/* harmony export */   "addPageShowEventListener": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_14__.addPageShowEventListener),
/* harmony export */   "addPageUnloadEventListener": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_14__.addPageUnloadEventListener),
/* harmony export */   "areCookiesSupported": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_20__.areCookiesSupported),
/* harmony export */   "arrForEach": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_13__.arrForEach),
/* harmony export */   "arrIndexOf": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_13__.arrIndexOf),
/* harmony export */   "arrMap": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_13__.arrMap),
/* harmony export */   "arrReduce": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_13__.arrReduce),
/* harmony export */   "attachEvent": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_14__.attachEvent),
/* harmony export */   "blockDynamicConversion": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_25__.blockDynamicConversion),
/* harmony export */   "convertAllHeadersToMap": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_15__.convertAllHeadersToMap),
/* harmony export */   "cookieAvailable": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_20__.areCookiesSupported),
/* harmony export */   "createCookieMgr": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_20__.createCookieMgr),
/* harmony export */   "createDynamicConfig": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_24__.createDynamicConfig),
/* harmony export */   "createEnumStyle": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_12__.createEnumStyle),
/* harmony export */   "createGuid": () => (/* reexport safe */ _Utils__WEBPACK_IMPORTED_MODULE_29__.createGuid),
/* harmony export */   "createProcessTelemetryContext": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_5__.createProcessTelemetryContext),
/* harmony export */   "createTraceParent": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_23__.createTraceParent),
/* harmony export */   "createUniqueNamespace": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_21__.createUniqueNamespace),
/* harmony export */   "createUnloadHandlerContainer": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_22__.createUnloadHandlerContainer),
/* harmony export */   "dateNow": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_13__.utcNow),
/* harmony export */   "detachEvent": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_14__.detachEvent),
/* harmony export */   "disallowsSameSiteNone": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_20__.uaDisallowsSameSiteNone),
/* harmony export */   "doPerf": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_10__.doPerf),
/* harmony export */   "dumpObj": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_13__.dumpObj),
/* harmony export */   "eventOff": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_14__.eventOff),
/* harmony export */   "eventOn": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_14__.eventOn),
/* harmony export */   "extend": () => (/* reexport safe */ _Utils__WEBPACK_IMPORTED_MODULE_29__.extend),
/* harmony export */   "findW3cTraceParent": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_23__.findW3cTraceParent),
/* harmony export */   "forceDynamicConversion": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_25__.forceDynamicConversion),
/* harmony export */   "formatErrorMessageXdr": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_15__.formatErrorMessageXdr),
/* harmony export */   "formatErrorMessageXhr": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_15__.formatErrorMessageXhr),
/* harmony export */   "formatTraceParent": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_23__.formatTraceParent),
/* harmony export */   "generateW3CId": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_16__.generateW3CId),
/* harmony export */   "getCommonSchemaMetaData": () => (/* reexport safe */ _Utils__WEBPACK_IMPORTED_MODULE_29__.getCommonSchemaMetaData),
/* harmony export */   "getConsole": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_18__.getConsole),
/* harmony export */   "getCookieValue": () => (/* reexport safe */ _Utils__WEBPACK_IMPORTED_MODULE_29__.getCookieValue),
/* harmony export */   "getCrypto": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_18__.getCrypto),
/* harmony export */   "getDocument": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_13__.getDocument),
/* harmony export */   "getDynamicConfigHandler": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_25__.getDynamicConfigHandler),
/* harmony export */   "getExceptionName": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_15__.getExceptionName),
/* harmony export */   "getFieldValueType": () => (/* reexport safe */ _Utils__WEBPACK_IMPORTED_MODULE_29__.getFieldValueType),
/* harmony export */   "getGlobal": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_13__.getGlobal),
/* harmony export */   "getGlobalInst": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_13__.getInst),
/* harmony export */   "getHistory": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_13__.getHistory),
/* harmony export */   "getIEVersion": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_18__.getIEVersion),
/* harmony export */   "getISOString": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_15__.toISOString),
/* harmony export */   "getJSON": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_18__.getJSON),
/* harmony export */   "getLocation": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_18__.getLocation),
/* harmony export */   "getMsCrypto": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_18__.getMsCrypto),
/* harmony export */   "getNavigator": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_13__.getNavigator),
/* harmony export */   "getPerformance": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_13__.getPerformance),
/* harmony export */   "getResponseText": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_15__.getResponseText),
/* harmony export */   "getSetValue": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_15__.getSetValue),
/* harmony export */   "getTenantId": () => (/* reexport safe */ _Utils__WEBPACK_IMPORTED_MODULE_29__.getTenantId),
/* harmony export */   "getTime": () => (/* reexport safe */ _Utils__WEBPACK_IMPORTED_MODULE_29__.getTime),
/* harmony export */   "getWindow": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_13__.getWindow),
/* harmony export */   "hasDocument": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_13__.hasDocument),
/* harmony export */   "hasHistory": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_13__.hasHistory),
/* harmony export */   "hasJSON": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_18__.hasJSON),
/* harmony export */   "hasNavigator": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_13__.hasNavigator),
/* harmony export */   "hasOwnProperty": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_13__.objHasOwnProperty),
/* harmony export */   "hasWindow": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_13__.hasWindow),
/* harmony export */   "isArray": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_13__.isArray),
/* harmony export */   "isArrayValid": () => (/* reexport safe */ _Utils__WEBPACK_IMPORTED_MODULE_29__.isArrayValid),
/* harmony export */   "isBeaconsSupported": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_18__.isBeaconsSupported),
/* harmony export */   "isBoolean": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_13__.isBoolean),
/* harmony export */   "isChromium": () => (/* reexport safe */ _Utils__WEBPACK_IMPORTED_MODULE_29__.isChromium),
/* harmony export */   "isDate": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_13__.isDate),
/* harmony export */   "isDocumentObjectAvailable": () => (/* reexport safe */ _Utils__WEBPACK_IMPORTED_MODULE_29__.isDocumentObjectAvailable),
/* harmony export */   "isError": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_13__.isError),
/* harmony export */   "isFetchSupported": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_18__.isFetchSupported),
/* harmony export */   "isFunction": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_13__.isFunction),
/* harmony export */   "isGreaterThanZero": () => (/* reexport safe */ _Utils__WEBPACK_IMPORTED_MODULE_29__.isGreaterThanZero),
/* harmony export */   "isIE": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_18__.isIE),
/* harmony export */   "isLatency": () => (/* reexport safe */ _Utils__WEBPACK_IMPORTED_MODULE_29__.isLatency),
/* harmony export */   "isNotTruthy": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_13__.isNotTruthy),
/* harmony export */   "isNullOrUndefined": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_13__.isNullOrUndefined),
/* harmony export */   "isNumber": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_13__.isNumber),
/* harmony export */   "isObject": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_13__.isObject),
/* harmony export */   "isReactNative": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_18__.isReactNative),
/* harmony export */   "isSampledFlag": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_23__.isSampledFlag),
/* harmony export */   "isString": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_13__.isString),
/* harmony export */   "isTruthy": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_13__.isTruthy),
/* harmony export */   "isTypeof": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_13__.isTypeof),
/* harmony export */   "isUint8ArrayAvailable": () => (/* reexport safe */ _Utils__WEBPACK_IMPORTED_MODULE_29__.isUint8ArrayAvailable),
/* harmony export */   "isUndefined": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_13__.isUndefined),
/* harmony export */   "isValidSpanId": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_23__.isValidSpanId),
/* harmony export */   "isValidTraceId": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_23__.isValidTraceId),
/* harmony export */   "isValidTraceParent": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_23__.isValidTraceParent),
/* harmony export */   "isValueAssigned": () => (/* reexport safe */ _Utils__WEBPACK_IMPORTED_MODULE_29__.isValueAssigned),
/* harmony export */   "isValueKind": () => (/* reexport safe */ _Utils__WEBPACK_IMPORTED_MODULE_29__.isValueKind),
/* harmony export */   "isWindowObjectAvailable": () => (/* reexport safe */ _Utils__WEBPACK_IMPORTED_MODULE_29__.isWindowObjectAvailable),
/* harmony export */   "isXhrSupported": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_18__.isXhrSupported),
/* harmony export */   "mergeEvtNamespace": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_14__.mergeEvtNamespace),
/* harmony export */   "newGuid": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_16__.newGuid),
/* harmony export */   "newId": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_17__.newId),
/* harmony export */   "normalizeJsName": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_15__.normalizeJsName),
/* harmony export */   "objDefineAccessors": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_13__.objDefineAccessors),
/* harmony export */   "objForEachKey": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_13__.objForEachKey),
/* harmony export */   "objFreeze": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_13__.objFreeze),
/* harmony export */   "objKeys": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_13__.objKeys),
/* harmony export */   "objSeal": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_13__.objSeal),
/* harmony export */   "onConfigChange": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_24__.onConfigChange),
/* harmony export */   "openXhr": () => (/* reexport safe */ _Utils__WEBPACK_IMPORTED_MODULE_29__.openXhr),
/* harmony export */   "optimizeObject": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_15__.optimizeObject),
/* harmony export */   "parseResponse": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_27__.parseResponse),
/* harmony export */   "parseTraceParent": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_23__.parseTraceParent),
/* harmony export */   "perfNow": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_13__.perfNow),
/* harmony export */   "prependTransports": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_15__.prependTransports),
/* harmony export */   "proxyAssign": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_15__.proxyAssign),
/* harmony export */   "proxyFunctionAs": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_15__.proxyFunctionAs),
/* harmony export */   "proxyFunctions": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_15__.proxyFunctions),
/* harmony export */   "random32": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_17__.random32),
/* harmony export */   "randomValue": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_17__.randomValue),
/* harmony export */   "removeEventHandler": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_14__.removeEventHandler),
/* harmony export */   "removeEventListeners": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_14__.removeEventListeners),
/* harmony export */   "removePageHideEventListener": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_14__.removePageHideEventListener),
/* harmony export */   "removePageShowEventListener": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_14__.removePageShowEventListener),
/* harmony export */   "removePageUnloadEventListener": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_14__.removePageUnloadEventListener),
/* harmony export */   "safeGetCookieMgr": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_20__.safeGetCookieMgr),
/* harmony export */   "safeGetLogger": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_8__.safeGetLogger),
/* harmony export */   "sanitizeProperty": () => (/* reexport safe */ _Utils__WEBPACK_IMPORTED_MODULE_29__.sanitizeProperty),
/* harmony export */   "setEnableEnvMocks": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_18__.setEnableEnvMocks),
/* harmony export */   "setProcessTelemetryTimings": () => (/* reexport safe */ _Utils__WEBPACK_IMPORTED_MODULE_29__.setProcessTelemetryTimings),
/* harmony export */   "setValue": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_15__.setValue),
/* harmony export */   "strContains": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_15__.strContains),
/* harmony export */   "strEndsWith": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_13__.strEndsWith),
/* harmony export */   "strFunction": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_19__.strShimFunction),
/* harmony export */   "strObject": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_19__.strShimObject),
/* harmony export */   "strPrototype": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_19__.strShimPrototype),
/* harmony export */   "strStartsWith": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_13__.strStartsWith),
/* harmony export */   "strTrim": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_13__.strTrim),
/* harmony export */   "strUndefined": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_19__.strShimUndefined),
/* harmony export */   "throwError": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_13__.throwError),
/* harmony export */   "toISOString": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_15__.toISOString),
/* harmony export */   "useXDomainRequest": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_18__.useXDomainRequest)
/* harmony export */ });
/* harmony import */ var _AppInsightsCore__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(31);
/* harmony import */ var _Enums__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28);
/* harmony import */ var _ValueSanitizer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(69);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(57);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(65);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(61);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(70);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(71);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(50);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(72);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(37);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(54);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(29);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(30);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(73);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(45);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(53);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(43);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(44);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(34);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(58);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(42);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(67);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(63);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(40);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(41);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(74);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(75);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(66);
/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(52);
/*
 * 1DS JS SDK Core, 4.3.0
 * Copyright (c) Microsoft and contributors. All rights reserved.
 * (Microsoft Internal Only)
 */
/**
* Index.ts
* @author Abhilash Panwar (abpanwar)
* @copyright Microsoft 2018
* File to export public classes, interfaces and enums.
*/






//# sourceMappingURL=Index.js.map

/***/ }),
/* 28 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EventLatency": () => (/* binding */ EventLatency),
/* harmony export */   "EventPersistence": () => (/* binding */ EventPersistence),
/* harmony export */   "EventPropertyType": () => (/* binding */ EventPropertyType),
/* harmony export */   "TraceLevel": () => (/* binding */ TraceLevel),
/* harmony export */   "ValueKind": () => (/* binding */ ValueKind)
/* harmony export */ });
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(29);
/*
 * 1DS JS SDK Core, 4.3.0
 * Copyright (c) Microsoft and contributors. All rights reserved.
 * (Microsoft Internal Only)
 */
/**
* Enums.ts
* @author Abhilash Panwar (abpanwar)
* @copyright Microsoft 2018
* File containing the enums as constants.
*/

/**
 * The ValueKind contains a set of values that specify value kind of the property.
 * Either PII (Personal Identifiable Information) or customer content.
 */
var ValueKind = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.createEnumStyle)({
    NotSet: 0 /* eValueKind.NotSet */,
    Pii_DistinguishedName: 1 /* eValueKind.Pii_DistinguishedName */,
    Pii_GenericData: 2 /* eValueKind.Pii_GenericData */,
    Pii_IPV4Address: 3 /* eValueKind.Pii_IPV4Address */,
    Pii_IPv6Address: 4 /* eValueKind.Pii_IPv6Address */,
    Pii_MailSubject: 5 /* eValueKind.Pii_MailSubject */,
    Pii_PhoneNumber: 6 /* eValueKind.Pii_PhoneNumber */,
    Pii_QueryString: 7 /* eValueKind.Pii_QueryString */,
    Pii_SipAddress: 8 /* eValueKind.Pii_SipAddress */,
    Pii_SmtpAddress: 9 /* eValueKind.Pii_SmtpAddress */,
    Pii_Identity: 10 /* eValueKind.Pii_Identity */,
    Pii_Uri: 11 /* eValueKind.Pii_Uri */,
    Pii_Fqdn: 12 /* eValueKind.Pii_Fqdn */,
    Pii_IPV4AddressLegacy: 13 /* eValueKind.Pii_IPV4AddressLegacy */,
    Pii_IPv6ScrubLastHextets: 14 /* eValueKind.Pii_IPv6ScrubLastHextets */,
    Pii_DropValue: 15 /* eValueKind.Pii_DropValue */,
    CustomerContent_GenericContent: 32 /* eValueKind.CustomerContent_GenericContent */
});
/**
 * The EventLatency contains a set of values that specify the latency with which an event is sent.
 */
var EventLatency = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.createEnumStyle)({
    /**
     * Normal latency.
     */
    Normal: 1 /* EventLatencyValue.Normal */,
    /**
     * Cost deferred latency. At the moment this latency is treated as Normal latency.
     */
    CostDeferred: 2 /* EventLatencyValue.CostDeferred */,
    /**
     * Real time latency.
     */
    RealTime: 3 /* EventLatencyValue.RealTime */,
    /**
     * Bypass normal batching/timing and send as soon as possible, this will still send asynchronously.
     * Added in v3.1.1
     */
    Immediate: 4 /* EventLatencyValue.Immediate */
});
/**
 * Enum for property types.
 */
var EventPropertyType = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.createEnumStyle)({
    Unspecified: 0 /* eEventPropertyType.Unspecified */,
    String: 1 /* eEventPropertyType.String */,
    Int32: 2 /* eEventPropertyType.Int32 */,
    UInt32: 3 /* eEventPropertyType.UInt32 */,
    Int64: 4 /* eEventPropertyType.Int64 */,
    UInt64: 5 /* eEventPropertyType.UInt64 */,
    Double: 6 /* eEventPropertyType.Double */,
    Bool: 7 /* eEventPropertyType.Bool */,
    Guid: 8 /* eEventPropertyType.Guid */,
    DateTime: 9 /* eEventPropertyType.DateTime */
});
/**
 * The EventPersistence contains a set of values that specify the event's persistence.
 */
var EventPersistence = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.createEnumStyle)({
    /**
     * Normal persistence.
     */
    Normal: 1 /* EventPersistenceValue.Normal */,
    /**
     * Critical persistence.
     */
    Critical: 2 /* EventPersistenceValue.Critical */
});
var TraceLevel = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.createEnumStyle)({
    NONE: 0 /* eTraceLevel.NONE */,
    ERROR: 1 /* eTraceLevel.ERROR */,
    WARNING: 2 /* eTraceLevel.WARNING */,
    INFORMATION: 3 /* eTraceLevel.INFORMATION */
});
//# sourceMappingURL=Enums.js.map

/***/ }),
/* 29 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createEnumStyle": () => (/* binding */ createEnumStyle),
/* harmony export */   "createValueMap": () => (/* binding */ createValueMap)
/* harmony export */ });
/* harmony import */ var _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(30);
/*
 * Application Insights JavaScript SDK - Core, 3.3.0
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */



/**
 * Create an enum style object which has both the key => value and value => key mappings
 * @param values - The values to populate on the new object
 * @returns
 */
var createEnumStyle = _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.createEnum;
/**
 * Create a 2 index map that maps an enum's key and value to the defined map value, X["key"] => mapValue and X[0] => mapValue.
 * Generic values
 * - E = the const enum type (typeof eRequestHeaders);
 * - V = Identifies the valid values for the keys, this should include both the enum numeric and string key of the type. The
 * resulting "Value" of each entry identifies the valid values withing the assignments.
 * @param values - The values to populate on the new object
 * @returns
 */
var createValueMap = _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.createTypeMap;
//# sourceMappingURL=EnumHelperFuncs.js.map

/***/ }),
/* 30 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "arrAppend": () => (/* binding */ arrAppend),
/* harmony export */   "arrContains": () => (/* binding */ arrContains),
/* harmony export */   "arrEvery": () => (/* binding */ arrEvery),
/* harmony export */   "arrFilter": () => (/* binding */ arrFilter),
/* harmony export */   "arrFind": () => (/* binding */ arrFind),
/* harmony export */   "arrFindIndex": () => (/* binding */ arrFindIndex),
/* harmony export */   "arrFindLast": () => (/* binding */ arrFindLast),
/* harmony export */   "arrFindLastIndex": () => (/* binding */ arrFindLastIndex),
/* harmony export */   "arrForEach": () => (/* binding */ arrForEach),
/* harmony export */   "arrFrom": () => (/* binding */ arrFrom),
/* harmony export */   "arrIncludes": () => (/* binding */ arrIncludes),
/* harmony export */   "arrIndexOf": () => (/* binding */ arrIndexOf),
/* harmony export */   "arrLastIndexOf": () => (/* binding */ arrLastIndexOf),
/* harmony export */   "arrMap": () => (/* binding */ arrMap),
/* harmony export */   "arrReduce": () => (/* binding */ arrReduce),
/* harmony export */   "arrSlice": () => (/* binding */ arrSlice),
/* harmony export */   "arrSome": () => (/* binding */ arrSome),
/* harmony export */   "arrayDeepCopyHandler": () => (/* binding */ arrayDeepCopyHandler),
/* harmony export */   "asString": () => (/* binding */ asString),
/* harmony export */   "createArrayIterator": () => (/* binding */ createArrayIterator),
/* harmony export */   "createCachedValue": () => (/* binding */ createCachedValue),
/* harmony export */   "createCustomError": () => (/* binding */ createCustomError),
/* harmony export */   "createDeferredCachedValue": () => (/* binding */ createDeferredCachedValue),
/* harmony export */   "createEnum": () => (/* binding */ createEnum),
/* harmony export */   "createEnumKeyMap": () => (/* binding */ createEnumKeyMap),
/* harmony export */   "createEnumValueMap": () => (/* binding */ createEnumValueMap),
/* harmony export */   "createFilenameRegex": () => (/* binding */ createFilenameRegex),
/* harmony export */   "createFnDeferredProxy": () => (/* binding */ createFnDeferredProxy),
/* harmony export */   "createIterable": () => (/* binding */ createIterable),
/* harmony export */   "createIterator": () => (/* binding */ createIterator),
/* harmony export */   "createProxyFuncs": () => (/* binding */ createProxyFuncs),
/* harmony export */   "createRangeIterator": () => (/* binding */ createRangeIterator),
/* harmony export */   "createSimpleMap": () => (/* binding */ createSimpleMap),
/* harmony export */   "createTimeout": () => (/* binding */ createTimeout),
/* harmony export */   "createTimeoutWith": () => (/* binding */ createTimeoutWith),
/* harmony export */   "createTypeMap": () => (/* binding */ createTypeMap),
/* harmony export */   "createWildcardRegex": () => (/* binding */ createWildcardRegex),
/* harmony export */   "dateDeepCopyHandler": () => (/* binding */ dateDeepCopyHandler),
/* harmony export */   "deepExtend": () => (/* binding */ deepExtend),
/* harmony export */   "dumpObj": () => (/* binding */ dumpObj),
/* harmony export */   "elapsedTime": () => (/* binding */ elapsedTime),
/* harmony export */   "encodeAsHtml": () => (/* binding */ encodeAsHtml),
/* harmony export */   "encodeAsJson": () => (/* binding */ encodeAsJson),
/* harmony export */   "fnApply": () => (/* binding */ fnApply),
/* harmony export */   "fnBind": () => (/* binding */ fnBind),
/* harmony export */   "fnCall": () => (/* binding */ fnCall),
/* harmony export */   "functionDeepCopyHandler": () => (/* binding */ functionDeepCopyHandler),
/* harmony export */   "getCancelIdleCallback": () => (/* binding */ getCancelIdleCallback),
/* harmony export */   "getDocument": () => (/* binding */ getDocument),
/* harmony export */   "getGlobal": () => (/* binding */ getGlobal),
/* harmony export */   "getHistory": () => (/* binding */ getHistory),
/* harmony export */   "getIdleCallback": () => (/* binding */ getIdleCallback),
/* harmony export */   "getInst": () => (/* binding */ getInst),
/* harmony export */   "getIntValue": () => (/* binding */ getIntValue),
/* harmony export */   "getKnownSymbol": () => (/* binding */ getKnownSymbol),
/* harmony export */   "getLazy": () => (/* binding */ getLazy),
/* harmony export */   "getLength": () => (/* binding */ getLength),
/* harmony export */   "getNavigator": () => (/* binding */ getNavigator),
/* harmony export */   "getPerformance": () => (/* binding */ getPerformance),
/* harmony export */   "getSymbol": () => (/* binding */ getSymbol),
/* harmony export */   "getValueByIter": () => (/* binding */ getValueByIter),
/* harmony export */   "getValueByKey": () => (/* binding */ getValueByKey),
/* harmony export */   "getWindow": () => (/* binding */ getWindow),
/* harmony export */   "hasDocument": () => (/* binding */ hasDocument),
/* harmony export */   "hasHistory": () => (/* binding */ hasHistory),
/* harmony export */   "hasIdleCallback": () => (/* binding */ hasIdleCallback),
/* harmony export */   "hasNavigator": () => (/* binding */ hasNavigator),
/* harmony export */   "hasPerformance": () => (/* binding */ hasPerformance),
/* harmony export */   "hasSymbol": () => (/* binding */ hasSymbol),
/* harmony export */   "hasValue": () => (/* binding */ hasValue),
/* harmony export */   "hasWindow": () => (/* binding */ hasWindow),
/* harmony export */   "isArray": () => (/* binding */ isArray),
/* harmony export */   "isArrayBuffer": () => (/* binding */ isArrayBuffer),
/* harmony export */   "isBlob": () => (/* binding */ isBlob),
/* harmony export */   "isBoolean": () => (/* binding */ isBoolean),
/* harmony export */   "isDate": () => (/* binding */ isDate),
/* harmony export */   "isDefined": () => (/* binding */ isDefined),
/* harmony export */   "isError": () => (/* binding */ isError),
/* harmony export */   "isFile": () => (/* binding */ isFile),
/* harmony export */   "isFormData": () => (/* binding */ isFormData),
/* harmony export */   "isFunction": () => (/* binding */ isFunction),
/* harmony export */   "isIterable": () => (/* binding */ isIterable),
/* harmony export */   "isIterator": () => (/* binding */ isIterator),
/* harmony export */   "isNode": () => (/* binding */ isNode),
/* harmony export */   "isNotTruthy": () => (/* binding */ isNotTruthy),
/* harmony export */   "isNullOrUndefined": () => (/* binding */ isNullOrUndefined),
/* harmony export */   "isNumber": () => (/* binding */ isNumber),
/* harmony export */   "isObject": () => (/* binding */ isObject),
/* harmony export */   "isPlainObject": () => (/* binding */ isPlainObject),
/* harmony export */   "isPrimitive": () => (/* binding */ isPrimitive),
/* harmony export */   "isPrimitiveType": () => (/* binding */ isPrimitiveType),
/* harmony export */   "isPromise": () => (/* binding */ isPromise),
/* harmony export */   "isPromiseLike": () => (/* binding */ isPromiseLike),
/* harmony export */   "isRegExp": () => (/* binding */ isRegExp),
/* harmony export */   "isStrictNullOrUndefined": () => (/* binding */ isStrictNullOrUndefined),
/* harmony export */   "isStrictUndefined": () => (/* binding */ isStrictUndefined),
/* harmony export */   "isString": () => (/* binding */ isString),
/* harmony export */   "isSymbol": () => (/* binding */ isSymbol),
/* harmony export */   "isThenable": () => (/* binding */ isThenable),
/* harmony export */   "isTruthy": () => (/* binding */ isTruthy),
/* harmony export */   "isTypeof": () => (/* binding */ isTypeof),
/* harmony export */   "isUndefined": () => (/* binding */ isUndefined),
/* harmony export */   "isWebWorker": () => (/* binding */ isWebWorker),
/* harmony export */   "iterForOf": () => (/* binding */ iterForOf),
/* harmony export */   "lazySafeGetInst": () => (/* binding */ lazySafeGetInst),
/* harmony export */   "makeGlobRegex": () => (/* binding */ makeGlobRegex),
/* harmony export */   "makeIterable": () => (/* binding */ makeIterable),
/* harmony export */   "mathCeil": () => (/* binding */ mathCeil),
/* harmony export */   "mathFloor": () => (/* binding */ mathFloor),
/* harmony export */   "mathMax": () => (/* binding */ mathMax),
/* harmony export */   "mathMin": () => (/* binding */ mathMin),
/* harmony export */   "mathToInt": () => (/* binding */ mathToInt),
/* harmony export */   "mathTrunc": () => (/* binding */ mathTrunc),
/* harmony export */   "newSymbol": () => (/* binding */ newSymbol),
/* harmony export */   "normalizeJsName": () => (/* binding */ normalizeJsName),
/* harmony export */   "objAssign": () => (/* binding */ objAssign),
/* harmony export */   "objCopyProps": () => (/* binding */ objCopyProps),
/* harmony export */   "objCreate": () => (/* binding */ objCreate),
/* harmony export */   "objDeepCopy": () => (/* binding */ objDeepCopy),
/* harmony export */   "objDeepFreeze": () => (/* binding */ objDeepFreeze),
/* harmony export */   "objDefine": () => (/* binding */ objDefine),
/* harmony export */   "objDefineAccessors": () => (/* binding */ objDefineAccessors),
/* harmony export */   "objDefineGet": () => (/* binding */ objDefineGet),
/* harmony export */   "objDefineProp": () => (/* binding */ objDefineProp),
/* harmony export */   "objDefineProperties": () => (/* binding */ objDefineProperties),
/* harmony export */   "objDefineProps": () => (/* binding */ objDefineProps),
/* harmony export */   "objEntries": () => (/* binding */ objEntries),
/* harmony export */   "objExtend": () => (/* binding */ objExtend),
/* harmony export */   "objForEachKey": () => (/* binding */ objForEachKey),
/* harmony export */   "objFreeze": () => (/* binding */ objFreeze),
/* harmony export */   "objGetOwnPropertyDescriptor": () => (/* binding */ objGetOwnPropertyDescriptor),
/* harmony export */   "objGetPrototypeOf": () => (/* binding */ objGetPrototypeOf),
/* harmony export */   "objHasOwn": () => (/* binding */ objHasOwn),
/* harmony export */   "objHasOwnProperty": () => (/* binding */ objHasOwnProperty),
/* harmony export */   "objKeys": () => (/* binding */ objKeys),
/* harmony export */   "objSeal": () => (/* binding */ objSeal),
/* harmony export */   "objSetPrototypeOf": () => (/* binding */ objSetPrototypeOf),
/* harmony export */   "objToString": () => (/* binding */ objToString),
/* harmony export */   "perfNow": () => (/* binding */ perfNow),
/* harmony export */   "plainObjDeepCopyHandler": () => (/* binding */ plainObjDeepCopyHandler),
/* harmony export */   "polyArrFind": () => (/* binding */ polyArrFind),
/* harmony export */   "polyArrFindIndex": () => (/* binding */ polyArrFindIndex),
/* harmony export */   "polyArrFindLast": () => (/* binding */ polyArrFindLast),
/* harmony export */   "polyArrFindLastIndex": () => (/* binding */ polyArrFindLastIndex),
/* harmony export */   "polyArrFrom": () => (/* binding */ polyArrFrom),
/* harmony export */   "polyArrIncludes": () => (/* binding */ polyArrIncludes),
/* harmony export */   "polyGetKnownSymbol": () => (/* binding */ polyGetKnownSymbol),
/* harmony export */   "polyIsArray": () => (/* binding */ polyIsArray),
/* harmony export */   "polyNewSymbol": () => (/* binding */ polyNewSymbol),
/* harmony export */   "polyObjEntries": () => (/* binding */ polyObjEntries),
/* harmony export */   "polyObjHasOwn": () => (/* binding */ polyObjHasOwn),
/* harmony export */   "polyObjKeys": () => (/* binding */ polyObjKeys),
/* harmony export */   "polyStrIncludes": () => (/* binding */ polyStrIncludes),
/* harmony export */   "polyStrSubstr": () => (/* binding */ polyStrSubstr),
/* harmony export */   "polyStrSymSplit": () => (/* binding */ polyStrSymSplit),
/* harmony export */   "polyStrTrim": () => (/* binding */ polyStrTrim),
/* harmony export */   "polyStrTrimEnd": () => (/* binding */ polyStrTrimEnd),
/* harmony export */   "polyStrTrimStart": () => (/* binding */ polyStrTrimStart),
/* harmony export */   "polySymbolFor": () => (/* binding */ polySymbolFor),
/* harmony export */   "polySymbolKeyFor": () => (/* binding */ polySymbolKeyFor),
/* harmony export */   "polyUtcNow": () => (/* binding */ polyUtcNow),
/* harmony export */   "readArgs": () => (/* binding */ readArgs),
/* harmony export */   "safe": () => (/* binding */ safe),
/* harmony export */   "safeGet": () => (/* binding */ safeGet),
/* harmony export */   "safeGetLazy": () => (/* binding */ safeGetLazy),
/* harmony export */   "scheduleIdleCallback": () => (/* binding */ scheduleIdleCallback),
/* harmony export */   "scheduleInterval": () => (/* binding */ scheduleInterval),
/* harmony export */   "scheduleTimeout": () => (/* binding */ scheduleTimeout),
/* harmony export */   "scheduleTimeoutWith": () => (/* binding */ scheduleTimeoutWith),
/* harmony export */   "setBypassLazyCache": () => (/* binding */ setBypassLazyCache),
/* harmony export */   "setDefaultIdleTimeout": () => (/* binding */ setDefaultIdleTimeout),
/* harmony export */   "setDefaultMaxExecutionTime": () => (/* binding */ setDefaultMaxExecutionTime),
/* harmony export */   "setValueByIter": () => (/* binding */ setValueByIter),
/* harmony export */   "setValueByKey": () => (/* binding */ setValueByKey),
/* harmony export */   "strCamelCase": () => (/* binding */ strCamelCase),
/* harmony export */   "strContains": () => (/* binding */ strContains),
/* harmony export */   "strEndsWith": () => (/* binding */ strEndsWith),
/* harmony export */   "strIncludes": () => (/* binding */ strIncludes),
/* harmony export */   "strIndexOf": () => (/* binding */ strIndexOf),
/* harmony export */   "strIsNullOrEmpty": () => (/* binding */ strIsNullOrEmpty),
/* harmony export */   "strIsNullOrWhiteSpace": () => (/* binding */ strIsNullOrWhiteSpace),
/* harmony export */   "strKebabCase": () => (/* binding */ strKebabCase),
/* harmony export */   "strLastIndexOf": () => (/* binding */ strLastIndexOf),
/* harmony export */   "strLeft": () => (/* binding */ strLeft),
/* harmony export */   "strLetterCase": () => (/* binding */ strLetterCase),
/* harmony export */   "strLower": () => (/* binding */ strLower),
/* harmony export */   "strPadEnd": () => (/* binding */ strPadEnd),
/* harmony export */   "strPadStart": () => (/* binding */ strPadStart),
/* harmony export */   "strRepeat": () => (/* binding */ strRepeat),
/* harmony export */   "strRight": () => (/* binding */ strRight),
/* harmony export */   "strSlice": () => (/* binding */ strSlice),
/* harmony export */   "strSnakeCase": () => (/* binding */ strSnakeCase),
/* harmony export */   "strSplit": () => (/* binding */ strSplit),
/* harmony export */   "strStartsWith": () => (/* binding */ strStartsWith),
/* harmony export */   "strSubstr": () => (/* binding */ strSubstr),
/* harmony export */   "strSubstring": () => (/* binding */ strSubstring),
/* harmony export */   "strSymSplit": () => (/* binding */ strSymSplit),
/* harmony export */   "strTrim": () => (/* binding */ strTrim),
/* harmony export */   "strTrimEnd": () => (/* binding */ strTrimEnd),
/* harmony export */   "strTrimLeft": () => (/* binding */ strTrimLeft),
/* harmony export */   "strTrimRight": () => (/* binding */ strTrimRight),
/* harmony export */   "strTrimStart": () => (/* binding */ strTrimStart),
/* harmony export */   "strUpper": () => (/* binding */ strUpper),
/* harmony export */   "symbolFor": () => (/* binding */ symbolFor),
/* harmony export */   "symbolKeyFor": () => (/* binding */ symbolKeyFor),
/* harmony export */   "throwError": () => (/* binding */ throwError),
/* harmony export */   "throwRangeError": () => (/* binding */ throwRangeError),
/* harmony export */   "throwTypeError": () => (/* binding */ throwTypeError),
/* harmony export */   "throwUnsupported": () => (/* binding */ throwUnsupported),
/* harmony export */   "utcNow": () => (/* binding */ utcNow)
/* harmony export */ });
/*! https://github.com/nevware21/ts-utils v0.11.3 */
/*
 * Copyright (c) NevWare21 Solutions LLC and contributors. All rights reserved.
 * Licensed under the MIT license.
 */
/*#__NO_SIDE_EFFECTS__*/
function _pureAssign(func1, func2) {
    return func1 || func2;
}
/*#__NO_SIDE_EFFECTS__*/
function _pureRef(value, name) {
    return value[name];
}

var UNDEF_VALUE = undefined;
var NULL_VALUE = null;
var EMPTY = "";
var FUNCTION = "function";
var OBJECT = "object";
var PROTOTYPE = "prototype";
var __PROTO__ = "__proto__";
var UNDEFINED = "undefined";
var CONSTRUCTOR = "constructor";
var SYMBOL = "Symbol";
var POLYFILL_TAG = "_polyfill";
var LENGTH = "length";
var NAME = "name";
var CALL = "call";
var TO_STRING = "toString";
var ObjClass = ( /*#__PURE__*/_pureAssign(Object));
var ObjProto = ( /*#__PURE__*/_pureRef(ObjClass, PROTOTYPE));
var StrCls = ( /*#__PURE__*/_pureAssign(String));
var StrProto = ( /*#__PURE__*/_pureRef(StrCls, PROTOTYPE));
var MathCls = ( /*#__PURE__*/_pureAssign(Math));
var ArrCls = ( /*#__PURE__*/_pureAssign(Array));
var ArrProto = ( /*#__PURE__*/_pureRef(ArrCls, PROTOTYPE));
var ArrSlice = ( /*#__PURE__*/_pureRef(ArrProto, "slice"));

function safe(func, argArray) {
    try {
        return {
            v: func.apply(this, argArray)
        };
    }
    catch (e) {
        return { e: e };
    }
}

/*#__NO_SIDE_EFFECTS__*/
function safeGet(cb, defValue) {
    var result = safe(cb);
    return result.e ? defValue : result.v;
}

var _primitiveTypes;
/*#__NO_SIDE_EFFECTS__*/
function _createIs(theType) {
    return function (value) {
        return typeof value === theType;
    };
}
/*#__NO_SIDE_EFFECTS__*/
function _createObjIs(theName) {
    var theType = "[object " + theName + "]";
    return function (value) {
        return !!(value && objToString(value) === theType);
    };
}
/*#__NO_SIDE_EFFECTS__*/
function objToString(value) {
    return ObjProto[TO_STRING].call(value);
}
/*#__NO_SIDE_EFFECTS__*/
function isTypeof(value, theType) {
    return typeof value === theType;
}
/*#__NO_SIDE_EFFECTS__*/
function isUndefined(value) {
    return typeof value === UNDEFINED || value === UNDEFINED;
}
/*#__NO_SIDE_EFFECTS__*/
function isStrictUndefined(arg) {
    return !isDefined(arg);
}
/*#__NO_SIDE_EFFECTS__*/
function isNullOrUndefined(value) {
    return value === NULL_VALUE || isUndefined(value);
}
/*#__NO_SIDE_EFFECTS__*/
function isStrictNullOrUndefined(value) {
    return value === NULL_VALUE || !isDefined(value);
}
/*#__NO_SIDE_EFFECTS__*/
function isDefined(arg) {
    return !!arg || arg !== UNDEF_VALUE;
}
/*#__NO_SIDE_EFFECTS__*/
function isPrimitive(value) {
    return value === NULL_VALUE || isPrimitiveType(typeof value);
}
/*#__NO_SIDE_EFFECTS__*/
function isPrimitiveType(theType) {
    !_primitiveTypes && (_primitiveTypes = ["string", "number", "boolean", UNDEFINED, "symbol", "bigint"]);
    return theType !== OBJECT && _primitiveTypes.indexOf(theType) !== -1;
}
var isString = ( /*#__PURE__*/_createIs("string"));
var isFunction = ( /*#__PURE__*/_createIs(FUNCTION));
/*#__NO_SIDE_EFFECTS__*/
function isObject(value) {
    if (!value && isNullOrUndefined(value)) {
        return false;
    }
    return !!value && typeof value === OBJECT;
}
var isArray = ( /* #__PURE__*/_pureRef(ArrCls, "isArray"));
var isDate = ( /*#__PURE__*/_createObjIs("Date"));
var isNumber = ( /*#__PURE__*/_createIs("number"));
var isBoolean = ( /*#__PURE__*/_createIs("boolean"));
var isRegExp = ( /*#__PURE__*/_createObjIs("RegExp"));
var isFile = ( /*#__PURE__*/_createObjIs("File"));
var isFormData = ( /*#__PURE__*/_createObjIs("FormData"));
var isBlob = ( /*#__PURE__*/_createObjIs("Blob"));
var isArrayBuffer = ( /*#__PURE__*/_createObjIs("ArrayBuffer"));
var isError = ( /*#__PURE__*/_createObjIs("Error"));
/*#__NO_SIDE_EFFECTS__*/
function isPromiseLike(value) {
    return !!(value && value.then && isFunction(value.then));
}
var isThenable = isPromiseLike;
/*#__NO_SIDE_EFFECTS__*/
function isPromise(value) {
    return !!(value && value.then && value.catch && isFunction(value.then) && isFunction(value.catch));
}
/*#__NO_SIDE_EFFECTS__*/
function isNotTruthy(value) {
    return !value || !isTruthy(value);
}
/*#__NO_SIDE_EFFECTS__*/
function isTruthy(value) {
    return !(!value || safeGet(function () { return !(value && (0 + value)); }, !value));
}

var objGetOwnPropertyDescriptor = ( /* #__PURE__ */_pureRef(ObjClass, "getOwnPropertyDescriptor"));

/*#__NO_SIDE_EFFECTS__*/
function objHasOwnProperty(obj, prop) {
    return !!obj && ObjProto.hasOwnProperty[CALL](obj, prop);
}

var objHasOwn = ( /*#__PURE__*/_pureAssign(( /* #__PURE__ */_pureRef(ObjClass, "hasOwn")), polyObjHasOwn));
/*#__NO_SIDE_EFFECTS__*/
function polyObjHasOwn(obj, prop) {
    return objHasOwnProperty(obj, prop) || !!objGetOwnPropertyDescriptor(obj, prop);
}

function objForEachKey(theObject, callbackfn, thisArg) {
    if (theObject && isObject(theObject)) {
        for (var prop in theObject) {
            if (objHasOwn(theObject, prop)) {
                if (callbackfn[CALL](thisArg || theObject, prop, theObject[prop]) === -1) {
                    break;
                }
            }
        }
    }
}

var propMap = {
    e: "enumerable",
    c: "configurable",
    v: "value",
    w: "writable",
    g: "get",
    s: "set"
};
/*#__NO_SIDE_EFFECTS__*/
function _createProp(value) {
    var prop = {};
    prop[propMap["c"]] = true;
    prop[propMap["e"]] = true;
    if (value.l) {
        prop.get = function () { return value.l.v; };
        var desc = objGetOwnPropertyDescriptor(value.l, "v");
        if (desc && desc.set) {
            prop.set = function (newValue) {
                value.l.v = newValue;
            };
        }
    }
    objForEachKey(value, function (key, value) {
        prop[propMap[key]] = isUndefined(value) ? prop[propMap[key]] : value;
    });
    return prop;
}
var objDefineProp = ( /*#__PURE__*/_pureRef(ObjClass, "defineProperty"));
var objDefineProperties = ( /*#__PURE__*/_pureRef(ObjClass, "defineProperties"));
function objDefineGet(target, key, value, configurable, enumerable) {
    var _a;
    return objDefineProp(target, key, _createProp((_a = {
            e: enumerable,
            c: configurable
        },
        _a[isFunction(value) ? "g" : "v"] = value,
        _a)));
}
function objDefineAccessors(target, prop, getProp, setProp, configurable, enumerable) {
    var desc = {
        e: enumerable,
        c: configurable
    };
    if (getProp) {
        desc.g = getProp;
    }
    if (setProp) {
        desc.s = setProp;
    }
    return objDefineProp(target, prop, _createProp(desc));
}
function objDefine(target, key, propDesc) {
    return objDefineProp(target, key, _createProp(propDesc));
}
function objDefineProps(target, propDescMap) {
    var props = {};
    objForEachKey(propDescMap, function (key, value) {
        props[key] = _createProp(value);
    });
    return objDefineProperties(target, props);
}

/*#__NO_SIDE_EFFECTS__*/
function _createKeyValueMap(values, keyType, valueType, completeFn, writable) {
    var theMap = {};
    objForEachKey(values, function (key, value) {
        _assignMapValue(theMap, key, keyType ? value : key, writable);
        _assignMapValue(theMap, value, valueType ? value : key, writable);
    });
    return completeFn ? completeFn(theMap) : theMap;
}
function _assignMapValue(theMap, key, value, writable) {
    objDefineProp(theMap, key, {
        value: value,
        enumerable: true,
        writable: !!writable
    });
}

var asString = ( /* #__PURE__ */_pureAssign(StrCls));

var ERROR_TYPE = "[object Error]";
/*#__NO_SIDE_EFFECTS__*/
function dumpObj(object, format) {
    var propertyValueDump = EMPTY;
    var objType = ObjProto[TO_STRING][CALL](object);
    if (objType === ERROR_TYPE) {
        object = { stack: asString(object.stack), message: asString(object.message), name: asString(object.name) };
    }
    try {
        propertyValueDump = JSON.stringify(object, NULL_VALUE, format ? ((typeof format === "number") ? format : 4) : UNDEF_VALUE);
        propertyValueDump = (propertyValueDump && propertyValueDump.replace(/"(\w+)"\s*:\s{0,1}/g, "$1: ")) || asString(object);
    }
    catch (e) {
        propertyValueDump = " - " + dumpObj(e, format);
    }
    return objType + ": " + propertyValueDump;
}

function throwError(message) {
    throw new Error(message);
}
function throwTypeError(message) {
    throw new TypeError(message);
}
function throwRangeError(message) {
    throw new RangeError(message);
}

/*#__NO_SIDE_EFFECTS__*/
function polyObjKeys(obj) {
    if (!isObject(obj) || obj === NULL_VALUE) {
        throwTypeError("non-object " + dumpObj(obj));
    }
    var result = [];
    for (var prop in obj) {
        if (objHasOwn(obj, prop)) {
            result.push(prop);
        }
    }
    return result;
}
/*#__NO_SIDE_EFFECTS__*/
function polyObjEntries(value) {
    var result = [];
    objForEachKey(value, function (key, value) {
        result.push([key, value]);
    });
    return result;
}

var _objFreeze = ( /* #__PURE__ */_pureRef(ObjClass, "freeze"));
function _doNothing(value) {
    return value;
}
/*#__NO_SIDE_EFFECTS__*/
function _getProto(value) {
    return value[__PROTO__] || NULL_VALUE;
}
var objAssign = ( /*#__PURE__*/_pureRef(ObjClass, "assign"));
var objKeys = ( /*#__PURE__*/_pureRef(ObjClass, "keys"));
function objDeepFreeze(value) {
    if (_objFreeze) {
        objForEachKey(value, function (key, value) {
            if (isArray(value) || isObject(value)) {
                objDeepFreeze(value);
            }
        });
    }
    return objFreeze(value);
}
var objFreeze = ( /* #__PURE__*/_pureAssign(_objFreeze, _doNothing));
var objSeal = ( /* #__PURE__*/_pureAssign(( /* #__PURE__*/_pureRef(ObjClass, "seal")), _doNothing));
var objGetPrototypeOf = ( /* #__PURE__*/_pureAssign(( /* #__PURE__*/_pureRef(ObjClass, "getPrototypeOf")), _getProto));
var objEntries = ( /* #__PURE__*/_pureAssign(( /* #__PURE__*/_pureRef(ObjClass, "entries")), polyObjEntries));

/*#__NO_SIDE_EFFECTS__*/
function createEnum(values) {
    return _createKeyValueMap(values, 1 , 0 , objFreeze);
}
/*#__NO_SIDE_EFFECTS__*/
function createEnumKeyMap(values) {
    return _createKeyValueMap(values, 0 , 0 , objFreeze);
}
/*#__NO_SIDE_EFFECTS__*/
function createEnumValueMap(values) {
    return _createKeyValueMap(values, 1 , 1 , objFreeze);
}
/*#__NO_SIDE_EFFECTS__*/
function createSimpleMap(values) {
    var mapClass = {};
    objForEachKey(values, function (key, value) {
        _assignMapValue(mapClass, key, value[1]);
        _assignMapValue(mapClass, value[0], value[1]);
    });
    return objFreeze(mapClass);
}
/*#__NO_SIDE_EFFECTS__*/
function createTypeMap(values) {
    return createSimpleMap(values);
}

var _wellKnownSymbolMap = /*#__PURE__*/ createEnumKeyMap({
    asyncIterator: 0 ,
    hasInstance: 1 ,
    isConcatSpreadable: 2 ,
    iterator: 3 ,
    match: 4 ,
    matchAll: 5 ,
    replace: 6 ,
    search: 7 ,
    species: 8 ,
    split: 9 ,
    toPrimitive: 10 ,
    toStringTag: 11 ,
    unscopables: 12
});

var GLOBAL_CONFIG_KEY = "__tsUtils$gblCfg";
var _globalCfg;
/*#__NO_SIDE_EFFECTS__*/
function _getGlobalValue() {
    var result;
    if (typeof globalThis !== UNDEFINED) {
        result = globalThis;
    }
    if (!result && typeof self !== UNDEFINED) {
        result = self;
    }
    if (!result && typeof window !== UNDEFINED) {
        result = window;
    }
    if (!result && typeof global !== UNDEFINED) {
        result = global;
    }
    return result;
}
/*#__NO_SIDE_EFFECTS__*/
function _getGlobalConfig() {
    if (!_globalCfg) {
        var gbl = safe(_getGlobalValue).v || {};
        _globalCfg = gbl[GLOBAL_CONFIG_KEY] = gbl[GLOBAL_CONFIG_KEY] || {};
    }
    return _globalCfg;
}

var _unwrapFunction = ( _unwrapFunctionWithPoly);
/*#__NO_SIDE_EFFECTS__*/
function _unwrapFunctionWithPoly(funcName, clsProto, polyFunc) {
    var clsFn = clsProto && clsProto[funcName];
    return function (thisArg) {
        var theFunc = (thisArg && thisArg[funcName]) || clsFn;
        if (theFunc || polyFunc) {
            var theArgs = arguments;
            return (theFunc || polyFunc).apply(thisArg, theFunc ? ArrSlice[CALL](theArgs, 1) : theArgs);
        }
        throwTypeError("\"" + asString(funcName) + "\" not defined for " + dumpObj(thisArg));
    };
}
/*#__NO_SIDE_EFFECTS__*/
function _unwrapProp(propName) {
    return function (thisArg) {
        return thisArg[propName];
    };
}

var mathMin = ( /*#__PURE__*/_pureRef(MathCls, "min"));
var mathMax = ( /*#__PURE__*/_pureRef(MathCls, "max"));

var strSlice = ( /*#__PURE__*/_unwrapFunction("slice", StrProto));

var strSubstring = ( /*#__PURE__*/_unwrapFunction("substring", StrProto));
var strSubstr = ( /*#__PURE__*/_unwrapFunctionWithPoly("substr", StrProto, polyStrSubstr));
/*#__NO_SIDE_EFFECTS__*/
function polyStrSubstr(value, start, length) {
    if (isNullOrUndefined(value)) {
        throwTypeError("Invalid " + dumpObj(value));
    }
    if (length < 0) {
        return EMPTY;
    }
    start = start || 0;
    if (start < 0) {
        start = mathMax(start + value[LENGTH], 0);
    }
    if (isUndefined(length)) {
        return strSlice(value, start);
    }
    return strSlice(value, start, start + length);
}
/*#__NO_SIDE_EFFECTS__*/
function strLeft(value, count) {
    return strSubstring(value, 0, count);
}
/*#__NO_SIDE_EFFECTS__*/
function strRight(value, count) {
    return count <= 0 ? EMPTY : (value[LENGTH] > count ? strSlice(value, -count) : value);
}

var UNIQUE_REGISTRY_ID = "_urid";
var _polySymbols;
/*#__NO_SIDE_EFFECTS__*/
function _globalSymbolRegistry() {
    if (!_polySymbols) {
        var gblCfg = _getGlobalConfig();
        _polySymbols = gblCfg.gblSym = gblCfg.gblSym || { k: {}, s: {} };
    }
    return _polySymbols;
}
var _wellKnownSymbolCache;
/*#__NO_SIDE_EFFECTS__*/
function polyNewSymbol(description) {
    var theSymbol = {
        description: asString(description),
        toString: function () { return SYMBOL + "(" + description + ")"; }
    };
    theSymbol[POLYFILL_TAG] = true;
    return theSymbol;
}
/*#__NO_SIDE_EFFECTS__*/
function polySymbolFor(key) {
    var registry = _globalSymbolRegistry();
    if (!objHasOwn(registry.k, key)) {
        var newSymbol_1 = polyNewSymbol(key);
        var regId_1 = objKeys(registry.s).length;
        newSymbol_1[UNIQUE_REGISTRY_ID] = function () { return regId_1 + "_" + newSymbol_1[TO_STRING](); };
        registry.k[key] = newSymbol_1;
        registry.s[newSymbol_1[UNIQUE_REGISTRY_ID]()] = asString(key);
    }
    return registry.k[key];
}
/*#__NO_SIDE_EFFECTS__*/
function polySymbolKeyFor(sym) {
    if (!sym || !sym[TO_STRING] || strSubstring(sym[TO_STRING](), 0, 6) != SYMBOL) {
        throwTypeError(sym + " is not a symbol");
    }
    var regId = sym[POLYFILL_TAG] && sym[UNIQUE_REGISTRY_ID] && sym[UNIQUE_REGISTRY_ID]();
    return regId ? _globalSymbolRegistry().s[regId] : undefined;
}
/*#__NO_SIDE_EFFECTS__*/
function polyGetKnownSymbol(name) {
    !_wellKnownSymbolCache && (_wellKnownSymbolCache = {});
    var result;
    var knownName = _wellKnownSymbolMap[name];
    if (knownName) {
        result = _wellKnownSymbolCache[knownName] = _wellKnownSymbolCache[knownName] || polyNewSymbol(SYMBOL + "." + knownName);
    }
    return result;
}

var _globalLazyTestHooks;
function _initTestHooks() {
    _globalLazyTestHooks = _getGlobalConfig();
}
/*#__NO_SIDE_EFFECTS__*/
function getLazy(cb) {
    var lazyValue = {};
    !_globalLazyTestHooks && _initTestHooks();
    lazyValue.b = _globalLazyTestHooks.lzy;
    objDefineProp(lazyValue, "v", {
        configurable: true,
        get: function () {
            var result = cb();
            if (!_globalLazyTestHooks.lzy) {
                objDefineProp(lazyValue, "v", {
                    value: result
                });
            }
            lazyValue.b = _globalLazyTestHooks.lzy;
            return result;
        }
    });
    return lazyValue;
}
function setBypassLazyCache(newValue) {
    !_globalLazyTestHooks && _initTestHooks();
    _globalLazyTestHooks.lzy = newValue;
}

/*#__NO_SIDE_EFFECTS__*/
function createCachedValue(value) {
    return objDefineProp({
        toJSON: function () { return value; }
    }, "v", { value: value });
}
/*#__NO_SIDE_EFFECTS__*/
function createDeferredCachedValue(cb) {
    var theValue = {
        toJSON: function () { return theValue.v; }
    };
    return objDefineProp(theValue, "v", {
        get: function () {
            var result = cb();
            cb = NULL_VALUE;
            objDefineProp(theValue, "v", { value: result });
            return result;
        },
        configurable: true
    });
}

var WINDOW = "window";
var _cachedGlobal;
function _getGlobalInstFn(getFn, theArgs) {
    var cachedValue;
    return function () {
        !_globalLazyTestHooks && _initTestHooks();
        (!cachedValue || _globalLazyTestHooks.lzy) && (cachedValue = createCachedValue(safe(getFn, theArgs).v));
        return cachedValue.v;
    };
}
/*#__NO_SIDE_EFFECTS__*/
function lazySafeGetInst(name) {
    return getLazy(function () { return safe((getInst), [name]).v || UNDEF_VALUE; });
}
/*#__NO_SIDE_EFFECTS__*/
function getGlobal(useCached) {
    !_globalLazyTestHooks && _initTestHooks();
    (!_cachedGlobal || useCached === false || _globalLazyTestHooks.lzy) && (_cachedGlobal = createCachedValue(safe(_getGlobalValue).v || NULL_VALUE));
    return _cachedGlobal.v;
}
/*#__NO_SIDE_EFFECTS__*/
function getInst(name, useCached) {
    var gbl = (!_cachedGlobal || useCached === false) ? getGlobal(useCached) : _cachedGlobal.v;
    if (gbl && gbl[name]) {
        return gbl[name];
    }
    if (name === WINDOW) {
        return getWindow();
    }
    return NULL_VALUE;
}
/*#__NO_SIDE_EFFECTS__*/
function hasDocument() {
    return !!( /*#__PURE__*/getDocument());
}
var getDocument = ( /*#__PURE__*/_getGlobalInstFn(getInst, ["document"]));
/*#__NO_SIDE_EFFECTS__*/
function hasWindow() {
    return !!( /*#__PURE__*/getWindow());
}
var getWindow = ( /*#__PURE__*/_getGlobalInstFn(getInst, [WINDOW]));
/*#__NO_SIDE_EFFECTS__*/
function hasNavigator() {
    return !!( /*#__PURE__*/getNavigator());
}
var getNavigator = ( /*#__PURE__*/_getGlobalInstFn(getInst, ["navigator"]));
/*#__NO_SIDE_EFFECTS__*/
function hasHistory() {
    return !!( /*#__PURE__*/getHistory());
}
var getHistory = ( /*#__PURE__*/_getGlobalInstFn(getInst, ["history"]));
var isNode = ( /*#__PURE__*/_getGlobalInstFn(function () {
    return !!( /*#__PURE__*/safe(function () { return (process && (process.versions || {}).node); }).v);
}));
var isWebWorker = ( /*#__PURE__*/_getGlobalInstFn(function () {
    return !!( /*#__PURE__*/safe(function () { return self && self instanceof WorkerGlobalScope; }).v);
}));

var _symbol;
var _symbolFor;
var _symbolKeyFor;
/*#__NO_SIDE_EFFECTS__*/
function _initSymbol() {
    _symbol = ( /*#__PURE__*/createCachedValue(safe((getInst), [SYMBOL]).v));
    return _symbol;
}
function _getSymbolKey(key) {
    var gblSym = ((!_globalLazyTestHooks.lzy ? _symbol : 0) || _initSymbol());
    return (gblSym.v ? gblSym.v[key] : UNDEF_VALUE);
}
var isSymbol = ( /*#__PURE__*/_createIs("symbol"));
/*#__NO_SIDE_EFFECTS__*/
function hasSymbol() {
    return !!( /*#__PURE__*/getSymbol());
}
/*#__NO_SIDE_EFFECTS__*/
function getSymbol() {
    !_globalLazyTestHooks && _initTestHooks();
    return ((!_globalLazyTestHooks.lzy ? _symbol : 0) || _initSymbol()).v;
}
/*#__NO_SIDE_EFFECTS__*/
function getKnownSymbol(name, noPoly) {
    var knownName = _wellKnownSymbolMap[name];
    !_globalLazyTestHooks && _initTestHooks();
    var sym = ((!_globalLazyTestHooks.lzy ? _symbol : 0) || _initSymbol());
    return sym.v ? sym.v[knownName || name] : (!noPoly ? polyGetKnownSymbol(name) : UNDEF_VALUE);
}
/*#__NO_SIDE_EFFECTS__*/
function newSymbol(description, noPoly) {
    !_globalLazyTestHooks && _initTestHooks();
    var sym = ((!_globalLazyTestHooks.lzy ? _symbol : 0) || _initSymbol());
    return sym.v ? sym.v(description) : (!noPoly ? polyNewSymbol(description) : NULL_VALUE);
}
/*#__NO_SIDE_EFFECTS__*/
function symbolFor(key) {
    !_globalLazyTestHooks && _initTestHooks();
    _symbolFor = ((!_globalLazyTestHooks.lzy ? _symbolFor : 0) || ( /*#__PURE__*/createCachedValue(safe((_getSymbolKey), ["for"]).v)));
    return (_symbolFor.v || polySymbolFor)(key);
}
/*#__NO_SIDE_EFFECTS__*/
function symbolKeyFor(sym) {
    !_globalLazyTestHooks && _initTestHooks();
    _symbolKeyFor = ((!_globalLazyTestHooks.lzy ? _symbolKeyFor : 0) || ( /*#__PURE__*/createCachedValue(safe((_getSymbolKey), ["keyFor"]).v)));
    return (_symbolKeyFor.v || polySymbolKeyFor)(sym);
}

/*#__NO_SIDE_EFFECTS__*/
function isIterator(value) {
    return !!value && isFunction(value.next);
}
/*#__NO_SIDE_EFFECTS__*/
function isIterable(value) {
    return !isStrictNullOrUndefined(value) && isFunction(value[getKnownSymbol(3 )]);
}

var _iterSymbol$1;
function iterForOf(iter, callbackfn, thisArg) {
    if (iter) {
        if (!isIterator(iter)) {
            !_iterSymbol$1 && (_iterSymbol$1 = createCachedValue(getKnownSymbol(3 )));
            iter = iter[_iterSymbol$1.v] ? iter[_iterSymbol$1.v]() : null;
        }
        if (isIterator(iter)) {
            var err = UNDEF_VALUE;
            var iterResult = UNDEF_VALUE;
            try {
                var count = 0;
                while (!(iterResult = iter.next()).done) {
                    if (callbackfn[CALL](thisArg || iter, iterResult.value, count, iter) === -1) {
                        break;
                    }
                    count++;
                }
            }
            catch (failed) {
                err = { e: failed };
                if (iter.throw) {
                    iterResult = NULL_VALUE;
                    iter.throw(err);
                }
            }
            finally {
                try {
                    if (iterResult && !iterResult.done) {
                        iter.return && iter.return(iterResult);
                    }
                }
                finally {
                    if (err) {
                        // eslint-disable-next-line no-unsafe-finally
                        throw err.e;
                    }
                }
            }
        }
    }
}

function fnApply(fn, thisArg, argArray) {
    return fn.apply(thisArg, argArray);
}
function fnCall(fn, thisArg) {
    return fn.apply(thisArg, ArrSlice[CALL](arguments, 2));
}
function fnBind(fn, thisArg) {
    return fn.bind.apply(fn, ArrSlice[CALL](arguments, 1));
}

function arrAppend(target, elms) {
    if (!isUndefined(elms) && target) {
        if (isArray(elms)) {
            fnApply(target.push, target, elms);
        }
        else if (isIterator(elms) || isIterable(elms)) {
            iterForOf(elms, function (elm) {
                target.push(elm);
            });
        }
        else {
            target.push(elms);
        }
    }
    return target;
}

var arrEvery = /*#__PURE__*/ _unwrapFunction("every", ArrProto);
var arrFilter = /*#__PURE__*/ _unwrapFunction("filter", ArrProto);

function arrForEach(theArray, callbackfn, thisArg) {
    if (theArray) {
        var len = theArray[LENGTH] >>> 0;
        for (var idx = 0; idx < len; idx++) {
            if (idx in theArray) {
                if (callbackfn[CALL](thisArg || theArray, theArray[idx], idx, theArray) === -1) {
                    break;
                }
            }
        }
    }
}

var arrIndexOf = ( /*#__PURE__*/_unwrapFunction("indexOf", ArrProto));
var arrLastIndexOf = ( /*#__PURE__*/_unwrapFunction("lastIndexOf", ArrProto));

var arrMap = ( /*#__PURE__*/_unwrapFunction("map", ArrProto));

function arrSlice(theArray, start, end) {
    return ((theArray && theArray["slice"]) || ArrSlice).apply(theArray, ArrSlice[CALL](arguments, 1));
}

/*#__NO_SIDE_EFFECTS__*/
function polyIsArray(value) {
    if (isNullOrUndefined(value)) {
        return false;
    }
    return objToString(value) === "[object Array]";
}
/*#__NO_SIDE_EFFECTS__*/
function polyArrIncludes(theArray, searchElement, fromIndex) {
    return arrIndexOf(theArray, searchElement, fromIndex) !== -1;
}
function polyArrFind(theArray, callbackFn, thisArg) {
    var result;
    var idx = polyArrFindIndex(theArray, callbackFn, thisArg);
    return idx !== -1 ? theArray[idx] : result;
}
function polyArrFindIndex(theArray, callbackFn, thisArg) {
    var result = -1;
    arrForEach(theArray, function (value, index) {
        if (callbackFn[CALL](thisArg | theArray, value, index, theArray)) {
            result = index;
            return -1;
        }
    });
    return result;
}
function polyArrFindLast(theArray, callbackFn, thisArg) {
    var result;
    var idx = polyArrFindLastIndex(theArray, callbackFn, thisArg);
    return idx !== -1 ? theArray[idx] : result;
}
function polyArrFindLastIndex(theArray, callbackFn, thisArg) {
    var result = -1;
    var len = theArray[LENGTH] >>> 0;
    for (var idx = len - 1; idx >= 0; idx--) {
        if (idx in theArray && callbackFn[CALL](thisArg | theArray, theArray[idx], idx, theArray)) {
            result = idx;
            break;
        }
    }
    return result;
}
function polyArrFrom(theValue, mapFn, thisArg) {
    if (isArray(theValue)) {
        var result_1 = arrSlice(theValue);
        return mapFn ? arrMap(result_1, mapFn, thisArg) : result_1;
    }
    var result = [];
    iterForOf(theValue, function (value, cnt) {
        return result.push(mapFn ? mapFn[CALL](thisArg, value, cnt) : value);
    });
    return result;
}

var arrFind = /*#__PURE__*/ _unwrapFunctionWithPoly("find", ArrProto, polyArrFind);
var arrFindIndex = /*#__PURE__*/ _unwrapFunctionWithPoly("findIndex", ArrProto, polyArrFindIndex);
var arrFindLast = /*#__PURE__*/ _unwrapFunctionWithPoly("findLast", ArrProto, polyArrFindLast);
var arrFindLastIndex = /*#__PURE__*/ _unwrapFunctionWithPoly("findLastIndex", ArrProto, polyArrFindLastIndex);

var arrFrom = ( /* #__PURE__*/_pureAssign(( /* #__PURE__*/_pureRef(ArrCls, "from")), polyArrFrom));

var arrIncludes = ( /*#__PURE__*/_unwrapFunctionWithPoly("includes", ArrProto, polyArrIncludes));
var arrContains = arrIncludes;

var arrReduce = ( /*#__PURE__*/_unwrapFunction("reduce", ArrProto));

var arrSome = ( /*#__PURE__*/_unwrapFunction("some", ArrProto));

/*#__NO_SIDE_EFFECTS__*/
function createFnDeferredProxy(hostFn, funcName) {
    return function () {
        var theArgs = ArrSlice[CALL](arguments);
        var theHost = hostFn();
        return fnApply(theHost[funcName], theHost, theArgs);
    };
}
function createProxyFuncs(target, host, funcDefs) {
    if (target && host && isArray(funcDefs)) {
        var isDeferred_1 = isFunction(host);
        arrForEach(funcDefs, function (funcDef) {
            var targetName = (funcDef.as || funcDef.n);
            if (funcDef.rp === false && target[targetName]) {
                return;
            }
            target[targetName] = isDeferred_1 ?
                createFnDeferredProxy(host, funcDef.n) :
                fnBind(host[funcDef.n], host);
        });
    }
    return target;
}

var _iterSymbol;
/*#__NO_SIDE_EFFECTS__*/
function readArgs(theArgs, start, end) {
    if (!objHasOwn(theArgs, LENGTH)) {
        !_iterSymbol && (_iterSymbol = createCachedValue(hasSymbol() && getKnownSymbol(3 )));
        var iterFn = _iterSymbol.v && theArgs[_iterSymbol.v];
        if (iterFn) {
            var values_1 = [];
            var from_1 = (start === UNDEF_VALUE || start < 0) ? 0 : start;
            var to_1 = end < 0 || start < 0 ? UNDEF_VALUE : end;
            iterForOf(iterFn[CALL](theArgs), function (value, cnt) {
                if (to_1 !== UNDEF_VALUE && cnt >= to_1) {
                    return -1;
                }
                if (cnt >= from_1) {
                    values_1.push(value);
                }
            });
            if ((start === UNDEF_VALUE || start >= 0) && (end === UNDEF_VALUE || end >= 0)) {
                return values_1;
            }
            theArgs = values_1;
        }
    }
    return arrSlice(theArgs, start, end);
}

var objCreate = ( /* #__PURE__*/_pureAssign(( /* #__PURE__*/_pureRef(ObjClass, "create")), polyObjCreate));
/*#__NO_SIDE_EFFECTS__*/
function polyObjCreate(obj) {
    if (!obj) {
        return {};
    }
    var type = typeof obj;
    if (type !== OBJECT && type !== FUNCTION) {
        throwTypeError("Prototype must be an Object or function: " + dumpObj(obj));
    }
    function tempFunc() { }
    tempFunc[PROTOTYPE] = obj;
    return new tempFunc();
}

var _isProtoArray;
function objSetPrototypeOf(obj, proto) {
    var fn = ObjClass["setPrototypeOf"] ||
        function (d, b) {
            var _a;
            !_isProtoArray && (_isProtoArray = createCachedValue((_a = {}, _a[__PROTO__] = [], _a) instanceof Array));
            _isProtoArray.v ? d[__PROTO__] = b : objForEachKey(b, function (key, value) { return d[key] = value; });
        };
    return fn(obj, proto);
}

/*#__NO_SIDE_EFFECTS__*/
function _createCustomError(name, d, b) {
    safe(objDefine, [d, NAME, { v: name, c: true, e: false }]);
    d = objSetPrototypeOf(d, b);
    function __() {
        this[CONSTRUCTOR] = d;
        safe(objDefine, [this, NAME, { v: name, c: true, e: false }]);
    }
    d[PROTOTYPE] = b === NULL_VALUE ? objCreate(b) : (__[PROTOTYPE] = b[PROTOTYPE], new __());
    return d;
}
function _setName(baseClass, name) {
    name && (baseClass[NAME] = name);
}
/*#__NO_SIDE_EFFECTS__*/
function createCustomError(name, constructCb, errorBase) {
    var theBaseClass = errorBase || Error;
    var orgName = theBaseClass[PROTOTYPE][NAME];
    var captureFn = Error.captureStackTrace;
    return _createCustomError(name, function () {
        var _this = this;
        var theArgs = arguments;
        try {
            safe(_setName, [theBaseClass, name]);
            var _self = fnApply(theBaseClass, _this, ArrSlice[CALL](theArgs)) || _this;
            if (_self !== _this) {
                var orgProto = objGetPrototypeOf(_this);
                if (orgProto !== objGetPrototypeOf(_self)) {
                    objSetPrototypeOf(_self, orgProto);
                }
            }
            captureFn && captureFn(_self, _this[CONSTRUCTOR]);
            constructCb && constructCb(_self, theArgs);
            return _self;
        }
        finally {
            safe(_setName, [theBaseClass, orgName]);
        }
    }, theBaseClass);
}
var _unsupportedError;
function throwUnsupported(message) {
    if (!_unsupportedError) {
        _unsupportedError = createCustomError("UnsupportedError");
    }
    throw new _unsupportedError(message);
}

/*#__NO_SIDE_EFFECTS__*/
function utcNow() {
    return (Date.now || polyUtcNow)();
}
/*#__NO_SIDE_EFFECTS__*/
function polyUtcNow() {
    return new Date().getTime();
}

/*#__NO_SIDE_EFFECTS__*/
function _createTrimFn(exp) {
    return function _doTrim(value) {
        if (isNullOrUndefined(value)) {
            throwTypeError("strTrim called [" + dumpObj(value) + "]");
        }
        if (value && value.replace) {
            value = value.replace(exp, EMPTY);
        }
        return value;
    };
}
var polyStrTrim = ( /*#__PURE__*/_createTrimFn(/^\s+|(?=\s)\s+$/g));
var polyStrTrimStart = ( /*#__PURE__*/_createTrimFn(/^\s+/g));
var polyStrTrimEnd = ( /*#__PURE__*/_createTrimFn(/(?=\s)\s+$/g));

var strTrim = ( /*#__PURE__*/_unwrapFunctionWithPoly("trim", StrProto, polyStrTrim));
var strTrimStart = ( /*#__PURE__*/_unwrapFunctionWithPoly("trimStart", StrProto, polyStrTrimStart));
var strTrimLeft = ( /*#__PURE__*/_pureAssign(strTrimStart));
var strTrimEnd = ( /*#__PURE__*/_unwrapFunctionWithPoly("trimEnd", StrProto, polyStrTrimEnd));
var strTrimRight = ( /*#__PURE__*/_pureAssign(strTrimEnd));

var strUpper = ( /*#__PURE__*/_unwrapFunction("toUpperCase", StrProto));
var strLower = ( /*#__PURE__*/_unwrapFunction("toLowerCase", StrProto));

/*#__NO_SIDE_EFFECTS__*/
function _convertCase(value, newPrefix, upperWord) {
    return strTrim(asString(value)).replace(/((_|\W)+(\w){0,1}|([a-z])([A-Z]))/g, function (_match, _g1, _g2, wordStart, upperPrefix, upperLetter) {
        var convertMatch = wordStart || upperLetter || EMPTY;
        if (upperWord) {
            convertMatch = strUpper(convertMatch);
        }
        return (upperPrefix || EMPTY) + newPrefix + convertMatch;
    });
}
/*#__NO_SIDE_EFFECTS__*/
function strLetterCase(value) {
    return asString(value).replace(/(_|\b)\w/g, strUpper);
}
/*#__NO_SIDE_EFFECTS__*/
function strCamelCase(value, upperFirst) {
    var result = _convertCase(value, "", true);
    return result.replace(/^\w/, upperFirst ? strUpper : strLower);
}
/*#__NO_SIDE_EFFECTS__*/
function strKebabCase(value, scream) {
    var result = _convertCase(value, "-");
    return (scream ? strUpper : strLower)(result);
}
/*#__NO_SIDE_EFFECTS__*/
function strSnakeCase(value, scream) {
    var result = _convertCase(value, "_");
    return (scream ? strUpper : strLower)(result);
}

var mathFloor = ( /*#__PURE__*/_pureRef(MathCls, "floor"));
var mathCeil = ( /*#__PURE__*/_pureRef(MathCls, "ceil"));

var mathTrunc = ( /* #__PURE__*/_pureAssign(( /* #__PURE__*/_pureRef(MathCls, "trunc")), polyMathTrunc));
/*#__NO_SIDE_EFFECTS__*/
function polyMathTrunc(value) {
    var theValue = +value;
    return (theValue > 0 ? mathFloor : mathCeil)(theValue);
}

/*#__NO_SIDE_EFFECTS__*/
function mathToInt(value, throwInfinity) {
    var result = +value;
    if (result == Infinity && throwInfinity) {
        throwRangeError("invalid value [" + dumpObj(value) + "]");
    }
    return result !== result || result === 0 ? 0 : mathTrunc(result);
}

var strRepeat = ( /*#__PURE__*/_unwrapFunctionWithPoly("repeat", StrProto, polyStrRepeat));
/*#__NO_SIDE_EFFECTS__*/
function polyStrRepeat(value, count) {
    if (isNullOrUndefined(value)) {
        throwTypeError("can't convert [" + dumpObj(value) + "]");
    }
    count = mathToInt(count, true);
    if (count < 0) {
        throwRangeError("invalid count must be >= 0 && < Infinity");
    }
    var pad = isString(value) ? value : asString(value);
    var result = EMPTY;
    for (; count > 0; (count >>>= 1) && (pad += pad)) {
        if (count & 1) {
            result += pad;
        }
    }
    return result;
}

/*#__NO_SIDE_EFFECTS__*/
function _padValue(value, targetLength, padString) {
    var result = EMPTY;
    targetLength = mathToInt(targetLength, true);
    targetLength >>= 0;
    var len = value[LENGTH];
    if (len < targetLength) {
        result = isNullOrUndefined(padString) ? " " : asString(padString);
        targetLength = targetLength - len;
        if (targetLength > result[LENGTH]) {
            result = strRepeat(result, mathCeil(targetLength / result[LENGTH]));
        }
        if (result[LENGTH] > targetLength) {
            result = strSubstring(result, 0, targetLength);
        }
    }
    return result;
}
var strPadStart = ( /*#__PURE__*/_unwrapFunctionWithPoly("padStart", StrProto, polyStrPadStart));
var strPadEnd = ( /*#__PURE__*/_unwrapFunctionWithPoly("padEnd", StrProto, polyStrPadEnd));
/*#__NO_SIDE_EFFECTS__*/
function polyStrPadStart(value, targetLength, padString) {
    return _padValue(value, targetLength, padString) + value;
}
/*#__NO_SIDE_EFFECTS__*/
function polyStrPadEnd(value, targetLength, padString) {
    return value + _padValue(value, targetLength, padString);
}

var DBL_QUOTE = "\"";
var INVALID_JS_NAME = /([^\w\d_$])/g;
var _htmlEntityCache;
/*#__NO_SIDE_EFFECTS__*/
function normalizeJsName(jsName, camelCase) {
    var result = asString(jsName).replace(INVALID_JS_NAME, "_");
    return !isUndefined(camelCase) ? strCamelCase(result, !camelCase) : result;
}
/*#__NO_SIDE_EFFECTS__*/
function encodeAsJson(value, format) {
    var result;
    if (isString(value)) {
        result = DBL_QUOTE + value.replace(/[^\w .,\-!@#$%\^&*\(\)_+={}\[\]:;|<>?]/g, function (match) {
            if (match === DBL_QUOTE || match === "\\") {
                return "\\" + match;
            }
            var hex = match.charCodeAt(0)[TO_STRING](16);
            return "\\u" + strPadStart(strUpper(hex), 4, "0");
        }) + DBL_QUOTE;
    }
    else {
        try {
            result = JSON.stringify(value, NULL_VALUE, format ? (isNumber(format) ? format : 4) : UNDEF_VALUE);
        }
        catch (e) {
            result = DBL_QUOTE + dumpObj(e) + DBL_QUOTE;
        }
    }
    return result;
}
/*#__NO_SIDE_EFFECTS__*/
function encodeAsHtml(value) {
    !_htmlEntityCache && (_htmlEntityCache = {
        "&": "amp",
        "<": "lt",
        ">": "gt",
        "\"": "quot",
        "'": "#39"
    });
    return asString(value).replace(/[&<>"']/g, function (match) { return "&" + _htmlEntityCache[match] + ";"; });
}

var _fnToString;
var _objCtrFnString;
var _gblWindow;
/*#__NO_SIDE_EFFECTS__*/
function isPlainObject(value) {
    if (!value || typeof value !== OBJECT) {
        return false;
    }
    if (!_gblWindow) {
        _gblWindow = hasWindow() ? getWindow() : true;
    }
    var result = false;
    if (value !== _gblWindow) {
        if (!_objCtrFnString) {
            _fnToString = Function[PROTOTYPE][TO_STRING];
            _objCtrFnString = _fnToString[CALL](ObjClass);
        }
        try {
            var proto = objGetPrototypeOf(value);
            result = !proto;
            if (!result) {
                if (objHasOwnProperty(proto, CONSTRUCTOR)) {
                    proto = proto[CONSTRUCTOR];
                }
                result = proto && typeof proto === FUNCTION && _fnToString[CALL](proto) === _objCtrFnString;
            }
        }
        catch (ex) {
        }
    }
    return result;
}

/*#__NO_SIDE_EFFECTS__*/
function _defaultDeepCopyHandler(details) {
    details.value && plainObjDeepCopyHandler(details);
    return true;
}
var defaultDeepCopyHandlers = [
    arrayDeepCopyHandler,
    plainObjDeepCopyHandler,
    functionDeepCopyHandler,
    dateDeepCopyHandler
];
/*#__NO_SIDE_EFFECTS__*/
function _getSetVisited(visitMap, source, newPath, cb) {
    var theEntry;
    arrForEach(visitMap, function (entry) {
        if (entry.k === source) {
            theEntry = entry;
            return -1;
        }
    });
    if (!theEntry) {
        theEntry = { k: source, v: source };
        visitMap.push(theEntry);
        cb(theEntry);
    }
    return theEntry.v;
}
function _deepCopy(visitMap, value, ctx, key) {
    var userHandler = ctx.handler;
    var newPath = ctx.path ? (key ? ctx.path.concat(key) : ctx.path) : [];
    var newCtx = {
        handler: ctx.handler,
        src: ctx.src,
        path: newPath
    };
    var theType = typeof value;
    var isPlain = false;
    var isPrim = false;
    if (value && theType === OBJECT) {
        isPlain = isPlainObject(value);
    }
    else {
        isPrim = value === NULL_VALUE || isPrimitiveType(theType);
    }
    var details = {
        type: theType,
        isPrim: isPrim,
        isPlain: isPlain,
        value: value,
        result: value,
        path: newPath,
        origin: ctx.src,
        copy: function (source, newKey) {
            return _deepCopy(visitMap, source, newKey ? newCtx : ctx, newKey);
        },
        copyTo: function (target, source) {
            return _copyProps(visitMap, target, source, newCtx);
        }
    };
    if (!details.isPrim) {
        return _getSetVisited(visitMap, value, newPath, function (newEntry) {
            objDefine(details, "result", {
                g: function () {
                    return newEntry.v;
                },
                s: function (newValue) {
                    newEntry.v = newValue;
                }
            });
            var idx = 0;
            var handler = userHandler;
            while (!(handler || (idx < defaultDeepCopyHandlers.length ? defaultDeepCopyHandlers[idx++] : _defaultDeepCopyHandler))[CALL](ctx, details)) {
                handler = NULL_VALUE;
            }
        });
    }
    if (userHandler && userHandler[CALL](ctx, details)) {
        return details.result;
    }
    return value;
}
function _copyProps(visitMap, target, source, ctx) {
    if (!isNullOrUndefined(source)) {
        for (var key in source) {
            target[key] = _deepCopy(visitMap, source[key], ctx, key);
        }
    }
    return target;
}
function objCopyProps(target, source, handler) {
    var ctx = {
        handler: handler,
        src: source,
        path: []
    };
    return _copyProps([], target, source, ctx);
}
/*#__NO_SIDE_EFFECTS__*/
function objDeepCopy(source, handler) {
    var ctx = {
        handler: handler,
        src: source
    };
    return _deepCopy([], source, ctx);
}
function arrayDeepCopyHandler(details) {
    var value = details.value;
    if (isArray(value)) {
        var target = details.result = [];
        target.length = value.length;
        details.copyTo(target, value);
        return true;
    }
    return false;
}
function dateDeepCopyHandler(details) {
    var value = details.value;
    if (isDate(value)) {
        details.result = new Date(value.getTime());
        return true;
    }
    return false;
}
function functionDeepCopyHandler(details) {
    if (details.type === FUNCTION) {
        return true;
    }
    return false;
}
function plainObjDeepCopyHandler(details) {
    var value = details.value;
    if (value && details.isPlain) {
        var target = details.result = {};
        details.copyTo(target, value);
        return true;
    }
    return false;
}

function _doExtend(target, theArgs) {
    arrForEach(theArgs, function (theArg) {
        objCopyProps(target, theArg);
    });
    return target;
}
function deepExtend(target, obj1, obj2, obj3, obj4, obj5, obj6) {
    return _doExtend(objDeepCopy(target) || {}, ArrSlice[CALL](arguments));
}
function objExtend(target, obj1, obj2, obj3, obj4, obj5, obj6) {
    return _doExtend(target || {}, ArrSlice[CALL](arguments));
}

var getLength = ( /*#__PURE__*/_unwrapProp(LENGTH));

/*#__NO_SIDE_EFFECTS__*/
function getIntValue(value, defValue) {
    if (!isNullOrUndefined(value)) {
        if (isNumber(value)) {
            return value;
        }
        var theValue = parseInt(value, 10);
        return isNaN(theValue) ? defValue : theValue;
    }
    return defValue;
}

var _perf;
/*#__NO_SIDE_EFFECTS__*/
function hasPerformance() {
    return !!getPerformance();
}
/*#__NO_SIDE_EFFECTS__*/
function getPerformance() {
    !_globalLazyTestHooks && _initTestHooks();
    (!_perf || _globalLazyTestHooks.lzy) && (_perf = createCachedValue(safe((getInst), ["performance"]).v));
    return _perf.v;
}
/*#__NO_SIDE_EFFECTS__*/
function perfNow() {
    var perf = getPerformance();
    if (perf && perf.now) {
        return perf.now();
    }
    return utcNow();
}
/*#__NO_SIDE_EFFECTS__*/
function elapsedTime(startTime) {
    return perfNow() - startTime;
}

var MATCH_ANY = "(.*)";
var MATCH_SINGLE = "(.)";
function _createRegExp(value, escapeRgx, replaceFn, ignoreCase, fullMatch) {
    // eslint-disable-next-line security/detect-non-literal-regexp
    return new RegExp((fullMatch ? "^" : EMPTY) + replaceFn(value.replace(escapeRgx, "\\$1")) + (fullMatch ? "$" : EMPTY), ignoreCase ? "i" : "");
}
/*#__NO_SIDE_EFFECTS__*/
function createWildcardRegex(value, ignoreCase, fullMatch) {
    return _createRegExp(asString(value), /([-+|^$#.\?{}()\[\]\\/\"\'])/g, function (value) {
        return value.replace(/\*/g, MATCH_ANY);
    }, !!ignoreCase, fullMatch);
}
/*#__NO_SIDE_EFFECTS__*/
function createFilenameRegex(value, ignoreCase, fullMatch) {
    return _createRegExp(asString(value), /([-+|^$#.{}()\\\/\[\]\"\'])/g, function (value) {
        return value.replace(/(\\\\|\\\/|\*|\?)/g, function (_all, g1) {
            if (g1 == "\\/" || g1 == "\\\\") {
                return "[\\\\\\/]{1}";
            }
            return g1 == "*" ? MATCH_ANY : MATCH_SINGLE;
        });
    }, !!ignoreCase, fullMatch);
}
/*#__NO_SIDE_EFFECTS__*/
function makeGlobRegex(value, ignoreCase, fullMatch) {
    return _createRegExp(asString(value), /([-+|^$#.{}()\\\/\[\]\"\'])/g, function (value) {
        return value.replace(/(\*\*\\[\\\/]|\\\\|\\\/|\*\*|\*|\?)/g, function (_all, g1) {
            if (g1 == "**\\/" || g1 == "**\\\\") {
                return "(.*[\\\\\\/])*";
            }
            if (g1 === "\\/" || g1 == "\\\\") {
                return "[\\\\\\/]{1}";
            }
            if (g1 === "**") {
                return MATCH_ANY;
            }
            return g1 === "*" ? "([^\\\\\\/]*)" : "([^\\\\\\/]{1})";
        });
    }, !!ignoreCase, fullMatch);
}

/*#__NO_SIDE_EFFECTS__*/
function safeGetLazy(cb, defValue) {
    return getLazy(function () {
        var result = safe(cb);
        return result.e ? defValue : result.v;
    });
}

/*#__NO_SIDE_EFFECTS__*/
function _checkLength(value, props) {
    var result;
    arrForEach(props, function (prop) {
        if (prop in value) {
            var propValue = value[prop];
            result = (isFunction(propValue) ? propValue() : propValue) > 0;
            return -1;
        }
    });
    return result;
}
/*#__NO_SIDE_EFFECTS__*/
function _hasValue(value, depth) {
    var result = value === false || value === 0;
    if (!result && !isNullOrUndefined(value)) {
        if (isArray(value)) {
            result = value[LENGTH] > 0;
        }
        else if (isDate(value)) {
            result = !isNaN(value.getTime());
        }
        else if (isBoolean(value)) {
            return true;
        }
        else if (isObject(value)) {
            try {
                var chkValue = _checkLength(value, [LENGTH, "byteLength", "size", "count"]);
                if (isBoolean(chkValue)) {
                    return chkValue;
                }
                if (isFunction(value.valueOf) && depth < 5) {
                    return _hasValue(value.valueOf(), ++depth);
                }
            }
            catch (e) {
            }
            return !!objKeys(value)[LENGTH];
        }
        else {
            result = isTruthy(value);
        }
    }
    return result;
}
/*#__NO_SIDE_EFFECTS__*/
function hasValue(value) {
    return _hasValue(value, 0);
}

/*#__NO_SIDE_EFFECTS__*/
function createIterable(ctx) {
    return makeIterable({}, ctx);
}
function makeIterable(target, ctx) {
    var itSymbol = getKnownSymbol(3 );
    function _createIterator() {
        return createIterator(ctx);
    }
    target[itSymbol] = _createIterator;
    return target;
}
/*#__NO_SIDE_EFFECTS__*/
function createIterator(ctx) {
    var isDone = false;
    function _value() {
        return ctx.v;
    }
    function _next() {
        isDone = isDone || (ctx.n ? ctx.n(arguments) : true);
        var result = {
            done: isDone
        };
        if (!isDone) {
            objDefine(result, "value", { g: _value });
        }
        return result;
    }
    function _return(value) {
        isDone = true;
        return {
            done: true,
            value: ctx.r && ctx.r(value)
        };
    }
    function _throw(e) {
        isDone = true;
        return {
            done: true,
            value: ctx.t && ctx.t(e)
        };
    }
    var theIterator = {
        next: _next
    };
    if (ctx.r) {
        theIterator.return = _return;
    }
    if (ctx.t) {
        theIterator.throw = _throw;
    }
    return theIterator;
}

/*#__NO_SIDE_EFFECTS__*/
function createArrayIterator(values) {
    var idx = -1;
    var theValues = values ? values.slice() : [];
    var len = theValues[LENGTH];
    function _value() {
        if (idx >= 0 && idx < len) {
            return theValues[idx];
        }
    }
    function _getNext() {
        idx++;
        return idx >= len;
    }
    var ctx = {
        n: _getNext
    };
    objDefine(ctx, "v", { g: _value });
    return createIterator(ctx);
}

/*#__NO_SIDE_EFFECTS__*/
function createRangeIterator(start, end, step) {
    var nextValue = start;
    var theValue = UNDEF_VALUE;
    if (isNullOrUndefined(end)) {
        end = start;
    }
    var theStep = step || ((start <= end) ? 1 : -1);
    function _value() {
        return theValue;
    }
    function _getNext() {
        var isDone = false;
        if (theStep > 0) {
            isDone = nextValue > end;
        }
        else {
            isDone = nextValue < end;
        }
        if (!isDone) {
            theValue = nextValue;
            nextValue += theStep;
        }
        return isDone;
    }
    var ctx = {
        n: _getNext
    };
    objDefine(ctx, "v", { g: _value });
    return createIterator(ctx);
}

/*#__NO_SIDE_EFFECTS__*/
function polyStrSymSplit(value, splitter, limit) {
    var splitFn = splitter && splitter[getKnownSymbol(9 )];
    return splitFn ? splitFn(value, limit) : [value];
}

var strSplit = ( /*#__PURE__*/_unwrapFunction("split", StrProto));
var strSymSplit = ( /*#__PURE__*/_unwrapFunctionWithPoly("split", StrProto, !hasSymbol() ? polyStrSymSplit : null));

/*#__NO_SIDE_EFFECTS__*/
function getValueByKey(target, path, defValue) {
    if (!path || !target) {
        return defValue;
    }
    var parts = strSplit(path, ".");
    var cnt = parts.length;
    for (var lp = 0; lp < cnt && !isNullOrUndefined(target); lp++) {
        target = target[parts[lp]];
    }
    return (!isNullOrUndefined(target) ? target : defValue);
}
/*#__NO_SIDE_EFFECTS__*/
function getValueByIter(target, iter, defValue) {
    if (!iter || !target) {
        return defValue;
    }
    iterForOf(iter, function (value) {
        if (isNullOrUndefined(target)) {
            return -1;
        }
        target = target[value];
    });
    return (!isNullOrUndefined(target) ? target : defValue);
}
function setValueByKey(target, path, value) {
    if (target && path) {
        var parts = strSplit(path, ".");
        var lastKey = parts.pop();
        arrForEach(parts, function (key) {
            if (isNullOrUndefined(target[key])) {
                target[key] = {};
            }
            target = target[key];
        });
        target[lastKey] = value;
    }
}
function setValueByIter(target, iter, value) {
    if (target && iter) {
        var lastKey_1;
        iterForOf(iter, function (key) {
            if (lastKey_1) {
                if (isNullOrUndefined(target[lastKey_1])) {
                    target[lastKey_1] = {};
                }
                target = target[lastKey_1];
            }
            lastKey_1 = key;
        });
        target[lastKey_1] = value;
    }
}

var strEndsWith = ( /*#__PURE__*/_unwrapFunctionWithPoly("endsWith", StrProto, polyStrEndsWith));
/*#__NO_SIDE_EFFECTS__*/
function polyStrEndsWith(value, searchString, length) {
    if (!isString(value)) {
        throwTypeError("'" + dumpObj(value) + "' is not a string");
    }
    var searchValue = isString(searchString) ? searchString : asString(searchString);
    var end = !isUndefined(length) && length < value[LENGTH] ? length : value[LENGTH];
    return strSubstring(value, end - searchValue[LENGTH], end) === searchValue;
}

var strIndexOf = ( /*#__PURE__*/_unwrapFunction("indexOf", StrProto));
var strLastIndexOf = ( /*#__PURE__*/_unwrapFunction("lastIndexOf", StrProto));

var strIncludes = ( /*#__PURE__*/_unwrapFunctionWithPoly("includes", StrProto, polyStrIncludes));
var strContains = ( /*#__PURE__*/_pureAssign(strIncludes));
/*#__NO_SIDE_EFFECTS__*/
function polyStrIncludes(value, searchString, position) {
    if (isRegExp(searchString)) {
        throwTypeError("'searchString' must not be a regular expression" + dumpObj(searchString));
    }
    return strIndexOf(value, asString(searchString), position) !== -1;
}

/*#__NO_SIDE_EFFECTS__*/
function strIsNullOrWhiteSpace(value) {
    if (isString(value)) {
        return value.replace(/[\s\t\r\n\f]+/g, EMPTY) === EMPTY;
    }
    return isNullOrUndefined(value);
}
/*#__NO_SIDE_EFFECTS__*/
function strIsNullOrEmpty(value) {
    if (isString(value)) {
        return value === EMPTY;
    }
    return isNullOrUndefined(value);
}

var strStartsWith = ( /*#__PURE__*/_unwrapFunctionWithPoly("startsWith", StrProto, polyStrStartsWith));
/*#__NO_SIDE_EFFECTS__*/
function polyStrStartsWith(value, searchString, position) {
    if (!isString(value)) {
        throwTypeError("'" + dumpObj(value) + "' is not a string");
    }
    var searchValue = isString(searchString) ? searchString : asString(searchString);
    var pos = position > 0 ? position : 0;
    return strSubstring(value, pos, pos + searchValue[LENGTH]) === searchValue;
}

var REF = "ref";
var UNREF = "unref";
var HAS_REF = "hasRef";
var ENABLED = "enabled";
/*#__NO_SIDE_EFFECTS__*/
function _createTimerHandler(startTimer, refreshFn, cancelFn) {
    var ref = true;
    var timerId = startTimer ? refreshFn(NULL_VALUE) : NULL_VALUE;
    var theTimerHandler;
    function _unref() {
        ref = false;
        timerId && timerId[UNREF] && timerId[UNREF]();
        return theTimerHandler;
    }
    function _cancel() {
        timerId && cancelFn(timerId);
        timerId = NULL_VALUE;
    }
    function _refresh() {
        timerId = refreshFn(timerId);
        if (!ref) {
            _unref();
        }
        return theTimerHandler;
    }
    function _setEnabled(value) {
        !value && timerId && _cancel();
        value && !timerId && _refresh();
    }
    theTimerHandler = {
        cancel: _cancel,
        refresh: _refresh
    };
    theTimerHandler[HAS_REF] = function () {
        if (timerId && timerId[HAS_REF]) {
            return timerId[HAS_REF]();
        }
        return ref;
    };
    theTimerHandler[REF] = function () {
        ref = true;
        timerId && timerId[REF] && timerId[REF]();
        return theTimerHandler;
    };
    theTimerHandler[UNREF] = _unref;
    theTimerHandler = objDefineProp(theTimerHandler, ENABLED, {
        get: function () { return !!timerId; },
        set: _setEnabled
    });
    return {
        h: theTimerHandler,
        dn: function () {
            timerId = NULL_VALUE;
        }
    };
}

function _createTimeoutWith(startTimer, overrideFn, theArgs) {
    var isArr = isArray(overrideFn);
    var len = isArr ? overrideFn.length : 0;
    var setFn = (len > 0 ? overrideFn[0] : (!isArr ? overrideFn : UNDEF_VALUE)) || setTimeout;
    var clearFn = (len > 1 ? overrideFn[1] : UNDEF_VALUE) || clearTimeout;
    var timerFn = theArgs[0];
    theArgs[0] = function () {
        handler.dn();
        fnApply(timerFn, UNDEF_VALUE, ArrSlice[CALL](arguments));
    };
    var handler = _createTimerHandler(startTimer, function (timerId) {
        if (timerId) {
            if (timerId.refresh) {
                timerId.refresh();
                return timerId;
            }
            fnApply(clearFn, UNDEF_VALUE, [timerId]);
        }
        return fnApply(setFn, UNDEF_VALUE, theArgs);
    }, function (timerId) {
        fnApply(clearFn, UNDEF_VALUE, [timerId]);
    });
    return handler.h;
}
function scheduleTimeout(callback, timeout) {
    return _createTimeoutWith(true, UNDEF_VALUE, ArrSlice[CALL](arguments));
}
function scheduleTimeoutWith(overrideFn, callback, timeout) {
    return _createTimeoutWith(true, overrideFn, ArrSlice[CALL](arguments, 1));
}
function createTimeout(callback, timeout) {
    return _createTimeoutWith(false, UNDEF_VALUE, ArrSlice[CALL](arguments));
}
function createTimeoutWith(overrideFn, callback, timeout) {
    return _createTimeoutWith(false, overrideFn, ArrSlice[CALL](arguments, 1));
}

var _defaultIdleTimeout = 100;
var _maxExecutionTime = 50;
/*#__NO_SIDE_EFFECTS__*/
function hasIdleCallback() {
    return !!( /*#__PURE__*/getIdleCallback());
}
var getIdleCallback = ( /*#__PURE__*/_getGlobalInstFn(getInst, ["requestIdleCallback"]));
var getCancelIdleCallback = ( /*#__PURE__*/_getGlobalInstFn(getInst, ["cancelIdleCallback"]));
function setDefaultIdleTimeout(timeout) {
    _defaultIdleTimeout = timeout;
}
function setDefaultMaxExecutionTime(maxTime) {
    _maxExecutionTime = maxTime;
}
function scheduleIdleCallback(callback, options) {
    function _createDeadline(timedOut) {
        var startTime = perfNow();
        return {
            didTimeout: timedOut,
            timeRemaining: function () {
                return _maxExecutionTime - elapsedTime(startTime);
            }
        };
    }
    if (hasIdleCallback()) {
        var handler_1 = _createTimerHandler(true, function (idleId) {
            idleId && getCancelIdleCallback()(idleId);
            return getIdleCallback()(function (deadline) {
                handler_1.dn();
                callback(deadline || _createDeadline(false));
            }, options);
        }, function (idleId) {
            getCancelIdleCallback()(idleId);
        });
        return handler_1.h;
    }
    var timeout = (options || {}).timeout;
    if (isUndefined(timeout)) {
        timeout = _defaultIdleTimeout;
    }
    return scheduleTimeout(function () {
        callback(_createDeadline(true));
    }, timeout);
}

function scheduleInterval(callback, timeout) {
    var theArguments = ArrSlice[CALL](arguments);
    var handler = _createTimerHandler(true, function (intervalId) {
        intervalId && clearInterval(intervalId);
        return fnApply(setInterval, UNDEF_VALUE, theArguments);
    }, function (intervalId) {
        fnApply(clearInterval, UNDEF_VALUE, [intervalId]);
    });
    return handler.h;
}


//# sourceMappingURL=ts-utils.js.map


/***/ }),
/* 31 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AppInsightsCore": () => (/* binding */ AppInsightsCore)
/* harmony export */ });
/* harmony import */ var _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(33);
/* harmony import */ var _microsoft_dynamicproto_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(35);
/* harmony import */ var _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(30);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(37);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(40);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(50);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(54);
/* harmony import */ var _InternalConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(32);
/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(52);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(36);
/*
 * 1DS JS SDK Core, 4.3.0
 * Copyright (c) Microsoft and contributors. All rights reserved.
 * (Microsoft Internal Only)
 */

/**
* AppInsightsCore.ts
* @author Abhilash Panwar (abpanwar) Hector Hernandez (hectorh)
* @copyright Microsoft 2018
*/






/**
 * The default settings for the config.
 * WE MUST include all defaults here to ensure that the config is created with all of the properties
 * defined as dynamic.
 */
var defaultConfig = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objDeepFreeze)({
    endpointUrl: _InternalConstants__WEBPACK_IMPORTED_MODULE_1__.STR_DEFAULT_ENDPOINT_URL,
    propertyStorageOverride: { isVal: _chkPropOverride }
});
function _chkPropOverride(propertyStorageOverride) {
    // Validate property storage override
    if (propertyStorageOverride && (!propertyStorageOverride.getProperty || !propertyStorageOverride.setProperty)) {
        (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.throwError)("Invalid property storage override passed.");
    }
    return true;
}
/**
 * @group Classes
 * @group Entrypoint
 */
var AppInsightsCore = /** @class */ (function (_super) {
    (0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_2__.__extendsFn)(AppInsightsCore, _super);
    function AppInsightsCore() {
        var _this = _super.call(this) || this;
        (0,_microsoft_dynamicproto_js__WEBPACK_IMPORTED_MODULE_3__["default"])(AppInsightsCore, _this, function (_self, _base) {
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__._DYN_INITIALIZE /* @min:%2einitialize */] = function (config, extensions, logger, notificationManager) {
                (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_5__.doPerf)(_self, function () { return "AppInsightsCore.initialize"; }, function () {
                    try {
                        _base[_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__._DYN_INITIALIZE /* @min:%2einitialize */]((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_6__.createDynamicConfig)(config, defaultConfig, logger || _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__._DYN_LOGGER /* @min:%2elogger */], false).cfg, extensions, logger, notificationManager);
                    }
                    catch (e) {
                        var logger_1 = _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__._DYN_LOGGER /* @min:%2elogger */];
                        var message = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.dumpObj)(e);
                        if (message[_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__._DYN_INDEX_OF /* @min:%2eindexOf */]("channels") !== -1) {
                            // Add some additional context to the underlying reported error
                            message += "\n - Channels must be provided through config.channels only!";
                        }
                        (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_7__._throwInternal)(logger_1, 1 /* eLoggingSeverity.CRITICAL */, 514 /* _eExtendedInternalMessageId.FailedToInitializeSDK */, "SDK Initialization Failed - no telemetry will be sent: " + message);
                    }
                }, function () { return ({ config: config, extensions: extensions, logger: logger, notificationManager: notificationManager }); });
            };
            _self.track = function (item) {
                (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_5__.doPerf)(_self, function () { return "AppInsightsCore.track"; }, function () {
                    var telemetryItem = item;
                    if (telemetryItem) {
                        telemetryItem[_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__._DYN_TIMINGS /* @min:%2etimings */] = telemetryItem[_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__._DYN_TIMINGS /* @min:%2etimings */] || {};
                        telemetryItem[_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__._DYN_TIMINGS /* @min:%2etimings */].trackStart = (0,_Utils__WEBPACK_IMPORTED_MODULE_8__.getTime)();
                        if (!(0,_Utils__WEBPACK_IMPORTED_MODULE_8__.isLatency)(telemetryItem.latency)) {
                            telemetryItem.latency = 1 /* EventLatencyValue.Normal */;
                        }
                        var itemExt = telemetryItem.ext = telemetryItem.ext || {};
                        itemExt.sdk = itemExt.sdk || {};
                        itemExt.sdk.ver = _Utils__WEBPACK_IMPORTED_MODULE_8__.FullVersionString;
                        var baseData = telemetryItem.baseData = telemetryItem.baseData || {};
                        baseData[_InternalConstants__WEBPACK_IMPORTED_MODULE_1__.STR_PROPERTIES /* @min:%2eproperties */] = baseData[_InternalConstants__WEBPACK_IMPORTED_MODULE_1__.STR_PROPERTIES /* @min:%2eproperties */] || {};
                        var itemProperties = baseData[_InternalConstants__WEBPACK_IMPORTED_MODULE_1__.STR_PROPERTIES /* @min:%2eproperties */];
                        itemProperties[_InternalConstants__WEBPACK_IMPORTED_MODULE_1__.STR_VERSION] = itemProperties[_InternalConstants__WEBPACK_IMPORTED_MODULE_1__.STR_VERSION] || _self.pluginVersionString || _InternalConstants__WEBPACK_IMPORTED_MODULE_1__.STR_EMPTY;
                    }
                    _base.track(telemetryItem);
                }, function () { return ({ item: item }); }, !(item.sync));
            };
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__._DYN_POLL_INTERNAL_LOGS /* @min:%2epollInternalLogs */] = function (eventName) {
                return _base[_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__._DYN_POLL_INTERNAL_LOGS /* @min:%2epollInternalLogs */](eventName || "InternalLog");
            };
        });
        return _this;
    }
// Removed Stub for AppInsightsCore.prototype.initialize.
// Removed Stub for AppInsightsCore.prototype.track.
// Removed Stub for AppInsightsCore.prototype.pollInternalLogs.
    // This is a workaround for an IE bug when using dynamicProto() with classes that don't have any
    // non-dynamic functions or static properties/functions when using uglify-js to minify the resulting code.
    AppInsightsCore.__ieDyn=1;

    return AppInsightsCore;
}(_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_9__.AppInsightsCore));

//# sourceMappingURL=AppInsightsCore.js.map

/***/ }),
/* 32 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "STR_DEFAULT_ENDPOINT_URL": () => (/* binding */ STR_DEFAULT_ENDPOINT_URL),
/* harmony export */   "STR_EMPTY": () => (/* binding */ STR_EMPTY),
/* harmony export */   "STR_PROPERTIES": () => (/* binding */ STR_PROPERTIES),
/* harmony export */   "STR_VERSION": () => (/* binding */ STR_VERSION)
/* harmony export */ });
/*
 * 1DS JS SDK Core, 4.3.0
 * Copyright (c) Microsoft and contributors. All rights reserved.
 * (Microsoft Internal Only)
 */

// Licensed under the MIT License.
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// Note: DON'T Export these const from the package as we are still targeting ES3 this will export a mutable variables that someone could change!!!
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// Generally you should only put values that are used more than 2 times and then only if not already exposed as a constant (such as SdkCoreNames)
// as when using "short" named values from here they will be will be minified smaller than the SdkCoreNames[eSdkCoreNames.xxxx] value.
var STR_EMPTY = "";
var STR_DEFAULT_ENDPOINT_URL = "https://browser.events.data.microsoft.com/OneCollector/1.0/";
var STR_VERSION = "version";
var STR_PROPERTIES = "properties";
//# sourceMappingURL=InternalConstants.js.map

/***/ }),
/* 33 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ReflectObj": () => (/* binding */ ReflectObj),
/* harmony export */   "SymbolObj": () => (/* binding */ SymbolObj),
/* harmony export */   "__assignFn": () => (/* binding */ __assignFn),
/* harmony export */   "__createBindingFn": () => (/* binding */ __createBindingFn),
/* harmony export */   "__decorateFn": () => (/* binding */ __decorateFn),
/* harmony export */   "__exportStarFn": () => (/* binding */ __exportStarFn),
/* harmony export */   "__extendsFn": () => (/* binding */ __extendsFn),
/* harmony export */   "__hasReflect": () => (/* binding */ __hasReflect),
/* harmony export */   "__importDefaultFn": () => (/* binding */ __importDefaultFn),
/* harmony export */   "__importStarFn": () => (/* binding */ __importStarFn),
/* harmony export */   "__makeTemplateObjectFn": () => (/* binding */ __makeTemplateObjectFn),
/* harmony export */   "__metadataFn": () => (/* binding */ __metadataFn),
/* harmony export */   "__objAssignFnImpl": () => (/* binding */ __objAssignFnImpl),
/* harmony export */   "__paramFn": () => (/* binding */ __paramFn),
/* harmony export */   "__readFn": () => (/* binding */ __readFn),
/* harmony export */   "__restFn": () => (/* binding */ __restFn),
/* harmony export */   "__spreadArrayFn": () => (/* binding */ __spreadArrayFn),
/* harmony export */   "__spreadArraysFn": () => (/* binding */ __spreadArraysFn),
/* harmony export */   "__valuesFn": () => (/* binding */ __valuesFn)
/* harmony export */ });
/* harmony import */ var _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(30);
/* harmony import */ var _Constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(34);
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.


// Most of these functions have been directly shamelessly "lifted" from the https://github.com/@microsoft/tslib and
// modified to be ES5 compatible and applying several minification and tree-shaking techniques so that Application Insights
// can successfully use TypeScript "importHelpers" which imports tslib during compilation but it will use these at runtime
// Which is also why all of the functions have not been included as Application Insights currently doesn't use or require
// them.
var SymbolObj = ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.getGlobal)() || {})["Symbol"];
var ReflectObj = ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.getGlobal)() || {})["Reflect"];
var __hasReflect = !!ReflectObj;
var strDecorate = "decorate";
var strMetadata = "metadata";
var strGetOwnPropertySymbols = "getOwnPropertySymbols";
var strIterator = "iterator";
var strHasOwnProperty = "hasOwnProperty";
var __objAssignFnImpl = function (t) {
    // tslint:disable-next-line: ban-comma-operator
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) {
            if (_Constants__WEBPACK_IMPORTED_MODULE_1__.ObjProto[strHasOwnProperty].call(s, p)) {
                t[p] = s[p];
            }
        }
    }
    return t;
};
var __assignFn = _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objAssign || __objAssignFnImpl;
// tslint:disable-next-line: only-arrow-functions
var extendStaticsFn = function (d, b) {
    extendStaticsFn = _Constants__WEBPACK_IMPORTED_MODULE_1__.ObjClass.setPrototypeOf ||
        // tslint:disable-next-line: only-arrow-functions
        ({ __proto__: [] } instanceof Array && function (d, b) {
            d.__proto__ = b;
        }) ||
        // tslint:disable-next-line: only-arrow-functions
        function (d, b) {
            for (var p in b) {
                if (b[strHasOwnProperty](p)) {
                    d[p] = b[p];
                }
            }
        };
    return extendStaticsFn(d, b);
};
function __extendsFn(d, b) {
    if (typeof b !== _Constants__WEBPACK_IMPORTED_MODULE_1__.strShimFunction && b !== null) {
        (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.throwTypeError)("Class extends value " + String(b) + " is not a constructor or null");
    }
    extendStaticsFn(d, b);
    function __() {
        this.constructor = d;
    }
    // tslint:disable-next-line: ban-comma-operator
    d[_Constants__WEBPACK_IMPORTED_MODULE_1__.strShimPrototype] = b === null ? (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objCreate)(b) : (__[_Constants__WEBPACK_IMPORTED_MODULE_1__.strShimPrototype] = b[_Constants__WEBPACK_IMPORTED_MODULE_1__.strShimPrototype], new __());
}
function __restFn(s, e) {
    var t = {};
    for (var k in s) {
        if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objHasOwnProperty)(s, k) && e.indexOf(k) < 0) {
            t[k] = s[k];
        }
    }
    if (s != null && typeof _Constants__WEBPACK_IMPORTED_MODULE_1__.ObjClass[strGetOwnPropertySymbols] === _Constants__WEBPACK_IMPORTED_MODULE_1__.strShimFunction) {
        for (var i = 0, p = _Constants__WEBPACK_IMPORTED_MODULE_1__.ObjClass[strGetOwnPropertySymbols](s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && _Constants__WEBPACK_IMPORTED_MODULE_1__.ObjProto.propertyIsEnumerable.call(s, p[i])) {
                t[p[i]] = s[p[i]];
            }
        }
    }
    return t;
}
function __decorateFn(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = _Constants__WEBPACK_IMPORTED_MODULE_1__.ObjClass.getOwnPropertyDescriptor(target, key) : desc, d;
    if (__hasReflect && typeof ReflectObj[strDecorate] === _Constants__WEBPACK_IMPORTED_MODULE_1__.strShimFunction) {
        r = ReflectObj[strDecorate](decorators, target, key, desc);
    }
    else {
        for (var i = decorators.length - 1; i >= 0; i--) {
            // eslint-disable-next-line no-cond-assign
            if (d = decorators[i]) {
                r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
            }
        }
    }
    // tslint:disable-next-line:ban-comma-operator
    return c > 3 && r && (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objDefineProp)(target, key, r), r;
}
function __paramFn(paramIndex, decorator) {
    return function (target, key) {
        decorator(target, key, paramIndex);
    };
}
function __metadataFn(metadataKey, metadataValue) {
    if (__hasReflect && ReflectObj[strMetadata] === _Constants__WEBPACK_IMPORTED_MODULE_1__.strShimFunction) {
        return ReflectObj[strMetadata](metadataKey, metadataValue);
    }
}
function __exportStarFn(m, o) {
    for (var p in m) {
        if (p !== _Constants__WEBPACK_IMPORTED_MODULE_1__.strDefault && !(0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objHasOwnProperty)(o, p)) {
            __createBindingFn(o, m, p);
        }
    }
}
function __createBindingFn(o, m, k, k2) {
    if (k2 === undefined) {
        k2 = k;
    }
    if (!!_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objDefineProp) {
        (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objDefineProp)(o, k2, {
            enumerable: true,
            get: function () {
                return m[k];
            }
        });
    }
    else {
        o[k2] = m[k];
    }
}
function __valuesFn(o) {
    var s = typeof SymbolObj === _Constants__WEBPACK_IMPORTED_MODULE_1__.strShimFunction && SymbolObj[strIterator], m = s && o[s], i = 0;
    if (m) {
        return m.call(o);
    }
    if (o && typeof o.length === "number") {
        return {
            next: function () {
                if (o && i >= o.length) {
                    o = void 0;
                }
                return { value: o && o[i++], done: !o };
            }
        };
    }
    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.throwTypeError)(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __readFn(o, n) {
    var m = typeof SymbolObj === _Constants__WEBPACK_IMPORTED_MODULE_1__.strShimFunction && o[SymbolObj[strIterator]];
    if (!m) {
        return o;
    }
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {
            ar.push(r.value);
        }
    }
    catch (error) {
        e = {
            error: error
        };
    }
    finally {
        try {
            // tslint:disable-next-line:no-conditional-assignment
            if (r && !r.done && (m = i["return"])) {
                m.call(i);
            }
        }
        finally {
            if (e) {
                // eslint-disable-next-line no-unsafe-finally
                throw e.error;
            }
        }
    }
    return ar;
}
/** @deprecated */
function __spreadArraysFn() {
    var theArgs = arguments;
    // Calculate new total size
    for (var s = 0, i = 0, il = theArgs.length; i < il; i++) {
        s += theArgs[i].length;
    }
    // Create new full array
    for (var r = Array(s), k = 0, i = 0; i < il; i++) {
        for (var a = theArgs[i], j = 0, jl = a.length; j < jl; j++, k++) {
            r[k] = a[j];
        }
    }
    return r;
}
function __spreadArrayFn(to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) {
        to[j] = from[i];
    }
    return to;
}
function __makeTemplateObjectFn(cooked, raw) {
    if (_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objDefineProp) {
        (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objDefineProp)(cooked, "raw", { value: raw });
    }
    else {
        cooked.raw = raw;
    }
    return cooked;
}
function __importStarFn(mod) {
    if (mod && mod.__esModule) {
        return mod;
    }
    var result = {};
    if (mod != null) {
        for (var k in mod) {
            if (k !== _Constants__WEBPACK_IMPORTED_MODULE_1__.strDefault && Object.prototype.hasOwnProperty.call(mod, k)) {
                __createBindingFn(result, mod, k);
            }
        }
    }
    // Set default module
    if (!!_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objDefineProp) {
        (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objDefineProp)(result, _Constants__WEBPACK_IMPORTED_MODULE_1__.strDefault, { enumerable: true, value: mod });
    }
    else {
        result[_Constants__WEBPACK_IMPORTED_MODULE_1__.strDefault] = mod;
    }
    return result;
}
function __importDefaultFn(mod) {
    return (mod && mod.__esModule) ? mod : { strDefault: mod };
}
//# sourceMappingURL=TsLibShims.js.map

/***/ }),
/* 34 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ObjClass": () => (/* binding */ ObjClass),
/* harmony export */   "ObjProto": () => (/* binding */ ObjProto),
/* harmony export */   "strDefault": () => (/* binding */ strDefault),
/* harmony export */   "strShimFunction": () => (/* binding */ strShimFunction),
/* harmony export */   "strShimObject": () => (/* binding */ strShimObject),
/* harmony export */   "strShimPrototype": () => (/* binding */ strShimPrototype),
/* harmony export */   "strShimUndefined": () => (/* binding */ strShimUndefined)
/* harmony export */ });
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var strShimFunction = "function";
var strShimObject = "object";
var strShimUndefined = "undefined";
var strShimPrototype = "prototype";
var strDefault = "default";
var ObjClass = Object;
var ObjProto = ObjClass[strShimPrototype];
//# sourceMappingURL=Constants.js.map

/***/ }),
/* 35 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ dynamicProto)
/* harmony export */ });
/* harmony import */ var _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(30);
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var _a;

;
var UNDEFINED = "undefined";
/**
 * Constant string defined to support minimization
 * @ignore
 */
var Constructor = 'constructor';
/**
 * Constant string defined to support minimization
 * @ignore
 */
var Prototype = 'prototype';
/**
 * Constant string defined to support minimization
 * @ignore
 */
var strFunction = 'function';
/**
 * Used to define the name of the instance function lookup table
 * @ignore
 */
var DynInstFuncTable = '_dynInstFuncs';
/**
 * Name used to tag the dynamic prototype function
 * @ignore
 */
var DynProxyTag = '_isDynProxy';
/**
 * Name added to a prototype to define the dynamic prototype "class" name used to lookup the function table
 * @ignore
 */
var DynClassName = '_dynClass';
/**
 * Prefix added to the classname to avoid any name clashes with other instance level properties
 * @ignore
 */
var DynClassNamePrefix = '_dynCls$';
/**
 * A tag which is used to check if we have already to attempted to set the instance function if one is not present
 * @ignore
 */
var DynInstChkTag = '_dynInstChk';
/**
 * A tag which is used to check if we are allows to try and set an instance function is one is not present. Using the same
 * tag name as the function level but a different const name for readability only.
 */
var DynAllowInstChkTag = DynInstChkTag;
/**
 * The global (imported) instances where the global performance options are stored
 */
var DynProtoDefaultOptions = '_dfOpts';
/**
 * Value used as the name of a class when it cannot be determined
 * @ignore
 */
var UnknownValue = '_unknown_';
/**
 * Constant string defined to support minimization
 * @ignore
 */
var str__Proto = "__proto__";
/**
 * The polyfill version of __proto__ so that it doesn't cause issues for anyone not expecting it to exist
 */
var DynProtoBaseProto = "_dyn" + str__Proto;
/**
 * Runtime Global holder for dynamicProto settings
 */
var DynProtoGlobalSettings = "__dynProto$Gbl";
/**
 * Track the current prototype for IE8 as you can't look back to get the prototype
 */
var DynProtoCurrent = "_dynInstProto";
/**
 * Constant string defined to support minimization
 * @ignore
 */
var strUseBaseInst = 'useBaseInst';
/**
 * Constant string defined to support minimization
 * @ignore
 */
var strSetInstFuncs = 'setInstFuncs';
var Obj = Object;
/**
 * Pre-lookup to check if we are running on a modern browser (i.e. not IE8)
 * @ignore
 */
var _objGetPrototypeOf = Obj["getPrototypeOf"];
/**
 * Pre-lookup to check for the existence of this function
 */
var _objGetOwnProps = Obj["getOwnPropertyNames"];
// Since 1.1.7 moving these to the runtime global to work around mixed version and module issues
// See Issue https://github.com/microsoft/DynamicProto-JS/issues/57 for details
var _gbl = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.getGlobal)();
var _gblInst = _gbl[DynProtoGlobalSettings] || (_gbl[DynProtoGlobalSettings] = {
    o: (_a = {},
        _a[strSetInstFuncs] = true,
        _a[strUseBaseInst] = true,
        _a),
    n: 1000 // Start new global index @ 1000 so we "fix" some cases when mixed with 1.1.6 or earlier
});
/**
 * Helper used to check whether the target is an Object prototype or Array prototype
 * @ignore
 */
function _isObjectOrArrayPrototype(target) {
    return target && (target === Obj[Prototype] || target === Array[Prototype]);
}
/**
 * Helper used to check whether the target is an Object prototype, Array prototype or Function prototype
 * @ignore
 */
function _isObjectArrayOrFunctionPrototype(target) {
    return _isObjectOrArrayPrototype(target) || target === Function[Prototype];
}
/**
 * Helper used to get the prototype of the target object as getPrototypeOf is not available in an ES3 environment.
 * @ignore
 */
function _getObjProto(target) {
    var newProto;
    if (target) {
        // This method doesn't exist in older browsers (e.g. IE8)
        if (_objGetPrototypeOf) {
            return _objGetPrototypeOf(target);
        }
        var curProto = target[str__Proto] || target[Prototype] || (target[Constructor] ? target[Constructor][Prototype] : null);
        // Using the pre-calculated value as IE8 doesn't support looking up the prototype of a prototype and thus fails for more than 1 base class
        newProto = target[DynProtoBaseProto] || curProto;
        if (!(0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objHasOwnProperty)(target, DynProtoBaseProto)) {
            // As this prototype doesn't have this property then this is from an inherited class so newProto is the base to return so save it
            // so we can look it up value (which for a multiple hierarchy dynamicProto will be the base class)
            delete target[DynProtoCurrent]; // Delete any current value allocated to this instance so we pick up the value from prototype hierarchy
            newProto = target[DynProtoBaseProto] = target[DynProtoCurrent] || target[DynProtoBaseProto];
            target[DynProtoCurrent] = curProto;
        }
    }
    return newProto;
}
/**
 * Helper to get the properties of an object, including none enumerable ones as functions on a prototype in ES6
 * are not enumerable.
 * @param target
 */
function _forEachProp(target, func) {
    var props = [];
    if (_objGetOwnProps) {
        props = _objGetOwnProps(target);
    }
    else {
        for (var name_1 in target) {
            if (typeof name_1 === "string" && (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objHasOwnProperty)(target, name_1)) {
                props.push(name_1);
            }
        }
    }
    if (props && props.length > 0) {
        for (var lp = 0; lp < props.length; lp++) {
            func(props[lp]);
        }
    }
}
/**
 * Helper function to check whether the provided function name is a potential candidate for dynamic
 * callback and prototype generation.
 * @param target The target object, may be a prototype or class object
 * @param funcName The function name
 * @param skipOwn Skips the check for own property
 * @ignore
 */
function _isDynamicCandidate(target, funcName, skipOwn) {
    return (funcName !== Constructor && typeof target[funcName] === strFunction && (skipOwn || (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objHasOwnProperty)(target, funcName)) && funcName !== str__Proto && funcName !== Prototype);
}
/**
 * Helper to throw a TypeError exception
 * @param message the message
 * @ignore
 */
function _throwTypeError(message) {
    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.throwTypeError)("DynamicProto: " + message);
}
/**
 * Returns a collection of the instance functions that are defined directly on the thisTarget object, it does
 * not return any inherited functions
 * @param thisTarget The object to get the instance functions from
 * @ignore
 */
function _getInstanceFuncs(thisTarget) {
    // Get the base proto
    var instFuncs = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objCreate)(null);
    // Save any existing instance functions
    _forEachProp(thisTarget, function (name) {
        // Don't include any dynamic prototype instances - as we only want the real functions
        if (!instFuncs[name] && _isDynamicCandidate(thisTarget, name, false)) {
            // Create an instance callback for passing the base function to the caller
            instFuncs[name] = thisTarget[name];
        }
    });
    return instFuncs;
}
/**
 * Returns whether the value is included in the array
 * @param values The array of values
 * @param value  The value
 */
function _hasVisited(values, value) {
    for (var lp = values.length - 1; lp >= 0; lp--) {
        if (values[lp] === value) {
            return true;
        }
    }
    return false;
}
/**
 * Returns an object that contains callback functions for all "base/super" functions, this is used to "save"
 * enabling calling super.xxx() functions without requiring that the base "class" has defined a prototype references
 * @param target The current instance
 * @ignore
 */
function _getBaseFuncs(classProto, thisTarget, instFuncs, useBaseInst) {
    function _instFuncProxy(target, funcHost, funcName) {
        var theFunc = funcHost[funcName];
        if (theFunc[DynProxyTag] && useBaseInst) {
            // grab and reuse the hosted looking function (if available) otherwise the original passed function
            var instFuncTable = target[DynInstFuncTable] || {};
            if (instFuncTable[DynAllowInstChkTag] !== false) {
                theFunc = (instFuncTable[funcHost[DynClassName]] || {})[funcName] || theFunc;
            }
        }
        return function () {
            // eslint-disable-next-line prefer-rest-params
            return theFunc.apply(target, arguments);
        };
    }
    // Start creating a new baseFuncs by creating proxies for the instance functions (as they may get replaced)
    var baseFuncs = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objCreate)(null);
    _forEachProp(instFuncs, function (name) {
        // Create an instance callback for passing the base function to the caller
        baseFuncs[name] = _instFuncProxy(thisTarget, instFuncs, name);
    });
    // Get the base prototype functions
    var baseProto = _getObjProto(classProto);
    var visited = [];
    // Don't include base object functions for Object, Array or Function
    while (baseProto && !_isObjectArrayOrFunctionPrototype(baseProto) && !_hasVisited(visited, baseProto)) {
        // look for prototype functions
        _forEachProp(baseProto, function (name) {
            // Don't include any dynamic prototype instances - as we only want the real functions
            // For IE 7/8 the prototype lookup doesn't provide the full chain so we need to bypass the 
            // hasOwnProperty check we get all of the methods, main difference is that IE7/8 doesn't return
            // the Object prototype methods while bypassing the check
            if (!baseFuncs[name] && _isDynamicCandidate(baseProto, name, !_objGetPrototypeOf)) {
                // Create an instance callback for passing the base function to the caller
                baseFuncs[name] = _instFuncProxy(thisTarget, baseProto, name);
            }
        });
        // We need to find all possible functions that might be overloaded by walking the entire prototype chain
        // This avoids the caller from needing to check whether it's direct base class implements the function or not
        // by walking the entire chain it simplifies the usage and issues from upgrading any of the base classes.
        visited.push(baseProto);
        baseProto = _getObjProto(baseProto);
    }
    return baseFuncs;
}
function _getInstFunc(target, funcName, proto, currentDynProtoProxy) {
    var instFunc = null;
    // We need to check whether the class name is defined directly on this prototype otherwise
    // it will walk the proto chain and return any parent proto classname.
    if (target && (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objHasOwnProperty)(proto, DynClassName)) {
        var instFuncTable = target[DynInstFuncTable] || (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objCreate)(null);
        instFunc = (instFuncTable[proto[DynClassName]] || (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objCreate)(null))[funcName];
        if (!instFunc) {
            // Avoid stack overflow from recursive calling the same function
            _throwTypeError("Missing [" + funcName + "] " + strFunction);
        }
        // We have the instance function, lets check it we can speed up further calls
        // by adding the instance function back directly on the instance (avoiding the dynamic func lookup)
        if (!instFunc[DynInstChkTag] && instFuncTable[DynAllowInstChkTag] !== false) {
            // If the instance already has an instance function we can't replace it
            var canAddInst = !(0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objHasOwnProperty)(target, funcName);
            // Get current prototype
            var objProto = _getObjProto(target);
            var visited = [];
            // Lookup the function starting at the top (instance level prototype) and traverse down, if the first matching function
            // if nothing is found or if the first hit is a dynamic proto instance then we can safely add an instance shortcut
            while (canAddInst && objProto && !_isObjectArrayOrFunctionPrototype(objProto) && !_hasVisited(visited, objProto)) {
                var protoFunc = objProto[funcName];
                if (protoFunc) {
                    canAddInst = (protoFunc === currentDynProtoProxy);
                    break;
                }
                // We need to find all possible initial functions to ensure that we don't bypass a valid override function
                visited.push(objProto);
                objProto = _getObjProto(objProto);
            }
            try {
                if (canAddInst) {
                    // This instance doesn't have an instance func and the class hierarchy does have a higher level prototype version
                    // so it's safe to directly assign for any subsequent calls (for better performance)
                    target[funcName] = instFunc;
                }
                // Block further attempts to set the instance function for any
                instFunc[DynInstChkTag] = 1;
            }
            catch (e) {
                // Don't crash if the object is readonly or the runtime doesn't allow changing this
                // And set a flag so we don't try again for any function
                instFuncTable[DynAllowInstChkTag] = false;
            }
        }
    }
    return instFunc;
}
function _getProtoFunc(funcName, proto, currentDynProtoProxy) {
    var protoFunc = proto[funcName];
    // Check that the prototype function is not a self reference -- try to avoid stack overflow!
    if (protoFunc === currentDynProtoProxy) {
        // It is so lookup the base prototype
        protoFunc = _getObjProto(proto)[funcName];
    }
    if (typeof protoFunc !== strFunction) {
        _throwTypeError("[" + funcName + "] is not a " + strFunction);
    }
    return protoFunc;
}
/**
 * Add the required dynamic prototype methods to the the class prototype
 * @param proto - The class prototype
 * @param className - The instance classname
 * @param target - The target instance
 * @param baseInstFuncs - The base instance functions
 * @param setInstanceFunc - Flag to allow prototype function to reset the instance function if one does not exist
 * @ignore
 */
function _populatePrototype(proto, className, target, baseInstFuncs, setInstanceFunc) {
    function _createDynamicPrototype(proto, funcName) {
        var dynProtoProxy = function () {
            // Use the instance or prototype function
            var instFunc = _getInstFunc(this, funcName, proto, dynProtoProxy) || _getProtoFunc(funcName, proto, dynProtoProxy);
            // eslint-disable-next-line prefer-rest-params
            return instFunc.apply(this, arguments);
        };
        // Tag this function as a proxy to support replacing dynamic proxy elements (primary use case is for unit testing
        // via which can dynamically replace the prototype function reference)
        dynProtoProxy[DynProxyTag] = 1;
        return dynProtoProxy;
    }
    if (!_isObjectOrArrayPrototype(proto)) {
        var instFuncTable = target[DynInstFuncTable] = target[DynInstFuncTable] || (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objCreate)(null);
        if (!_isObjectOrArrayPrototype(instFuncTable)) {
            var instFuncs_1 = instFuncTable[className] = (instFuncTable[className] || (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objCreate)(null)); // fetch and assign if as it may not exist yet
            // Set whether we are allow to lookup instances, if someone has set to false then do not re-enable
            if (instFuncTable[DynAllowInstChkTag] !== false) {
                instFuncTable[DynAllowInstChkTag] = !!setInstanceFunc;
            }
            if (!_isObjectOrArrayPrototype(instFuncs_1)) {
                _forEachProp(target, function (name) {
                    // Only add overridden functions
                    if (_isDynamicCandidate(target, name, false) && target[name] !== baseInstFuncs[name]) {
                        // Save the instance Function to the lookup table and remove it from the instance as it's not a dynamic proto function
                        instFuncs_1[name] = target[name];
                        delete target[name];
                        // Add a dynamic proto if one doesn't exist or if a prototype function exists and it's not a dynamic one
                        if (!(0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objHasOwnProperty)(proto, name) || (proto[name] && !proto[name][DynProxyTag])) {
                            proto[name] = _createDynamicPrototype(proto, name);
                        }
                    }
                });
            }
        }
    }
}
/**
 * Checks whether the passed prototype object appears to be correct by walking the prototype hierarchy of the instance
 * @param classProto The class prototype instance
 * @param thisTarget The current instance that will be checked whether the passed prototype instance is in the hierarchy
 * @ignore
 */
function _checkPrototype(classProto, thisTarget) {
    // This method doesn't existing in older browsers (e.g. IE8)
    if (_objGetPrototypeOf) {
        // As this is primarily a coding time check, don't bother checking if running in IE8 or lower
        var visited = [];
        var thisProto = _getObjProto(thisTarget);
        while (thisProto && !_isObjectArrayOrFunctionPrototype(thisProto) && !_hasVisited(visited, thisProto)) {
            if (thisProto === classProto) {
                return true;
            }
            // This avoids the caller from needing to check whether it's direct base class implements the function or not
            // by walking the entire chain it simplifies the usage and issues from upgrading any of the base classes.
            visited.push(thisProto);
            thisProto = _getObjProto(thisProto);
        }
        return false;
    }
    // If objGetPrototypeOf doesn't exist then just assume everything is ok.
    return true;
}
/**
 * Gets the current prototype name using the ES6 name if available otherwise falling back to a use unknown as the name.
 * It's not critical for this to return a name, it's used to decorate the generated unique name for easier debugging only.
 * @param target
 * @param unknownValue
 * @ignore
 */
function _getObjName(target, unknownValue) {
    if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objHasOwnProperty)(target, Prototype)) {
        // Look like a prototype
        return target.name || unknownValue || UnknownValue;
    }
    return (((target || {})[Constructor]) || {}).name || unknownValue || UnknownValue;
}
/**
 * Helper function when creating dynamic (inline) functions for classes, this helper performs the following tasks :-
 * - Saves references to all defined base class functions
 * - Calls the delegateFunc with the current target (this) and a base object reference that can be used to call all "super" functions.
 * - Will populate the class prototype for all overridden functions to support class extension that call the prototype instance.
 * Callers should use this helper when declaring all function within the constructor of a class, as mentioned above the delegateFunc is
 * passed both the target "this" and an object that can be used to call any base (super) functions, using this based object in place of
 * super.XXX() (which gets expanded to _super.prototype.XXX()) provides a better minification outcome and also ensures the correct "this"
 * context is maintained as TypeScript creates incorrect references using super.XXXX() for dynamically defined functions i.e. Functions
 * defined in the constructor or some other function (rather than declared as complete typescript functions).
 * ### Usage
 * ```typescript
 * import dynamicProto from "@microsoft/dynamicproto-js";
 * class ExampleClass extends BaseClass {
 *     constructor() {
 *         dynamicProto(ExampleClass, this, (_self, base) => {
 *             // This will define a function that will be converted to a prototype function
 *             _self.newFunc = () => {
 *                 // Access any "this" instance property
 *                 if (_self.someProperty) {
 *                     ...
 *                 }
 *             }
 *             // This will define a function that will be converted to a prototype function
 *             _self.myFunction = () => {
 *                 // Access any "this" instance property
 *                 if (_self.someProperty) {
 *                     // Call the base version of the function that we are overriding
 *                     base.myFunction();
 *                 }
 *                 ...
 *             }
 *             _self.initialize = () => {
 *                 ...
 *             }
 *             // Warnings: While the following will work as _self is simply a reference to
 *             // this, if anyone overrides myFunction() the overridden will be called first
 *             // as the normal JavaScript method resolution will occur and the defined
 *             // _self.initialize() function is actually gets removed from the instance and
 *             // a proxy prototype version is created to reference the created method.
 *             _self.initialize();
 *         });
 *     }
 * }
 * ```
 * @typeparam DPType This is the generic type of the class, used to keep intellisense valid
 * @typeparam DPCls The type that contains the prototype of the current class
 * @param theClass - This is the current class instance which contains the prototype for the current class
 * @param target - The current "this" (target) reference, when the class has been extended this.prototype will not be the 'theClass' value.
 * @param delegateFunc - The callback function (closure) that will create the dynamic function
 * @param options - Additional options to configure how the dynamic prototype operates
 */
function dynamicProto(theClass, target, delegateFunc, options) {
    // Make sure that the passed theClass argument looks correct
    if (!(0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objHasOwnProperty)(theClass, Prototype)) {
        _throwTypeError("theClass is an invalid class definition.");
    }
    // Quick check to make sure that the passed theClass argument looks correct (this is a common copy/paste error)
    var classProto = theClass[Prototype];
    if (!_checkPrototype(classProto, target)) {
        _throwTypeError("[" + _getObjName(theClass) + "] not in hierarchy of [" + _getObjName(target) + "]");
    }
    var className = null;
    if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objHasOwnProperty)(classProto, DynClassName)) {
        // Only grab the class name if it's defined on this prototype (i.e. don't walk the prototype chain)
        className = classProto[DynClassName];
    }
    else {
        // As not all browser support name on the prototype creating a unique dynamic one if we have not already
        // assigned one, so we can use a simple string as the lookup rather than an object for the dynamic instance
        // function table lookup.
        className = DynClassNamePrefix + _getObjName(theClass, "_") + "$" + _gblInst.n;
        _gblInst.n++;
        classProto[DynClassName] = className;
    }
    var perfOptions = dynamicProto[DynProtoDefaultOptions];
    var useBaseInst = !!perfOptions[strUseBaseInst];
    if (useBaseInst && options && options[strUseBaseInst] !== undefined) {
        useBaseInst = !!options[strUseBaseInst];
    }
    // Get the current instance functions
    var instFuncs = _getInstanceFuncs(target);
    // Get all of the functions for any base instance (before they are potentially overridden)
    var baseFuncs = _getBaseFuncs(classProto, target, instFuncs, useBaseInst);
    // Execute the delegate passing in both the current target "this" and "base" function references
    // Note casting the same type as we don't actually have the base class here and this will provide some intellisense support
    delegateFunc(target, baseFuncs);
    // Don't allow setting instance functions for older IE instances
    var setInstanceFunc = !!_objGetPrototypeOf && !!perfOptions[strSetInstFuncs];
    if (setInstanceFunc && options) {
        setInstanceFunc = !!options[strSetInstFuncs];
    }
    // Populate the Prototype for any overridden instance functions
    _populatePrototype(classProto, className, target, instFuncs, setInstanceFunc !== false);
}
/**
 * Exposes the default global options to allow global configuration, if the global values are disabled these will override
 * any passed values. This is primarily exposed to support unit-testing without the need for individual classes to expose
 * their internal usage of dynamic proto.
 */
dynamicProto[DynProtoDefaultOptions] = _gblInst.o;
//# sourceMappingURL=DynamicProto.js.map

/***/ }),
/* 36 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "_DYN_CAN_HANDLE": () => (/* binding */ _DYN_CAN_HANDLE),
/* harmony export */   "_DYN_HANDLE_FIELD": () => (/* binding */ _DYN_HANDLE_FIELD),
/* harmony export */   "_DYN_INDEX_OF": () => (/* binding */ _DYN_INDEX_OF),
/* harmony export */   "_DYN_INITIALIZE": () => (/* binding */ _DYN_INITIALIZE),
/* harmony export */   "_DYN_KIND": () => (/* binding */ _DYN_KIND),
/* harmony export */   "_DYN_LENGTH": () => (/* binding */ _DYN_LENGTH),
/* harmony export */   "_DYN_LOGGER": () => (/* binding */ _DYN_LOGGER),
/* harmony export */   "_DYN_POLL_INTERNAL_LOGS": () => (/* binding */ _DYN_POLL_INTERNAL_LOGS),
/* harmony export */   "_DYN_PROCESS_TELEMETRY_ST0": () => (/* binding */ _DYN_PROCESS_TELEMETRY_ST0),
/* harmony export */   "_DYN_RM_FIELD_SANITIZER": () => (/* binding */ _DYN_RM_FIELD_SANITIZER),
/* harmony export */   "_DYN_RM_SANITIZER": () => (/* binding */ _DYN_RM_SANITIZER),
/* harmony export */   "_DYN_TIMINGS": () => (/* binding */ _DYN_TIMINGS),
/* harmony export */   "_DYN_VALUE": () => (/* binding */ _DYN_VALUE)
/* harmony export */ });
/*
 * 1DS JS SDK Core, 4.3.0
 * Copyright (c) Microsoft and contributors. All rights reserved.
 * (Microsoft Internal Only)
 */

// Licensed under the MIT License.
// @skip-file-minify
// ##############################################################
// AUTO GENERATED FILE: This file is Auto Generated during build.
// ##############################################################
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// Note: DON'T Export these const from the package as we are still targeting ES3 this will export a mutable variables that someone could change!!!
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
var _DYN_INITIALIZE = "initialize"; // Count: 4
var _DYN_LOGGER = "logger"; // Count: 4
var _DYN_INDEX_OF = "indexOf"; // Count: 4
var _DYN_TIMINGS = "timings"; // Count: 4
var _DYN_POLL_INTERNAL_LOGS = "pollInternalLogs"; // Count: 4
var _DYN_VALUE = "value"; // Count: 20
var _DYN_KIND = "kind"; // Count: 5
var _DYN_LENGTH = "length"; // Count: 7
var _DYN_PROCESS_TELEMETRY_ST0 = "processTelemetryStart"; // Count: 3
var _DYN_HANDLE_FIELD = "handleField"; // Count: 3
var _DYN_RM_SANITIZER = "rmSanitizer"; // Count: 3
var _DYN_RM_FIELD_SANITIZER = "rmFieldSanitizer"; // Count: 3
var _DYN_CAN_HANDLE = "canHandle"; // Count: 7
//# sourceMappingURL=__DynamicConstants.js.map

/***/ }),
/* 37 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PerfEvent": () => (/* binding */ PerfEvent),
/* harmony export */   "PerfManager": () => (/* binding */ PerfManager),
/* harmony export */   "doPerf": () => (/* binding */ doPerf),
/* harmony export */   "getGblPerfMgr": () => (/* binding */ getGblPerfMgr),
/* harmony export */   "setGblPerfMgr": () => (/* binding */ setGblPerfMgr)
/* harmony export */ });
/* harmony import */ var _microsoft_dynamicproto_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(35);
/* harmony import */ var _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(30);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(38);
/* harmony import */ var _InternalConstants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(39);
/*
 * Application Insights JavaScript SDK - Core, 3.3.0
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */






var strExecutionContextKey = "ctx";
var strParentContextKey = "ParentContextKey";
var strChildrenContextKey = "ChildrenContextKey";
var _defaultPerfManager = null;
var PerfEvent = /** @class */ (function () {
    function PerfEvent(name, payloadDetails, isAsync) {
        var _self = this;
        _self.start = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.utcNow)();
        _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_NAME /* @min:%2ename */] = name;
        _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_IS_ASYNC /* @min:%2eisAsync */] = isAsync;
        _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_IS_CHILD_EVT /* @min:%2eisChildEvt */] = function () { return false; };
        if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isFunction)(payloadDetails)) {
            // Create an accessor to minimize the potential performance impact of executing the payloadDetails callback
            var theDetails_1;
            (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objDefine)(_self, "payload", {
                g: function () {
                    // Delay the execution of the payloadDetails until needed
                    if (!theDetails_1 && (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isFunction)(payloadDetails)) {
                        theDetails_1 = payloadDetails();
                        // clear it out now so the referenced objects can be garbage collected
                        payloadDetails = null;
                    }
                    return theDetails_1;
                }
            });
        }
        _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_GET_CTX /* @min:%2egetCtx */] = function (key) {
            if (key) {
                // The parent and child links are located directly on the object (for better viewing in the DebugPlugin)
                if (key === PerfEvent[strParentContextKey] || key === PerfEvent[strChildrenContextKey]) {
                    return _self[key];
                }
                return (_self[strExecutionContextKey] || {})[key];
            }
            return null;
        };
        _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_SET_CTX /* @min:%2esetCtx */] = function (key, value) {
            if (key) {
                // Put the parent and child links directly on the object (for better viewing in the DebugPlugin)
                if (key === PerfEvent[strParentContextKey]) {
                    // Simple assumption, if we are setting a parent then we must be a child
                    if (!_self[key]) {
                        _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_IS_CHILD_EVT /* @min:%2eisChildEvt */] = function () { return true; };
                    }
                    _self[key] = value;
                }
                else if (key === PerfEvent[strChildrenContextKey]) {
                    _self[key] = value;
                }
                else {
                    var ctx = _self[strExecutionContextKey] = _self[strExecutionContextKey] || {};
                    ctx[key] = value;
                }
            }
        };
        _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_COMPLETE /* @min:%2ecomplete */] = function () {
            var childTime = 0;
            var childEvts = _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_GET_CTX /* @min:%2egetCtx */](PerfEvent[strChildrenContextKey]);
            if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isArray)(childEvts)) {
                for (var lp = 0; lp < childEvts[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LENGTH /* @min:%2elength */]; lp++) {
                    var childEvt = childEvts[lp];
                    if (childEvt) {
                        childTime += childEvt[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_TIME /* @min:%2etime */];
                    }
                }
            }
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_TIME /* @min:%2etime */] = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.utcNow)() - _self.start;
            _self.exTime = _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_TIME /* @min:%2etime */] - childTime;
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_COMPLETE /* @min:%2ecomplete */] = function () { };
        };
    }
    PerfEvent.ParentContextKey = "parent";
    PerfEvent.ChildrenContextKey = "childEvts";
    return PerfEvent;
}());

var PerfManager = /** @class */ (function () {
    function PerfManager(manager) {
        /**
         * General bucket used for execution context set and retrieved via setCtx() and getCtx.
         * Defined as private so it can be visualized via the DebugPlugin
         */
        this.ctx = {};
        (0,_microsoft_dynamicproto_js__WEBPACK_IMPORTED_MODULE_2__["default"])(PerfManager, this, function (_self) {
            _self.create = function (src, payloadDetails, isAsync) {
                // TODO (@MSNev): at some point we will want to add additional configuration to "select" which events to instrument
                // for now this is just a simple do everything.
                return new PerfEvent(src, payloadDetails, isAsync);
            };
            _self.fire = function (perfEvent) {
                if (perfEvent) {
                    perfEvent[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_COMPLETE /* @min:%2ecomplete */]();
                    if (manager && (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isFunction)(manager[_InternalConstants__WEBPACK_IMPORTED_MODULE_3__.STR_PERF_EVENT /* @min:%2eperfEvent */])) {
                        manager[_InternalConstants__WEBPACK_IMPORTED_MODULE_3__.STR_PERF_EVENT /* @min:%2eperfEvent */](perfEvent);
                    }
                }
            };
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_SET_CTX /* @min:%2esetCtx */] = function (key, value) {
                if (key) {
                    var ctx = _self[strExecutionContextKey] = _self[strExecutionContextKey] || {};
                    ctx[key] = value;
                }
            };
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_GET_CTX /* @min:%2egetCtx */] = function (key) {
                return (_self[strExecutionContextKey] || {})[key];
            };
        });
    }
// Removed Stub for PerfManager.prototype.create.
// Removed Stub for PerfManager.prototype.fire.
// Removed Stub for PerfManager.prototype.setCtx.
// Removed Stub for PerfManager.prototype.getCtx.
    // This is a workaround for an IE bug when using dynamicProto() with classes that don't have any
    // non-dynamic functions or static properties/functions when using uglify-js to minify the resulting code.
    PerfManager.__ieDyn=1;

    return PerfManager;
}());

var doPerfActiveKey = "CoreUtils.doPerf";
/**
 * Helper function to wrap a function with a perf event
 * @param mgrSource - The Performance Manager or a Performance provider source (may be null)
 * @param getSource - The callback to create the source name for the event (if perf monitoring is enabled)
 * @param func - The function to call and measure
 * @param details - A function to return the payload details
 * @param isAsync - Is the event / function being call asynchronously or synchronously
 */
function doPerf(mgrSource, getSource, func, details, isAsync) {
    if (mgrSource) {
        var perfMgr = mgrSource;
        if (perfMgr[_InternalConstants__WEBPACK_IMPORTED_MODULE_3__.STR_GET_PERF_MGR]) {
            // Looks like a perf manager provider object
            perfMgr = perfMgr[_InternalConstants__WEBPACK_IMPORTED_MODULE_3__.STR_GET_PERF_MGR]();
        }
        if (perfMgr) {
            var perfEvt = void 0;
            var currentActive = perfMgr[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_GET_CTX /* @min:%2egetCtx */](doPerfActiveKey);
            try {
                perfEvt = perfMgr.create(getSource(), details, isAsync);
                if (perfEvt) {
                    if (currentActive && perfEvt[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_SET_CTX /* @min:%2esetCtx */]) {
                        perfEvt[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_SET_CTX /* @min:%2esetCtx */](PerfEvent[strParentContextKey], currentActive);
                        if (currentActive[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_GET_CTX /* @min:%2egetCtx */] && currentActive[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_SET_CTX /* @min:%2esetCtx */]) {
                            var children = currentActive[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_GET_CTX /* @min:%2egetCtx */](PerfEvent[strChildrenContextKey]);
                            if (!children) {
                                children = [];
                                currentActive[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_SET_CTX /* @min:%2esetCtx */](PerfEvent[strChildrenContextKey], children);
                            }
                            children[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_PUSH /* @min:%2epush */](perfEvt);
                        }
                    }
                    // Set this event as the active event now
                    perfMgr[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_SET_CTX /* @min:%2esetCtx */](doPerfActiveKey, perfEvt);
                    return func(perfEvt);
                }
            }
            catch (ex) {
                if (perfEvt && perfEvt[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_SET_CTX /* @min:%2esetCtx */]) {
                    perfEvt[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_SET_CTX /* @min:%2esetCtx */]("exception", ex);
                }
            }
            finally {
                // fire the perf event
                if (perfEvt) {
                    perfMgr.fire(perfEvt);
                }
                // Reset the active event to the previous value
                perfMgr[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_SET_CTX /* @min:%2esetCtx */](doPerfActiveKey, currentActive);
            }
        }
    }
    return func();
}
/**
 * Set the global performance manager to use when there is no core instance or it has not been initialized yet.
 * @param perfManager - The IPerfManager instance to use when no performance manager is supplied.
 */
function setGblPerfMgr(perfManager) {
    _defaultPerfManager = perfManager;
}
/**
 * Get the current global performance manager that will be used with no performance manager is supplied.
 * @returns - The current default manager
 */
function getGblPerfMgr() {
    return _defaultPerfManager;
}
//# sourceMappingURL=PerfManager.js.map

/***/ }),
/* 38 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "_DYN_ADD_NOTIFICATION_LIS1": () => (/* binding */ _DYN_ADD_NOTIFICATION_LIS1),
/* harmony export */   "_DYN_APPLY": () => (/* binding */ _DYN_APPLY),
/* harmony export */   "_DYN_BLK_VAL": () => (/* binding */ _DYN_BLK_VAL),
/* harmony export */   "_DYN_CANCEL": () => (/* binding */ _DYN_CANCEL),
/* harmony export */   "_DYN_COMPLETE": () => (/* binding */ _DYN_COMPLETE),
/* harmony export */   "_DYN_CREATE_NEW": () => (/* binding */ _DYN_CREATE_NEW),
/* harmony export */   "_DYN_DATA": () => (/* binding */ _DYN_DATA),
/* harmony export */   "_DYN_DIAG_LOG": () => (/* binding */ _DYN_DIAG_LOG),
/* harmony export */   "_DYN_ENABLED": () => (/* binding */ _DYN_ENABLED),
/* harmony export */   "_DYN_GET_ALL_RESPONSE_HEA5": () => (/* binding */ _DYN_GET_ALL_RESPONSE_HEA5),
/* harmony export */   "_DYN_GET_CTX": () => (/* binding */ _DYN_GET_CTX),
/* harmony export */   "_DYN_GET_NEXT": () => (/* binding */ _DYN_GET_NEXT),
/* harmony export */   "_DYN_GET_NOTIFY_MGR": () => (/* binding */ _DYN_GET_NOTIFY_MGR),
/* harmony export */   "_DYN_GET_PLUGIN": () => (/* binding */ _DYN_GET_PLUGIN),
/* harmony export */   "_DYN_GET_PROCESS_TEL_CONT2": () => (/* binding */ _DYN_GET_PROCESS_TEL_CONT2),
/* harmony export */   "_DYN_GET_RESPONSE_HEADER": () => (/* binding */ _DYN_GET_RESPONSE_HEADER),
/* harmony export */   "_DYN_HANDLER": () => (/* binding */ _DYN_HANDLER),
/* harmony export */   "_DYN_HDLR": () => (/* binding */ _DYN_HDLR),
/* harmony export */   "_DYN_HEADERS": () => (/* binding */ _DYN_HEADERS),
/* harmony export */   "_DYN_IDENTIFIER": () => (/* binding */ _DYN_IDENTIFIER),
/* harmony export */   "_DYN_INITIALIZE": () => (/* binding */ _DYN_INITIALIZE),
/* harmony export */   "_DYN_INSTRUMENTATION_KEY": () => (/* binding */ _DYN_INSTRUMENTATION_KEY),
/* harmony export */   "_DYN_IS_ASYNC": () => (/* binding */ _DYN_IS_ASYNC),
/* harmony export */   "_DYN_IS_CHILD_EVT": () => (/* binding */ _DYN_IS_CHILD_EVT),
/* harmony export */   "_DYN_IS_INITIALIZED": () => (/* binding */ _DYN_IS_INITIALIZED),
/* harmony export */   "_DYN_ITEMS_RECEIVED": () => (/* binding */ _DYN_ITEMS_RECEIVED),
/* harmony export */   "_DYN_I_KEY": () => (/* binding */ _DYN_I_KEY),
/* harmony export */   "_DYN_LENGTH": () => (/* binding */ _DYN_LENGTH),
/* harmony export */   "_DYN_LOGGER": () => (/* binding */ _DYN_LOGGER),
/* harmony export */   "_DYN_LOGGING_LEVEL_CONSOL4": () => (/* binding */ _DYN_LOGGING_LEVEL_CONSOL4),
/* harmony export */   "_DYN_LOG_INTERNAL_MESSAGE": () => (/* binding */ _DYN_LOG_INTERNAL_MESSAGE),
/* harmony export */   "_DYN_MESSAGE": () => (/* binding */ _DYN_MESSAGE),
/* harmony export */   "_DYN_MESSAGE_ID": () => (/* binding */ _DYN_MESSAGE_ID),
/* harmony export */   "_DYN_NAME": () => (/* binding */ _DYN_NAME),
/* harmony export */   "_DYN_NODE_TYPE": () => (/* binding */ _DYN_NODE_TYPE),
/* harmony export */   "_DYN_NOTIFY": () => (/* binding */ _DYN_NOTIFY),
/* harmony export */   "_DYN_ON_COMPLETE": () => (/* binding */ _DYN_ON_COMPLETE),
/* harmony export */   "_DYN_POLL_INTERNAL_LOGS": () => (/* binding */ _DYN_POLL_INTERNAL_LOGS),
/* harmony export */   "_DYN_PROCESS_NEXT": () => (/* binding */ _DYN_PROCESS_NEXT),
/* harmony export */   "_DYN_PROTOCOL": () => (/* binding */ _DYN_PROTOCOL),
/* harmony export */   "_DYN_PUSH": () => (/* binding */ _DYN_PUSH),
/* harmony export */   "_DYN_RD_ONLY": () => (/* binding */ _DYN_RD_ONLY),
/* harmony export */   "_DYN_REMOVE_NOTIFICATION_0": () => (/* binding */ _DYN_REMOVE_NOTIFICATION_0),
/* harmony export */   "_DYN_REPLACE": () => (/* binding */ _DYN_REPLACE),
/* harmony export */   "_DYN_SEND_POST": () => (/* binding */ _DYN_SEND_POST),
/* harmony export */   "_DYN_SET_CTX": () => (/* binding */ _DYN_SET_CTX),
/* harmony export */   "_DYN_SET_DF": () => (/* binding */ _DYN_SET_DF),
/* harmony export */   "_DYN_SET_NEXT_PLUGIN": () => (/* binding */ _DYN_SET_NEXT_PLUGIN),
/* harmony export */   "_DYN_SET_REQUEST_HEADER": () => (/* binding */ _DYN_SET_REQUEST_HEADER),
/* harmony export */   "_DYN_SPAN_ID": () => (/* binding */ _DYN_SPAN_ID),
/* harmony export */   "_DYN_SPLICE": () => (/* binding */ _DYN_SPLICE),
/* harmony export */   "_DYN_SPLIT": () => (/* binding */ _DYN_SPLIT),
/* harmony export */   "_DYN_STATUS": () => (/* binding */ _DYN_STATUS),
/* harmony export */   "_DYN_STOP_POLLING_INTERNA3": () => (/* binding */ _DYN_STOP_POLLING_INTERNA3),
/* harmony export */   "_DYN_TEARDOWN": () => (/* binding */ _DYN_TEARDOWN),
/* harmony export */   "_DYN_THROW_INTERNAL": () => (/* binding */ _DYN_THROW_INTERNAL),
/* harmony export */   "_DYN_TIME": () => (/* binding */ _DYN_TIME),
/* harmony export */   "_DYN_TIMEOUT": () => (/* binding */ _DYN_TIMEOUT),
/* harmony export */   "_DYN_TO_LOWER_CASE": () => (/* binding */ _DYN_TO_LOWER_CASE),
/* harmony export */   "_DYN_TRACE_FLAGS": () => (/* binding */ _DYN_TRACE_FLAGS),
/* harmony export */   "_DYN_TRACE_ID": () => (/* binding */ _DYN_TRACE_ID),
/* harmony export */   "_DYN_TYPE": () => (/* binding */ _DYN_TYPE),
/* harmony export */   "_DYN_UNLOAD": () => (/* binding */ _DYN_UNLOAD),
/* harmony export */   "_DYN_UPDATE": () => (/* binding */ _DYN_UPDATE),
/* harmony export */   "_DYN_URL_STRING": () => (/* binding */ _DYN_URL_STRING),
/* harmony export */   "_DYN_USER_AGENT": () => (/* binding */ _DYN_USER_AGENT),
/* harmony export */   "_DYN_VALUE": () => (/* binding */ _DYN_VALUE),
/* harmony export */   "_DYN_VERSION": () => (/* binding */ _DYN_VERSION),
/* harmony export */   "_DYN_WARN_TO_CONSOLE": () => (/* binding */ _DYN_WARN_TO_CONSOLE),
/* harmony export */   "_DYN_WATCH": () => (/* binding */ _DYN_WATCH),
/* harmony export */   "_DYN__DO_TEARDOWN": () => (/* binding */ _DYN__DO_TEARDOWN),
/* harmony export */   "_DYN__INACTIVE": () => (/* binding */ _DYN__INACTIVE)
/* harmony export */ });
/*
 * Application Insights JavaScript SDK - Core, 3.3.0
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */


// @skip-file-minify
// ##############################################################
// AUTO GENERATED FILE: This file is Auto Generated during build.
// ##############################################################
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// Note: DON'T Export these const from the package as we are still targeting ES3 this will export a mutable variables that someone could change!!!
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
var _DYN_TO_LOWER_CASE = "toLowerCase"; // Count: 11
var _DYN_BLK_VAL = "blkVal"; // Count: 5
var _DYN_LENGTH = "length"; // Count: 55
var _DYN_RD_ONLY = "rdOnly"; // Count: 4
var _DYN_NOTIFY = "notify"; // Count: 4
var _DYN_WARN_TO_CONSOLE = "warnToConsole"; // Count: 4
var _DYN_THROW_INTERNAL = "throwInternal"; // Count: 5
var _DYN_SET_DF = "setDf"; // Count: 6
var _DYN_WATCH = "watch"; // Count: 8
var _DYN_LOGGER = "logger"; // Count: 21
var _DYN_APPLY = "apply"; // Count: 7
var _DYN_PUSH = "push"; // Count: 34
var _DYN_SPLICE = "splice"; // Count: 8
var _DYN_HDLR = "hdlr"; // Count: 6
var _DYN_CANCEL = "cancel"; // Count: 6
var _DYN_INITIALIZE = "initialize"; // Count: 5
var _DYN_IDENTIFIER = "identifier"; // Count: 8
var _DYN_REMOVE_NOTIFICATION_0 = "removeNotificationListener"; // Count: 4
var _DYN_ADD_NOTIFICATION_LIS1 = "addNotificationListener"; // Count: 4
var _DYN_IS_INITIALIZED = "isInitialized"; // Count: 10
var _DYN_INSTRUMENTATION_KEY = "instrumentationKey"; // Count: 2
var _DYN__INACTIVE = "INACTIVE"; // Count: 3
var _DYN_VALUE = "value"; // Count: 5
var _DYN_GET_NOTIFY_MGR = "getNotifyMgr"; // Count: 5
var _DYN_GET_PLUGIN = "getPlugin"; // Count: 6
var _DYN_NAME = "name"; // Count: 12
var _DYN_I_KEY = "iKey"; // Count: 5
var _DYN_TIME = "time"; // Count: 6
var _DYN_PROCESS_NEXT = "processNext"; // Count: 15
var _DYN_GET_PROCESS_TEL_CONT2 = "getProcessTelContext"; // Count: 2
var _DYN_POLL_INTERNAL_LOGS = "pollInternalLogs"; // Count: 2
var _DYN_ENABLED = "enabled"; // Count: 6
var _DYN_STOP_POLLING_INTERNA3 = "stopPollingInternalLogs"; // Count: 2
var _DYN_UNLOAD = "unload"; // Count: 9
var _DYN_ON_COMPLETE = "onComplete"; // Count: 5
var _DYN_VERSION = "version"; // Count: 6
var _DYN_LOGGING_LEVEL_CONSOL4 = "loggingLevelConsole"; // Count: 2
var _DYN_CREATE_NEW = "createNew"; // Count: 7
var _DYN_TEARDOWN = "teardown"; // Count: 9
var _DYN_MESSAGE_ID = "messageId"; // Count: 4
var _DYN_MESSAGE = "message"; // Count: 7
var _DYN_IS_ASYNC = "isAsync"; // Count: 6
var _DYN_DIAG_LOG = "diagLog"; // Count: 10
var _DYN__DO_TEARDOWN = "_doTeardown"; // Count: 5
var _DYN_UPDATE = "update"; // Count: 6
var _DYN_GET_NEXT = "getNext"; // Count: 12
var _DYN_SET_NEXT_PLUGIN = "setNextPlugin"; // Count: 5
var _DYN_PROTOCOL = "protocol"; // Count: 3
var _DYN_USER_AGENT = "userAgent"; // Count: 5
var _DYN_SPLIT = "split"; // Count: 7
var _DYN_NODE_TYPE = "nodeType"; // Count: 3
var _DYN_REPLACE = "replace"; // Count: 9
var _DYN_LOG_INTERNAL_MESSAGE = "logInternalMessage"; // Count: 2
var _DYN_TYPE = "type"; // Count: 14
var _DYN_HANDLER = "handler"; // Count: 5
var _DYN_STATUS = "status"; // Count: 5
var _DYN_GET_RESPONSE_HEADER = "getResponseHeader"; // Count: 2
var _DYN_GET_ALL_RESPONSE_HEA5 = "getAllResponseHeaders"; // Count: 2
var _DYN_IS_CHILD_EVT = "isChildEvt"; // Count: 3
var _DYN_DATA = "data"; // Count: 7
var _DYN_GET_CTX = "getCtx"; // Count: 6
var _DYN_SET_CTX = "setCtx"; // Count: 10
var _DYN_COMPLETE = "complete"; // Count: 3
var _DYN_ITEMS_RECEIVED = "itemsReceived"; // Count: 3
var _DYN_URL_STRING = "urlString"; // Count: 5
var _DYN_SEND_POST = "sendPOST"; // Count: 3
var _DYN_HEADERS = "headers"; // Count: 5
var _DYN_TIMEOUT = "timeout"; // Count: 6
var _DYN_SET_REQUEST_HEADER = "setRequestHeader"; // Count: 2
var _DYN_TRACE_ID = "traceId"; // Count: 5
var _DYN_SPAN_ID = "spanId"; // Count: 5
var _DYN_TRACE_FLAGS = "traceFlags"; // Count: 6
//# sourceMappingURL=__DynamicConstants.js.map

/***/ }),
/* 39 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "STR_CHANNELS": () => (/* binding */ STR_CHANNELS),
/* harmony export */   "STR_CORE": () => (/* binding */ STR_CORE),
/* harmony export */   "STR_CREATE_PERF_MGR": () => (/* binding */ STR_CREATE_PERF_MGR),
/* harmony export */   "STR_DISABLED": () => (/* binding */ STR_DISABLED),
/* harmony export */   "STR_DOMAIN": () => (/* binding */ STR_DOMAIN),
/* harmony export */   "STR_EMPTY": () => (/* binding */ STR_EMPTY),
/* harmony export */   "STR_EVENTS_DISCARDED": () => (/* binding */ STR_EVENTS_DISCARDED),
/* harmony export */   "STR_EVENTS_SEND_REQUEST": () => (/* binding */ STR_EVENTS_SEND_REQUEST),
/* harmony export */   "STR_EVENTS_SENT": () => (/* binding */ STR_EVENTS_SENT),
/* harmony export */   "STR_EXTENSIONS": () => (/* binding */ STR_EXTENSIONS),
/* harmony export */   "STR_EXTENSION_CONFIG": () => (/* binding */ STR_EXTENSION_CONFIG),
/* harmony export */   "STR_GET_PERF_MGR": () => (/* binding */ STR_GET_PERF_MGR),
/* harmony export */   "STR_NOT_DYNAMIC_ERROR": () => (/* binding */ STR_NOT_DYNAMIC_ERROR),
/* harmony export */   "STR_OFFLINE_DROP": () => (/* binding */ STR_OFFLINE_DROP),
/* harmony export */   "STR_OFFLINE_SENT": () => (/* binding */ STR_OFFLINE_SENT),
/* harmony export */   "STR_OFFLINE_STORE": () => (/* binding */ STR_OFFLINE_STORE),
/* harmony export */   "STR_PATH": () => (/* binding */ STR_PATH),
/* harmony export */   "STR_PERF_EVENT": () => (/* binding */ STR_PERF_EVENT),
/* harmony export */   "STR_PRIORITY": () => (/* binding */ STR_PRIORITY),
/* harmony export */   "STR_PROCESS_TELEMETRY": () => (/* binding */ STR_PROCESS_TELEMETRY),
/* harmony export */   "UNDEFINED_VALUE": () => (/* binding */ UNDEFINED_VALUE)
/* harmony export */ });
/*
 * Application Insights JavaScript SDK - Core, 3.3.0
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */


// ###################################################################################################################################################
// Note: DON'T Export these const from the package as we are still targeting IE/ES5 this will export a mutable variables that someone could change ###
// ###################################################################################################################################################
var UNDEFINED_VALUE = undefined;
var STR_EMPTY = "";
var STR_CHANNELS = "channels";
var STR_CORE = "core";
var STR_CREATE_PERF_MGR = "createPerfMgr";
var STR_DISABLED = "disabled";
var STR_EXTENSION_CONFIG = "extensionConfig";
var STR_EXTENSIONS = "extensions";
var STR_PROCESS_TELEMETRY = "processTelemetry";
var STR_PRIORITY = "priority";
var STR_EVENTS_SENT = "eventsSent";
var STR_EVENTS_DISCARDED = "eventsDiscarded";
var STR_EVENTS_SEND_REQUEST = "eventsSendRequest";
var STR_PERF_EVENT = "perfEvent";
var STR_OFFLINE_STORE = "offlineEventsStored";
var STR_OFFLINE_SENT = "offlineBatchSent";
var STR_OFFLINE_DROP = "offlineBatchDrop";
var STR_GET_PERF_MGR = "getPerfMgr";
var STR_DOMAIN = "domain";
var STR_PATH = "path";
var STR_NOT_DYNAMIC_ERROR = "Not dynamic - ";
//# sourceMappingURL=InternalConstants.js.map

/***/ }),
/* 40 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createDynamicConfig": () => (/* binding */ createDynamicConfig),
/* harmony export */   "onConfigChange": () => (/* binding */ onConfigChange)
/* harmony export */ });
/* harmony import */ var _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(30);
/* harmony import */ var _JavaScriptSDK_DataCacheHelper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(42);
/* harmony import */ var _JavaScriptSDK_InternalConstants__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(39);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(38);
/* harmony import */ var _ConfigDefaults__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(47);
/* harmony import */ var _DynamicProperty__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(46);
/* harmony import */ var _DynamicState__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(48);
/* harmony import */ var _DynamicSupport__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(41);
/*
 * Application Insights JavaScript SDK - Core, 3.3.0
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */










/**
 * Identifies a function which will be re-called whenever any of it's accessed configuration values
 * change.
 * @param configHandler - The callback that will be called for the initial request and then whenever any
 * accessed configuration changes are identified.
 */
function _createAndUseHandler(state, configHandler) {
    var handler = {
        fn: configHandler,
        rm: function () {
            // Clear all references to the handler so it can be garbage collected
            // This will also cause this handler to never get called and eventually removed
            handler.fn = null;
            state = null;
            configHandler = null;
        }
    };
    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objDefine)(handler, "toJSON", { v: function () { return "WatcherHandler" + (handler.fn ? "" : "[X]"); } });
    state.use(handler, configHandler);
    return handler;
}
/**
 * Creates the dynamic config handler and associates with the target config as the root object
 * @param target - The config that you want to be root of the dynamic config
 * @param inPlace - Should the passed config be converted in-place or a new proxy returned
 * @returns The existing dynamic handler or a new instance with the provided config values
 */
function _createDynamicHandler(logger, target, inPlace) {
    var _a;
    var dynamicHandler = (0,_DynamicSupport__WEBPACK_IMPORTED_MODULE_1__.getDynamicConfigHandler)(target);
    if (dynamicHandler) {
        // The passed config is already dynamic so return it's tracker
        return dynamicHandler;
    }
    var uid = (0,_JavaScriptSDK_DataCacheHelper__WEBPACK_IMPORTED_MODULE_2__.createUniqueNamespace)("dyncfg", true);
    var newTarget = (target && inPlace !== false) ? target : (0,_DynamicSupport__WEBPACK_IMPORTED_MODULE_1__._cfgDeepCopy)(target);
    var theState;
    function _notifyWatchers() {
        theState[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_NOTIFY /* @min:%2enotify */]();
    }
    function _setValue(target, name, value) {
        try {
            target = (0,_DynamicProperty__WEBPACK_IMPORTED_MODULE_4__._setDynamicProperty)(theState, target, name, value);
        }
        catch (e) {
            // Unable to convert to dynamic property so just leave as non-dynamic
            (0,_DynamicProperty__WEBPACK_IMPORTED_MODULE_4__._throwDynamicError)(logger, name, "Setting value", e);
        }
        return target[name];
    }
    function _watch(configHandler) {
        return _createAndUseHandler(theState, configHandler);
    }
    function _block(configHandler, allowUpdate) {
        theState.use(null, function (details) {
            var prevUpd = theState.upd;
            try {
                if (!(0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(allowUpdate)) {
                    theState.upd = allowUpdate;
                }
                configHandler(details);
            }
            finally {
                theState.upd = prevUpd;
            }
        });
    }
    function _ref(target, name) {
        var _a;
        // Make sure it's dynamic and mark as referenced with it's current value
        return (0,_DynamicProperty__WEBPACK_IMPORTED_MODULE_4__._setDynamicPropertyState)(theState, target, name, (_a = {}, _a[0 /* _eSetDynamicPropertyFlags.inPlace */] = true, _a))[name];
    }
    function _rdOnly(target, name) {
        var _a;
        // Make sure it's dynamic and mark as readonly with it's current value
        return (0,_DynamicProperty__WEBPACK_IMPORTED_MODULE_4__._setDynamicPropertyState)(theState, target, name, (_a = {}, _a[1 /* _eSetDynamicPropertyFlags.readOnly */] = true, _a))[name];
    }
    function _blkPropValue(target, name) {
        var _a;
        // Make sure it's dynamic and mark as readonly with it's current value
        return (0,_DynamicProperty__WEBPACK_IMPORTED_MODULE_4__._setDynamicPropertyState)(theState, target, name, (_a = {}, _a[2 /* _eSetDynamicPropertyFlags.blockDynamicProperty */] = true, _a))[name];
    }
    function _applyDefaults(theConfig, defaultValues) {
        if (defaultValues) {
            // Resolve/apply the defaults
            (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objForEachKey)(defaultValues, function (name, value) {
                // Sets the value and makes it dynamic (if it doesn't already exist)
                (0,_ConfigDefaults__WEBPACK_IMPORTED_MODULE_5__._applyDefaultValue)(cfgHandler, theConfig, name, value);
            });
        }
        return theConfig;
    }
    var cfgHandler = (_a = {
            uid: null,
            cfg: newTarget
        },
        _a[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LOGGER /* @min:logger */] = logger,
        _a[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_NOTIFY /* @min:notify */] = _notifyWatchers,
        _a.set = _setValue,
        _a[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_SET_DF /* @min:setDf */] = _applyDefaults,
        _a[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_WATCH /* @min:watch */] = _watch,
        _a.ref = _ref,
        _a[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_RD_ONLY /* @min:rdOnly */] = _rdOnly,
        _a[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_BLK_VAL /* @min:blkVal */] = _blkPropValue,
        _a._block = _block,
        _a);
    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objDefine)(cfgHandler, "uid", {
        c: false,
        e: false,
        w: false,
        v: uid
    });
    theState = (0,_DynamicState__WEBPACK_IMPORTED_MODULE_6__._createState)(cfgHandler);
    // Setup tracking for all defined default keys
    (0,_DynamicProperty__WEBPACK_IMPORTED_MODULE_4__._makeDynamicObject)(theState, newTarget, "config", "Creating");
    return cfgHandler;
}
/**
 * Log an invalid access message to the console
 * @param message
 */
function _logInvalidAccess(logger, message) {
    if (logger) {
        logger[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_WARN_TO_CONSOLE /* @min:%2ewarnToConsole */](message);
        logger[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_THROW_INTERNAL /* @min:%2ethrowInternal */](2 /* eLoggingSeverity.WARNING */, 108 /* _eInternalMessageId.DynamicConfigException */, message);
    }
    else {
        // We don't have a logger so just throw an exception
        (0,_DynamicSupport__WEBPACK_IMPORTED_MODULE_1__.throwInvalidAccess)(message);
    }
}
/**
 * Create or return a dynamic version of the passed config, if it is not already dynamic
 * @param config - The config to be converted into a dynamic config
 * @param defaultConfig - The default values to apply on the config if the properties don't already exist
 * @param inPlace - Should the config be converted in-place into a dynamic config or a new instance returned, defaults to true
 * @returns The dynamic config handler for the config (whether new or existing)
 */
function createDynamicConfig(config, defaultConfig, logger, inPlace) {
    var dynamicHandler = _createDynamicHandler(logger, config || {}, inPlace);
    if (defaultConfig) {
        dynamicHandler[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_SET_DF /* @min:%2esetDf */](dynamicHandler.cfg, defaultConfig);
    }
    return dynamicHandler;
}
/**
 * Watch and track changes for accesses to the current config, the provided config MUST already be
 * a dynamic config or a child accessed via the dynamic config
 * @param config
 * @param configHandler
 * @param logger - The logger instance to use if there is no existing handler
 * @returns A watcher handler instance that can be used to remove itself when being unloaded
 * @throws TypeError if the provided config is not a dynamic config instance
 */
function onConfigChange(config, configHandler, logger) {
    var handler = config[_DynamicSupport__WEBPACK_IMPORTED_MODULE_1__.CFG_HANDLER_LINK] || config;
    if (handler.cfg && (handler.cfg === config || handler.cfg[_DynamicSupport__WEBPACK_IMPORTED_MODULE_1__.CFG_HANDLER_LINK] === handler)) {
        return handler[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_WATCH /* @min:%2ewatch */](configHandler);
    }
    _logInvalidAccess(logger, _JavaScriptSDK_InternalConstants__WEBPACK_IMPORTED_MODULE_7__.STR_NOT_DYNAMIC_ERROR + (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.dumpObj)(config));
    return createDynamicConfig(config, null, logger)[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_WATCH /* @min:%2ewatch */](configHandler);
}
//# sourceMappingURL=DynamicConfig.js.map

/***/ }),
/* 41 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CFG_HANDLER_LINK": () => (/* binding */ CFG_HANDLER_LINK),
/* harmony export */   "_canMakeDynamic": () => (/* binding */ _canMakeDynamic),
/* harmony export */   "_cfgDeepCopy": () => (/* binding */ _cfgDeepCopy),
/* harmony export */   "blockDynamicConversion": () => (/* binding */ blockDynamicConversion),
/* harmony export */   "forceDynamicConversion": () => (/* binding */ forceDynamicConversion),
/* harmony export */   "getDynamicConfigHandler": () => (/* binding */ getDynamicConfigHandler),
/* harmony export */   "throwInvalidAccess": () => (/* binding */ throwInvalidAccess)
/* harmony export */ });
/* harmony import */ var _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(30);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(38);
/*
 * Application Insights JavaScript SDK - Core, 3.3.0
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */




// Using Symbol.for so that if the same symbol was already created it would be returned
// To handle multiple instances using potentially different versions we are not using
// createUniqueNamespace()
var CFG_HANDLER_LINK = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.symbolFor)("[[ai_dynCfg_1]]");
/**
 * @internal
 * @ignore
 * The symbol to tag objects / arrays with if they should not be converted
 */
var BLOCK_DYNAMIC = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.symbolFor)("[[ai_blkDynCfg_1]]");
/**
 * @internal
 * @ignore
 * The symbol to tag objects to indicate that when included into the configuration that
 * they should be converted into a trackable dynamic object.
 */
var FORCE_DYNAMIC = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.symbolFor)("[[ai_frcDynCfg_1]]");
function _cfgDeepCopy(source) {
    if (source) {
        var target_1;
        if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isArray)(source)) {
            target_1 = [];
            target_1[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LENGTH /* @min:%2elength */] = source[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LENGTH /* @min:%2elength */];
        }
        else if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(source)) {
            target_1 = {};
        }
        if (target_1) {
            // Copying index values by property name as the extensionConfig can be an array or object
            (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objForEachKey)(source, function (key, value) {
                // Perform a deep copy of the object
                target_1[key] = _cfgDeepCopy(value);
            });
            return target_1;
        }
    }
    return source;
}
/**
 * @internal
 * Get the dynamic config handler if the value is already dynamic
 * @param value
 * @returns
 */
function getDynamicConfigHandler(value) {
    if (value) {
        var handler = value[CFG_HANDLER_LINK] || value;
        if (handler.cfg && (handler.cfg === value || handler.cfg[CFG_HANDLER_LINK] === handler)) {
            return handler;
        }
    }
    return null;
}
/**
 * Mark the provided value so that if it's included into the configuration it will NOT have
 * its properties converted into a dynamic (reactive) object. If the object is not a plain object
 * or an array (ie. a class) this function has not affect as only Objects and Arrays are converted
 * into dynamic objects in the dynamic configuration.
 *
 * When you have tagged a value as both {@link forceDynamicConversion} and blocked force will take precedence.
 *
 * You should only need to use this function, if you are creating dynamic "classes" from objects
 * which confirm to the require interface. A common case for this is during unit testing where it's
 * easier to create mock extensions.
 *
 * If `value` is falsy (null / undefined / 0 / empty string etc) it will not be tagged and
 * if there is an exception adding the property to the value (because its frozen etc) the
 * exception will be swallowed
 *
 * @example
 * ```ts
 * // This is a valid "extension", but it is technically an object
 * // So when included in the config.extensions it WILL be cloned and then
 * // converted into a dynamic object, where all of its properties will become
 * // get/set object properties and will be tracked. While this WILL still
 * // function, when attempt to use a mocking framework on top of this the
 * // functions are now technically get accessors which return a function
 * // and this can cause some mocking frameworks to fail.
 * let mockChannel = {
 *      pause: () => { },
*      resume: () => { },
*      teardown: () => { },
*      flush: (async: any, callBack: any) => { },
*      processTelemetry: (env: any) => { },
*      setNextPlugin: (next: any) => { },
*      initialize: (config: any, core: any, extensions: any) => { },
*      identifier: "testChannel",
*      priority: 1003
* };
 * ```
 * @param value - The object that you want to block from being converted into a
 * trackable dynamic object
 * @returns The original value
 */
function blockDynamicConversion(value) {
    if (value && ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value) || (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isArray)(value))) {
        try {
            value[BLOCK_DYNAMIC] = true;
        }
        catch (e) {
            // Don't throw for this case as it's an ask only
        }
    }
    return value;
}
/**
 * This is the reverse case of {@link blockDynamicConversion} in that this will tag an
 * object to indicate that it should always be converted into a dynamic trackable object
 * even when not an object or array. So all properties of this object will become
 * get / set accessor functions.
 *
 * When you have tagged a value as both {@link forceDynamicConversion} and blocked force will take precedence.
 *
 * If `value` is falsy (null / undefined / 0 / empty string etc) it will not be tagged and
 * if there is an exception adding the property to the value (because its frozen etc) the
 * exception will be swallowed.
 * @param value - The object that should be tagged and converted if included into a dynamic
 * configuration.
 * @returns The original value
 */
function forceDynamicConversion(value) {
    if (value) {
        try {
            value[FORCE_DYNAMIC] = true;
        }
        catch (e) {
            // Don't throw for this case as it's an ask only
        }
    }
    return value;
}
/**
 * @internal
 * @ignore
 * Helper function to check whether an object can or should be converted into a dynamic
 * object.
 * @param value - The object to check whether it should be converted
 * @returns `true` if the value should be converted otherwise `false`.
 */
function _canMakeDynamic(getFunc, state, value) {
    var result = false;
    // Object must exist and be truthy
    if (value && !getFunc[state.blkVal]) {
        // Tagged as always convert
        result = value[FORCE_DYNAMIC];
        // Check that it's not explicitly tagged as blocked
        if (!result && !value[BLOCK_DYNAMIC]) {
            // Only convert plain objects or arrays by default
            result = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value) || (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isArray)(value);
        }
    }
    return result;
}
/**
 * Throws an invalid access exception
 * @param message - The message to include in the exception
 */
function throwInvalidAccess(message) {
    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.throwTypeError)("InvalidAccess:" + message);
}
//# sourceMappingURL=DynamicSupport.js.map

/***/ }),
/* 42 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createElmNodeData": () => (/* binding */ createElmNodeData),
/* harmony export */   "createUniqueNamespace": () => (/* binding */ createUniqueNamespace)
/* harmony export */ });
/* harmony import */ var _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(30);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(38);
/* harmony import */ var _HelperFuncs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(45);
/* harmony import */ var _InternalConstants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(39);
/* harmony import */ var _RandomHelper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(43);
/*
 * Application Insights JavaScript SDK - Core, 3.3.0
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */







var version = '3.3.0';
var instanceName = "." + (0,_RandomHelper__WEBPACK_IMPORTED_MODULE_0__.newId)(6);
var _dataUid = 0;
// Accepts only:
//  - Node
//    - Node.ELEMENT_NODE
//    - Node.DOCUMENT_NODE
//  - Object
//    - Any
function _canAcceptData(target) {
    return target[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_NODE_TYPE /* @min:%2enodeType */] === 1 || target[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_NODE_TYPE /* @min:%2enodeType */] === 9 || !(+target[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_NODE_TYPE /* @min:%2enodeType */]);
}
function _getCache(data, target) {
    var theCache = target[data.id];
    if (!theCache) {
        theCache = {};
        try {
            if (_canAcceptData(target)) {
                (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_2__.objDefine)(target, data.id, {
                    e: false,
                    v: theCache
                });
            }
        }
        catch (e) {
            // Not all environments allow extending all objects, so just ignore the cache in those cases
        }
    }
    return theCache;
}
function createUniqueNamespace(name, includeVersion) {
    if (includeVersion === void 0) { includeVersion = false; }
    return (0,_HelperFuncs__WEBPACK_IMPORTED_MODULE_3__.normalizeJsName)(name + (_dataUid++) + (includeVersion ? "." + version : _InternalConstants__WEBPACK_IMPORTED_MODULE_4__.STR_EMPTY) + instanceName);
}
function createElmNodeData(name) {
    var data = {
        id: createUniqueNamespace("_aiData-" + (name || _InternalConstants__WEBPACK_IMPORTED_MODULE_4__.STR_EMPTY) + "." + version),
        accept: function (target) {
            return _canAcceptData(target);
        },
        get: function (target, name, defValue, addDefault) {
            var theCache = target[data.id];
            if (!theCache) {
                if (addDefault) {
                    // Side effect is adds the cache
                    theCache = _getCache(data, target);
                    theCache[(0,_HelperFuncs__WEBPACK_IMPORTED_MODULE_3__.normalizeJsName)(name)] = defValue;
                }
                return defValue;
            }
            return theCache[(0,_HelperFuncs__WEBPACK_IMPORTED_MODULE_3__.normalizeJsName)(name)];
        },
        kill: function (target, name) {
            if (target && target[name]) {
                try {
                    delete target[name];
                }
                catch (e) {
                    // Just cleaning up, so if this fails -- ignore
                }
            }
        }
    };
    return data;
}
//# sourceMappingURL=DataCacheHelper.js.map

/***/ }),
/* 43 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "mwcRandom32": () => (/* binding */ mwcRandom32),
/* harmony export */   "mwcRandomSeed": () => (/* binding */ mwcRandomSeed),
/* harmony export */   "newId": () => (/* binding */ newId),
/* harmony export */   "random32": () => (/* binding */ random32),
/* harmony export */   "randomValue": () => (/* binding */ randomValue)
/* harmony export */ });
/* harmony import */ var _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(30);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(38);
/* harmony import */ var _EnvUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(44);
/* harmony import */ var _InternalConstants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(39);
/*
 * Application Insights JavaScript SDK - Core, 3.3.0
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */






var UInt32Mask = 0x100000000;
var MaxUInt32 = 0xffffffff;
var SEED1 = 123456789;
var SEED2 = 987654321;
// MWC based Random generator (for IE)
var _mwcSeeded = false;
var _mwcW = SEED1;
var _mwcZ = SEED2;
// Takes any integer
function _mwcSeed(seedValue) {
    if (seedValue < 0) {
        // Make sure we end up with a positive number and not -ve one.
        seedValue >>>= 0;
    }
    _mwcW = (SEED1 + seedValue) & MaxUInt32;
    _mwcZ = (SEED2 - seedValue) & MaxUInt32;
    _mwcSeeded = true;
}
function _autoSeedMwc() {
    // Simple initialization using default Math.random() - So we inherit any entropy from the browser
    // and bitwise XOR with the current milliseconds
    try {
        var now = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.utcNow)() & 0x7fffffff;
        _mwcSeed(((Math.random() * UInt32Mask) ^ now) + now);
    }
    catch (e) {
        // Don't crash if something goes wrong
    }
}
/**
 * Generate a random value between 0 and maxValue, max value should be limited to a 32-bit maximum.
 * So maxValue(16) will produce a number from 0..16 (range of 17)
 * @param maxValue
 */
function randomValue(maxValue) {
    if (maxValue > 0) {
        return Math.floor((random32() / MaxUInt32) * (maxValue + 1)) >>> 0;
    }
    return 0;
}
/**
 * generate a random 32-bit number (0x000000..0xFFFFFFFF) or (-0x80000000..0x7FFFFFFF), defaults un-unsigned.
 * @param signed - True to return a signed 32-bit number (-0x80000000..0x7FFFFFFF) otherwise an unsigned one (0x000000..0xFFFFFFFF)
 */
function random32(signed) {
    var value = 0;
    var c = (0,_EnvUtils__WEBPACK_IMPORTED_MODULE_1__.getCrypto)() || (0,_EnvUtils__WEBPACK_IMPORTED_MODULE_1__.getMsCrypto)();
    if (c && c.getRandomValues) {
        // Make sure the number is converted into the specified range (-0x80000000..0x7FFFFFFF)
        value = c.getRandomValues(new Uint32Array(1))[0] & MaxUInt32;
    }
    if (value === 0 && (0,_EnvUtils__WEBPACK_IMPORTED_MODULE_1__.isIE)()) {
        // For IE 6, 7, 8 (especially on XP) Math.random is not very random
        if (!_mwcSeeded) {
            // Set the seed for the Mwc algorithm
            _autoSeedMwc();
        }
        // Don't use Math.random for IE
        // Make sure the number is converted into the specified range (-0x80000000..0x7FFFFFFF)
        value = mwcRandom32() & MaxUInt32;
    }
    if (value === 0) {
        // Make sure the number is converted into the specified range (-0x80000000..0x7FFFFFFF)
        value = Math.floor((UInt32Mask * Math.random()) | 0);
    }
    if (!signed) {
        // Make sure we end up with a positive number and not -ve one.
        value >>>= 0;
    }
    return value;
}
/**
 * Seed the MWC random number generator with the specified seed or a random value
 * @param value - optional the number to used as the seed, if undefined, null or zero a random value will be chosen
 */
function mwcRandomSeed(value) {
    if (!value) {
        _autoSeedMwc();
    }
    else {
        _mwcSeed(value);
    }
}
/**
 * Generate a random 32-bit number between (0x000000..0xFFFFFFFF) or (-0x80000000..0x7FFFFFFF), using MWC (Multiply with carry)
 * instead of Math.random() defaults to un-signed.
 * Used as a replacement random generator for IE to avoid issues with older IE instances.
 * @param signed - True to return a signed 32-bit number (-0x80000000..0x7FFFFFFF) otherwise an unsigned one (0x000000..0xFFFFFFFF)
 */
function mwcRandom32(signed) {
    _mwcZ = (36969 * (_mwcZ & 0xFFFF) + (_mwcZ >> 16)) & MaxUInt32;
    _mwcW = (18000 * (_mwcW & 0xFFFF) + (_mwcW >> 16)) & MaxUInt32;
    var value = (((_mwcZ << 16) + (_mwcW & 0xFFFF)) >>> 0) & MaxUInt32 | 0;
    if (!signed) {
        // Make sure we end up with a positive number and not -ve one.
        value >>>= 0;
    }
    return value;
}
/**
 * Generate random base64 id string.
 * The default length is 22 which is 132-bits so almost the same as a GUID but as base64 (the previous default was 5)
 * @param maxLength - Optional value to specify the length of the id to be generated, defaults to 22
 */
function newId(maxLength) {
    if (maxLength === void 0) { maxLength = 22; }
    var base64chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    // Start with an initial random number, consuming the value in reverse byte order
    var number = random32() >>> 0; // Make sure it's a +ve number
    var chars = 0;
    var result = _InternalConstants__WEBPACK_IMPORTED_MODULE_2__.STR_EMPTY;
    while (result[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LENGTH /* @min:%2elength */] < maxLength) {
        chars++;
        result += base64chars.charAt(number & 0x3F);
        number >>>= 6; // Zero fill with right shift
        if (chars === 5) {
            // 5 base64 characters === 30 bits so we don't have enough bits for another base64 char
            // So add on another 30 bits and make sure it's +ve
            number = (((random32() << 2) & 0xFFFFFFFF) | (number & 0x03)) >>> 0;
            chars = 0; // We need to reset the number every 5 chars (30 bits)
        }
    }
    return result;
}
//# sourceMappingURL=RandomHelper.js.map

/***/ }),
/* 44 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createCustomDomEvent": () => (/* binding */ createCustomDomEvent),
/* harmony export */   "dispatchEvent": () => (/* binding */ dispatchEvent),
/* harmony export */   "findMetaTag": () => (/* binding */ findMetaTag),
/* harmony export */   "findNamedServerTiming": () => (/* binding */ findNamedServerTiming),
/* harmony export */   "getConsole": () => (/* binding */ getConsole),
/* harmony export */   "getCrypto": () => (/* binding */ getCrypto),
/* harmony export */   "getIEVersion": () => (/* binding */ getIEVersion),
/* harmony export */   "getJSON": () => (/* binding */ getJSON),
/* harmony export */   "getLocation": () => (/* binding */ getLocation),
/* harmony export */   "getMsCrypto": () => (/* binding */ getMsCrypto),
/* harmony export */   "hasJSON": () => (/* binding */ hasJSON),
/* harmony export */   "isBeaconsSupported": () => (/* binding */ isBeaconsSupported),
/* harmony export */   "isFetchSupported": () => (/* binding */ isFetchSupported),
/* harmony export */   "isIE": () => (/* binding */ isIE),
/* harmony export */   "isReactNative": () => (/* binding */ isReactNative),
/* harmony export */   "isSafari": () => (/* binding */ isSafari),
/* harmony export */   "isXhrSupported": () => (/* binding */ isXhrSupported),
/* harmony export */   "sendCustomEvent": () => (/* binding */ sendCustomEvent),
/* harmony export */   "setEnableEnvMocks": () => (/* binding */ setEnableEnvMocks),
/* harmony export */   "useXDomainRequest": () => (/* binding */ useXDomainRequest)
/* harmony export */ });
/* harmony import */ var _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(34);
/* harmony import */ var _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(30);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(38);
/* harmony import */ var _HelperFuncs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(45);
/* harmony import */ var _InternalConstants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(39);
/*
 * Application Insights JavaScript SDK - Core, 3.3.0
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */








/**
 * This file exists to hold environment utilities that are required to check and
 * validate the current operating environment. Unless otherwise required, please
 * only use defined methods (functions) in this class so that users of these
 * functions/properties only need to include those that are used within their own modules.
 */
var strDocumentMode = "documentMode";
var strLocation = "location";
var strConsole = "console";
var strJSON = "JSON";
var strCrypto = "crypto";
var strMsCrypto = "msCrypto";
var strReactNative = "ReactNative";
var strMsie = "msie";
var strTrident = "trident/";
var strXMLHttpRequest = "XMLHttpRequest";
var _isTrident = null;
var _navUserAgentCheck = null;
var _enableMocks = false;
var _useXDomainRequest = null;
var _beaconsSupported = null;
function _hasProperty(theClass, property) {
    var supported = false;
    if (theClass) {
        try {
            supported = property in theClass;
            if (!supported) {
                var proto = theClass[_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_0__.strShimPrototype];
                if (proto) {
                    supported = property in proto;
                }
            }
        }
        catch (e) {
            // Do Nothing
        }
        if (!supported) {
            try {
                var tmp = new theClass();
                supported = !(0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.isUndefined)(tmp[property]);
            }
            catch (e) {
                // Do Nothing
            }
        }
    }
    return supported;
}
/**
 * Enable the lookup of test mock objects if requested
 * @param enabled
 */
function setEnableEnvMocks(enabled) {
    _enableMocks = enabled;
}
/**
 * Returns the global location object if it is present otherwise null.
 * This helper is used to access the location object without causing an exception
 * "Uncaught ReferenceError: location is not defined"
 */
function getLocation(checkForMock) {
    if (checkForMock && _enableMocks) {
        var mockLocation = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.getInst)("__mockLocation");
        if (mockLocation) {
            return mockLocation;
        }
    }
    if (typeof location === _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_0__.strShimObject && location) {
        return location;
    }
    return (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.getInst)(strLocation);
}
/**
 * Returns the global console object
 */
function getConsole() {
    if (typeof console !== _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_0__.strShimUndefined) {
        return console;
    }
    return (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.getInst)(strConsole);
}
/**
 * Checks if JSON object is available, this is required as we support the API running without a
 * window /document (eg. Node server, electron webworkers) and if we attempt to assign a history
 * object to a local variable or pass as an argument an "Uncaught ReferenceError: JSON is not defined"
 * exception will be thrown.
 * Defined as a function to support lazy / late binding environments.
 */
function hasJSON() {
    return Boolean((typeof JSON === _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_0__.strShimObject && JSON) || (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.getInst)(strJSON) !== null);
}
/**
 * Returns the global JSON object if it is present otherwise null.
 * This helper is used to access the JSON object without causing an exception
 * "Uncaught ReferenceError: JSON is not defined"
 */
function getJSON() {
    if (hasJSON()) {
        return JSON || (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.getInst)(strJSON);
    }
    return null;
}
/**
 * Returns the crypto object if it is present otherwise null.
 * This helper is used to access the crypto object from the current
 * global instance which could be window or globalThis for a web worker
 */
function getCrypto() {
    return (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.getInst)(strCrypto);
}
/**
 * Returns the crypto object if it is present otherwise null.
 * This helper is used to access the crypto object from the current
 * global instance which could be window or globalThis for a web worker
 */
function getMsCrypto() {
    return (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.getInst)(strMsCrypto);
}
/**
 * Returns whether the environment is reporting that we are running in a React Native Environment
 */
function isReactNative() {
    // If running in React Native, navigator.product will be populated
    var nav = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.getNavigator)();
    if (nav && nav.product) {
        return nav.product === strReactNative;
    }
    return false;
}
/**
 * Identifies whether the current environment appears to be IE
 */
function isIE() {
    var nav = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.getNavigator)();
    if (nav && (nav[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_USER_AGENT /* @min:%2euserAgent */] !== _navUserAgentCheck || _isTrident === null)) {
        // Added to support test mocking of the user agent
        _navUserAgentCheck = nav[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_USER_AGENT /* @min:%2euserAgent */];
        var userAgent = (_navUserAgentCheck || _InternalConstants__WEBPACK_IMPORTED_MODULE_3__.STR_EMPTY)[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_TO_LOWER_CASE /* @min:%2etoLowerCase */]();
        _isTrident = ((0,_HelperFuncs__WEBPACK_IMPORTED_MODULE_4__.strContains)(userAgent, strMsie) || (0,_HelperFuncs__WEBPACK_IMPORTED_MODULE_4__.strContains)(userAgent, strTrident));
    }
    return _isTrident;
}
/**
 * Gets IE version returning the document emulation mode if we are running on IE, or null otherwise
 */
function getIEVersion(userAgentStr) {
    if (userAgentStr === void 0) { userAgentStr = null; }
    if (!userAgentStr) {
        var navigator_1 = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.getNavigator)() || {};
        userAgentStr = navigator_1 ? (navigator_1.userAgent || _InternalConstants__WEBPACK_IMPORTED_MODULE_3__.STR_EMPTY)[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_TO_LOWER_CASE /* @min:%2etoLowerCase */]() : _InternalConstants__WEBPACK_IMPORTED_MODULE_3__.STR_EMPTY;
    }
    var ua = (userAgentStr || _InternalConstants__WEBPACK_IMPORTED_MODULE_3__.STR_EMPTY)[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_TO_LOWER_CASE /* @min:%2etoLowerCase */]();
    // Also check for documentMode in case X-UA-Compatible meta tag was included in HTML.
    if ((0,_HelperFuncs__WEBPACK_IMPORTED_MODULE_4__.strContains)(ua, strMsie)) {
        var doc = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.getDocument)() || {};
        return Math.max(parseInt(ua[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_SPLIT /* @min:%2esplit */](strMsie)[1]), (doc[strDocumentMode] || 0));
    }
    else if ((0,_HelperFuncs__WEBPACK_IMPORTED_MODULE_4__.strContains)(ua, strTrident)) {
        var tridentVer = parseInt(ua[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_SPLIT /* @min:%2esplit */](strTrident)[1]);
        if (tridentVer) {
            return tridentVer + 4;
        }
    }
    return null;
}
function isSafari(userAgentStr) {
    if (!userAgentStr || !(0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.isString)(userAgentStr)) {
        var navigator_2 = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.getNavigator)() || {};
        userAgentStr = navigator_2 ? (navigator_2.userAgent || _InternalConstants__WEBPACK_IMPORTED_MODULE_3__.STR_EMPTY)[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_TO_LOWER_CASE /* @min:%2etoLowerCase */]() : _InternalConstants__WEBPACK_IMPORTED_MODULE_3__.STR_EMPTY;
    }
    var ua = (userAgentStr || _InternalConstants__WEBPACK_IMPORTED_MODULE_3__.STR_EMPTY)[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_TO_LOWER_CASE /* @min:%2etoLowerCase */]();
    return ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.strIndexOf)(ua, "safari") >= 0);
}
/**
 * Checks if HTML5 Beacons are supported in the current environment.
 * @param useCached - [Optional] used for testing to bypass the cached lookup, when `true` this will
 * cause the cached global to be reset.
 * @returns True if supported, false otherwise.
 */
function isBeaconsSupported(useCached) {
    if (_beaconsSupported === null || useCached === false) {
        _beaconsSupported = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.hasNavigator)() && Boolean((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.getNavigator)().sendBeacon);
    }
    return _beaconsSupported;
}
/**
 * Checks if the Fetch API is supported in the current environment.
 * @param withKeepAlive - [Optional] If True, check if fetch is available and it supports the keepalive feature, otherwise only check if fetch is supported
 * @returns True if supported, otherwise false
 */
function isFetchSupported(withKeepAlive) {
    var isSupported = false;
    try {
        isSupported = !!(0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.getInst)("fetch");
        var request = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.getInst)("Request");
        if (isSupported && withKeepAlive && request) {
            isSupported = _hasProperty(request, "keepalive");
        }
    }
    catch (e) {
        // Just Swallow any failure during availability checks
    }
    return isSupported;
}
function useXDomainRequest() {
    if (_useXDomainRequest === null) {
        _useXDomainRequest = (typeof XDomainRequest !== _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_0__.strShimUndefined);
        if (_useXDomainRequest && isXhrSupported()) {
            _useXDomainRequest = _useXDomainRequest && !_hasProperty((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.getInst)(strXMLHttpRequest), "withCredentials");
        }
    }
    return _useXDomainRequest;
}
/**
 * Checks if XMLHttpRequest is supported
 * @returns True if supported, otherwise false
 */
function isXhrSupported() {
    var isSupported = false;
    try {
        var xmlHttpRequest = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.getInst)(strXMLHttpRequest);
        isSupported = !!xmlHttpRequest;
    }
    catch (e) {
        // Just Swallow any failure during availability checks
    }
    return isSupported;
}
function _getNamedValue(values, name) {
    if (values) {
        for (var i = 0; i < values[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_LENGTH /* @min:%2elength */]; i++) {
            var value = values[i];
            if (value[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_NAME /* @min:%2ename */]) {
                if (value[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_NAME /* @min:%2ename */] === name) {
                    return value;
                }
            }
        }
    }
    return {};
}
/**
 * Helper function to fetch the named meta-tag from the page.
 * @param name
 */
function findMetaTag(name) {
    var doc = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.getDocument)();
    if (doc && name) {
        // Look for a meta-tag
        return _getNamedValue(doc.querySelectorAll("meta"), name).content;
    }
    return null;
}
/**
 * Helper function to fetch the named server timing value from the page response (first navigation event).
 * @param name
 */
function findNamedServerTiming(name) {
    var value;
    var perf = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.getPerformance)();
    if (perf) {
        // Try looking for a server-timing header
        var navPerf = perf.getEntriesByType("navigation") || [];
        value = _getNamedValue((navPerf[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_LENGTH /* @min:%2elength */] > 0 ? navPerf[0] : {}).serverTiming, name).description;
    }
    return value;
}
// TODO: should reuse this method for analytics plugin
function dispatchEvent(target, evnt) {
    if (target && target.dispatchEvent && evnt) {
        target.dispatchEvent(evnt);
        return true;
    }
    return false;
}
function createCustomDomEvent(eventName, details) {
    var event = null;
    var detail = { detail: details || null };
    if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.isFunction)(CustomEvent)) { // Use CustomEvent constructor when available
        event = new CustomEvent(eventName, detail);
    }
    else { // CustomEvent has no constructor in IE
        var doc = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.getDocument)();
        if (doc && doc.createEvent) {
            event = doc.createEvent("CustomEvent");
            event.initCustomEvent(eventName, true, true, detail);
        }
    }
    return event;
}
function sendCustomEvent(evtName, cfg, customDetails) {
    var global = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.getGlobal)();
    if (global && global.CustomEvent) {
        try {
            var details = { cfg: cfg || null, customDetails: customDetails || null };
            return dispatchEvent(global, createCustomDomEvent(evtName, details));
        }
        catch (e) {
            // eslint-disable-next-line no-empty
        }
    }
    return false;
}
//# sourceMappingURL=EnvUtils.js.map

/***/ }),
/* 45 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "_appendHeader": () => (/* binding */ _appendHeader),
/* harmony export */   "_getAllResponseHeaders": () => (/* binding */ _getAllResponseHeaders),
/* harmony export */   "_getObjProto": () => (/* binding */ _getObjProto),
/* harmony export */   "asString": () => (/* binding */ asString),
/* harmony export */   "convertAllHeadersToMap": () => (/* binding */ convertAllHeadersToMap),
/* harmony export */   "createClassFromInterface": () => (/* binding */ createClassFromInterface),
/* harmony export */   "deepFreeze": () => (/* binding */ deepFreeze),
/* harmony export */   "formatErrorMessageXdr": () => (/* binding */ formatErrorMessageXdr),
/* harmony export */   "formatErrorMessageXhr": () => (/* binding */ formatErrorMessageXhr),
/* harmony export */   "getExceptionName": () => (/* binding */ getExceptionName),
/* harmony export */   "getResponseText": () => (/* binding */ getResponseText),
/* harmony export */   "getSetValue": () => (/* binding */ getSetValue),
/* harmony export */   "isFeatureEnabled": () => (/* binding */ isFeatureEnabled),
/* harmony export */   "isNotNullOrUndefined": () => (/* binding */ isNotNullOrUndefined),
/* harmony export */   "isNotUndefined": () => (/* binding */ isNotUndefined),
/* harmony export */   "normalizeJsName": () => (/* binding */ normalizeJsName),
/* harmony export */   "objExtend": () => (/* binding */ objExtend),
/* harmony export */   "openXhr": () => (/* binding */ openXhr),
/* harmony export */   "optimizeObject": () => (/* binding */ optimizeObject),
/* harmony export */   "prependTransports": () => (/* binding */ prependTransports),
/* harmony export */   "proxyAssign": () => (/* binding */ proxyAssign),
/* harmony export */   "proxyFunctionAs": () => (/* binding */ proxyFunctionAs),
/* harmony export */   "proxyFunctions": () => (/* binding */ proxyFunctions),
/* harmony export */   "setValue": () => (/* binding */ setValue),
/* harmony export */   "strContains": () => (/* binding */ strContains),
/* harmony export */   "toISOString": () => (/* binding */ toISOString)
/* harmony export */ });
/* harmony import */ var _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(30);
/* harmony import */ var _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(34);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(38);
/* harmony import */ var _InternalConstants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(39);
/*
 * Application Insights JavaScript SDK - Core, 3.3.0
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */






// RESTRICT and AVOID circular dependencies you should not import other contained modules or export the contents of this file directly
// Added to help with minification
var strGetPrototypeOf = "getPrototypeOf";
var rCamelCase = /-([a-z])/g;
var rNormalizeInvalid = /([^\w\d_$])/g;
var rLeadingNumeric = /^(\d+[\w\d_$])/;
var _getObjProto = Object[strGetPrototypeOf];
function isNotUndefined(value) {
    return !(0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(value);
}
function isNotNullOrUndefined(value) {
    return !(0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(value);
}
/**
 * Validates that the string name conforms to the JS IdentifierName specification and if not
 * normalizes the name so that it would. This method does not identify or change any keywords
 * meaning that if you pass in a known keyword the same value will be returned.
 * This is a simplified version
 * @param name - The name to validate
 */
function normalizeJsName(name) {
    var value = name;
    if (value && (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isString)(value)) {
        // CamelCase everything after the "-" and remove the dash
        value = value[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_REPLACE /* @min:%2ereplace */](rCamelCase, function (_all, letter) {
            return letter.toUpperCase();
        });
        value = value[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_REPLACE /* @min:%2ereplace */](rNormalizeInvalid, "_");
        value = value[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_REPLACE /* @min:%2ereplace */](rLeadingNumeric, function (_all, match) {
            return "_" + match;
        });
    }
    return value;
}
/**
 * A simple wrapper (for minification support) to check if the value contains the search string.
 * @param value - The string value to check for the existence of the search value
 * @param search - The value search within the value
 */
function strContains(value, search) {
    if (value && search) {
        return (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.strIndexOf)(value, search) !== -1;
    }
    return false;
}
/**
 * Convert a date to I.S.O. format in IE8
 */
function toISOString(date) {
    return date && date.toISOString() || "";
}
var deepFreeze = _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objDeepFreeze;
/**
 * Returns the name of object if it's an Error. Otherwise, returns empty string.
 */
function getExceptionName(object) {
    if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isError)(object)) {
        return object[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_NAME /* @min:%2ename */];
    }
    return _InternalConstants__WEBPACK_IMPORTED_MODULE_2__.STR_EMPTY;
}
/**
 * Sets the provided value on the target instance using the field name when the provided chk function returns true, the chk
 * function will only be called if the new value is no equal to the original value.
 * @param target - The target object
 * @param field - The key of the target
 * @param value - The value to set
 * @param valChk - [Optional] Callback to check the value that if supplied will be called check if the new value can be set
 * @param srcChk - [Optional] Callback to check to original value that if supplied will be called if the new value should be set (if allowed)
 * @returns The existing or new value, depending what was set
 */
function setValue(target, field, value, valChk, srcChk) {
    var theValue = value;
    if (target) {
        theValue = target[field];
        if (theValue !== value && (!srcChk || srcChk(theValue)) && (!valChk || valChk(value))) {
            theValue = value;
            target[field] = theValue;
        }
    }
    return theValue;
}
/**
 * Returns the current value from the target object if not null or undefined otherwise sets the new value and returns it
 * @param target - The target object to return or set the default value
 * @param field - The key for the field to set on the target
 * @param defValue - [Optional] The value to set if not already present, when not provided a empty object will be added
 */
function getSetValue(target, field, defValue) {
    var theValue;
    if (target) {
        theValue = target[field];
        if (!theValue && (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(theValue)) {
            // Supports having the default as null
            theValue = !(0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(defValue) ? defValue : {};
            target[field] = theValue;
        }
    }
    else {
        // Expanded for performance so we only check defValue if required
        theValue = !(0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(defValue) ? defValue : {};
    }
    return theValue;
}
function _createProxyFunction(source, funcName) {
    var srcFunc = null;
    var src = null;
    if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isFunction)(source)) {
        srcFunc = source;
    }
    else {
        src = source;
    }
    return function () {
        // Capture the original arguments passed to the method
        var originalArguments = arguments;
        if (srcFunc) {
            src = srcFunc();
        }
        if (src) {
            return src[funcName][_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_APPLY /* @min:%2eapply */](src, originalArguments);
        }
    };
}
/**
 * Effectively assigns all enumerable properties (not just own properties) and functions (including inherited prototype) from
 * the source object to the target, it attempts to use proxy getters / setters (if possible) and proxy functions to avoid potential
 * implementation issues by assigning prototype functions as instance ones
 *
 * This method is the primary method used to "update" the snippet proxy with the ultimate implementations.
 *
 * Special ES3 Notes:
 * Updates (setting) of direct property values on the target or indirectly on the source object WILL NOT WORK PROPERLY, updates to the
 * properties of "referenced" object will work (target.context.newValue = 10 => will be reflected in the source.context as it's the
 * same object). ES3 Failures: assigning target.myProp = 3 -> Won't change source.myProp = 3, likewise the reverse would also fail.
 * @param target - The target object to be assigned with the source properties and functions
 * @param source - The source object which will be assigned / called by setting / calling the targets proxies
 * @param chkSet - An optional callback to determine whether a specific property/function should be proxied
 */
function proxyAssign(target, source, chkSet) {
    if (target && source && (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isObject)(target) && (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isObject)(source)) {
        var _loop_1 = function (field) {
            if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isString)(field)) {
                var value = source[field];
                if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isFunction)(value)) {
                    if (!chkSet || chkSet(field, true, source, target)) {
                        // Create a proxy function rather than just copying the (possible) prototype to the new object as an instance function
                        target[field] = _createProxyFunction(source, field);
                    }
                }
                else if (!chkSet || chkSet(field, false, source, target)) {
                    if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objHasOwn)(target, field)) {
                        // Remove any previous instance property
                        delete target[field];
                    }
                    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objDefine)(target, field, {
                        g: function () {
                            return source[field];
                        },
                        s: function (theValue) {
                            source[field] = theValue;
                        }
                    });
                }
            }
        };
        // effectively apply/proxy full source to the target instance
        for (var field in source) {
            _loop_1(field);
        }
    }
    return target;
}
/**
 * Creates a proxy function on the target which internally will call the source version with all arguments passed to the target method.
 *
 * @param target - The target object to be assigned with the source properties and functions
 * @param name - The function name that will be added on the target
 * @param source - The source object which will be assigned / called by setting / calling the targets proxies
 * @param theFunc - The function name on the source that will be proxied on the target
 * @param overwriteTarget - If `false` this will not replace any pre-existing name otherwise (the default) it will overwrite any existing name
 */
function proxyFunctionAs(target, name, source, theFunc, overwriteTarget) {
    if (target && name && source) {
        if (overwriteTarget !== false || (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(target[name])) {
            target[name] = _createProxyFunction(source, theFunc);
        }
    }
}
/**
 * Creates proxy functions on the target which internally will call the source version with all arguments passed to the target method.
 *
 * @param target - The target object to be assigned with the source properties and functions
 * @param source - The source object which will be assigned / called by setting / calling the targets proxies
 * @param functionsToProxy - An array of function names that will be proxied on the target
 * @param overwriteTarget - If false this will not replace any pre-existing name otherwise (the default) it will overwrite any existing name
 */
function proxyFunctions(target, source, functionsToProxy, overwriteTarget) {
    if (target && source && (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isObject)(target) && (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isArray)(functionsToProxy)) {
        (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrForEach)(functionsToProxy, function (theFuncName) {
            if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isString)(theFuncName)) {
                proxyFunctionAs(target, theFuncName, source, theFuncName, overwriteTarget);
            }
        });
    }
    return target;
}
/**
 * Simpler helper to create a dynamic class that implements the interface and populates the values with the defaults.
 * Only instance properties (hasOwnProperty) values are copied from the defaults to the new instance
 * @param defaults - Simple helper
 */
function createClassFromInterface(defaults) {
    return /** @class */ (function () {
        function class_1() {
            var _this = this;
            if (defaults) {
                (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objForEachKey)(defaults, function (field, value) {
                    _this[field] = value;
                });
            }
        }
        return class_1;
    }());
}
/**
 * A helper function to assist with JIT performance for objects that have properties added / removed dynamically
 * this is primarily for chromium based browsers and has limited effects on Firefox and none of IE. Only call this
 * function after you have finished "updating" the object, calling this within loops reduces or defeats the benefits.
 * This helps when iterating using for..in, objKeys() and objForEach()
 * @param theObject - The object to be optimized if possible
 */
function optimizeObject(theObject) {
    // V8 Optimization to cause the JIT compiler to create a new optimized object for looking up the own properties
    // primarily for object with <= 19 properties for >= 20 the effect is reduced or non-existent
    if (theObject && _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objAssign) {
        theObject = (0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_3__.ObjClass)((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objAssign)({}, theObject));
    }
    return theObject;
}
function objExtend(obj1, obj2, obj3, obj4, obj5, obj6) {
    // Variables
    var theArgs = arguments;
    var extended = theArgs[0] || {};
    var argLen = theArgs[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LENGTH /* @min:%2elength */];
    var deep = false;
    var idx = 1;
    // Check for "Deep" flag
    if (argLen > 0 && (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isBoolean)(extended)) {
        deep = extended;
        extended = theArgs[idx] || {};
        idx++;
    }
    // Handle case when target is a string or something (possible in deep copy)
    if (!(0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isObject)(extended)) {
        extended = {};
    }
    // Loop through each remaining object and conduct a merge
    for (; idx < argLen; idx++) {
        var arg = theArgs[idx];
        var isArgArray = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isArray)(arg);
        var isArgObj = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isObject)(arg);
        for (var prop in arg) {
            var propOk = (isArgArray && (prop in arg)) || (isArgObj && (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objHasOwn)(arg, prop));
            if (!propOk) {
                continue;
            }
            var newValue = arg[prop];
            var isNewArray = void 0;
            // If deep merge and property is an object, merge properties
            if (deep && newValue && ((isNewArray = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isArray)(newValue)) || (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(newValue))) {
                // Grab the current value of the extended object
                var clone = extended[prop];
                if (isNewArray) {
                    if (!(0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isArray)(clone)) {
                        // We can't "merge" an array with a non-array so overwrite the original
                        clone = [];
                    }
                }
                else if (!(0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(clone)) {
                    // We can't "merge" an object with a non-object
                    clone = {};
                }
                // Never move the original objects always clone them
                newValue = objExtend(deep, clone, newValue);
            }
            // Assign the new (or previous) value (unless undefined)
            if (newValue !== undefined) {
                extended[prop] = newValue;
            }
        }
    }
    return extended;
}
var asString = _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.asString;
function isFeatureEnabled(feature, cfg) {
    var rlt = false;
    var ft = cfg && cfg.featureOptIn && cfg.featureOptIn[feature];
    if (feature && ft) {
        var mode = ft.mode;
        // NOTE: None will be considered as true
        rlt = (mode == 3 /* FeatureOptInMode.enable */) || (mode == 1 /* FeatureOptInMode.none */);
    }
    return rlt;
}
function getResponseText(xhr) {
    try {
        return xhr.responseText;
    }
    catch (e) {
        // Best effort, as XHR may throw while XDR wont so just ignore
    }
    return null;
}
function formatErrorMessageXdr(xdr, message) {
    if (xdr) {
        return "XDomainRequest,Response:" + getResponseText(xdr) || 0;
    }
    return message;
}
function formatErrorMessageXhr(xhr, message) {
    if (xhr) {
        return "XMLHttpRequest,Status:" + xhr[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_STATUS /* @min:%2estatus */] + ",Response:" + getResponseText(xhr) || 0 || 0;
    }
    return message;
}
function prependTransports(theTransports, newTransports) {
    if (newTransports) {
        if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isNumber)(newTransports)) {
            theTransports = [newTransports].concat(theTransports);
        }
        else if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isArray)(newTransports)) {
            theTransports = newTransports.concat(theTransports);
        }
    }
    return theTransports;
}
var strDisabledPropertyName = "Microsoft_ApplicationInsights_BypassAjaxInstrumentation";
var strWithCredentials = "withCredentials";
var strTimeout = "timeout";
/**
 * Create and open an XMLHttpRequest object
 * @param method - The request method
 * @param urlString - The url
 * @param withCredentials - Option flag indicating that credentials should be sent
 * @param disabled - Optional flag indicating that the XHR object should be marked as disabled and not tracked (default is false)
 * @param isSync - Optional flag indicating if the instance should be a synchronous request (defaults to false)
 * @param timeout - Optional value identifying the timeout value that should be assigned to the XHR request
 * @returns A new opened XHR request
 */
function openXhr(method, urlString, withCredentials, disabled, isSync, timeout) {
    if (disabled === void 0) { disabled = false; }
    if (isSync === void 0) { isSync = false; }
    function _wrapSetXhrProp(xhr, prop, value) {
        try {
            xhr[prop] = value;
        }
        catch (e) {
            // - Wrapping as depending on the environment setting the property may fail (non-terminally)
        }
    }
    var xhr = new XMLHttpRequest();
    if (disabled) {
        // Tag the instance so it's not tracked (trackDependency)
        // If the environment has locked down the XMLHttpRequest (preventExtensions and/or freeze), this would
        // cause the request to fail and we no telemetry would be sent
        _wrapSetXhrProp(xhr, strDisabledPropertyName, disabled);
    }
    if (withCredentials) {
        // Some libraries require that the withCredentials flag is set "before" open and
        // - Wrapping as IE 10 has started throwing when setting before open
        _wrapSetXhrProp(xhr, strWithCredentials, withCredentials);
    }
    xhr.open(method, urlString, !isSync);
    if (withCredentials) {
        // withCredentials should be set AFTER open (https://xhr.spec.whatwg.org/#the-withcredentials-attribute)
        // And older firefox instances from 11+ will throw for sync events (current versions don't) which happens during unload processing
        _wrapSetXhrProp(xhr, strWithCredentials, withCredentials);
    }
    // Only set the timeout for asynchronous requests as
    // "Timeout shouldn't be used for synchronous XMLHttpRequests requests used in a document environment or it will throw an InvalidAccessError exception.""
    // https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/timeout
    if (!isSync && timeout) {
        _wrapSetXhrProp(xhr, strTimeout, timeout);
    }
    return xhr;
}
/**
* Converts the XHR getAllResponseHeaders to a map containing the header key and value.
* @internal
*/
// tslint:disable-next-line: align
function convertAllHeadersToMap(headersString) {
    var headers = {};
    if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isString)(headersString)) {
        var headersArray = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.strTrim)(headersString)[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_SPLIT /* @min:%2esplit */](/[\r\n]+/);
        (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrForEach)(headersArray, function (headerEntry) {
            if (headerEntry) {
                var idx = headerEntry.indexOf(": ");
                if (idx !== -1) {
                    // The new spec has the headers returning all as lowercase -- but not all browsers do this yet
                    var header = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.strTrim)(headerEntry.substring(0, idx))[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_TO_LOWER_CASE /* @min:%2etoLowerCase */]();
                    var value = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.strTrim)(headerEntry.substring(idx + 1));
                    headers[header] = value;
                }
                else {
                    headers[(0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.strTrim)(headerEntry)] = 1;
                }
            }
        });
    }
    return headers;
}
/**
* append the XHR headers.
* @internal
*/
function _appendHeader(theHeaders, xhr, name) {
    if (!theHeaders[name] && xhr && xhr[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_GET_RESPONSE_HEADER /* @min:%2egetResponseHeader */]) {
        var value = xhr[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_GET_RESPONSE_HEADER /* @min:%2egetResponseHeader */](name);
        if (value) {
            theHeaders[name] = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.strTrim)(value);
        }
    }
    return theHeaders;
}
var STR_KILL_DURATION_HEADER = "kill-duration";
var STR_KILL_DURATION_SECONDS_HEADER = "kill-duration-seconds";
var STR_TIME_DELTA_HEADER = "time-delta-millis";
/**
* get the XHR getAllResponseHeaders.
* @internal
*/
function _getAllResponseHeaders(xhr, isOneDs) {
    var theHeaders = {};
    if (!xhr[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_GET_ALL_RESPONSE_HEA5 /* @min:%2egetAllResponseHeaders */]) {
        // Firefox 2-63 doesn't have getAllResponseHeaders function but it does have getResponseHeader
        // Only call these if getAllResponseHeaders doesn't exist, otherwise we can get invalid response errors
        // as collector is not currently returning the correct header to allow JS to access these headers
        if (!!isOneDs) {
            theHeaders = _appendHeader(theHeaders, xhr, STR_TIME_DELTA_HEADER);
            theHeaders = _appendHeader(theHeaders, xhr, STR_KILL_DURATION_HEADER);
            theHeaders = _appendHeader(theHeaders, xhr, STR_KILL_DURATION_SECONDS_HEADER);
        }
    }
    else {
        theHeaders = convertAllHeadersToMap(xhr[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_GET_ALL_RESPONSE_HEA5 /* @min:%2egetAllResponseHeaders */]());
    }
    return theHeaders;
}
//# sourceMappingURL=HelperFuncs.js.map

/***/ }),
/* 46 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "_makeDynamicObject": () => (/* binding */ _makeDynamicObject),
/* harmony export */   "_setDynamicProperty": () => (/* binding */ _setDynamicProperty),
/* harmony export */   "_setDynamicPropertyState": () => (/* binding */ _setDynamicPropertyState),
/* harmony export */   "_throwDynamicError": () => (/* binding */ _throwDynamicError)
/* harmony export */ });
/* harmony import */ var _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(30);
/* harmony import */ var _JavaScriptSDK_InternalConstants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(39);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38);
/* harmony import */ var _DynamicSupport__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(41);
/*
 * Application Insights JavaScript SDK - Core, 3.3.0
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */






var arrayMethodsToPatch = [
    "push",
    "pop",
    "shift",
    "unshift",
    "splice"
];
var _throwDynamicError = function (logger, name, desc, e) {
    logger && logger[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_THROW_INTERNAL /* @min:%2ethrowInternal */](3 /* eLoggingSeverity.DEBUG */, 108 /* _eInternalMessageId.DynamicConfigException */, "".concat(desc, " [").concat(name, "] failed - ") + (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.dumpObj)(e));
};
function _patchArray(state, target, name) {
    if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.isArray)(target)) {
        // Monkey Patch the methods that might change the array
        (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.arrForEach)(arrayMethodsToPatch, function (method) {
            var orgMethod = target[method];
            target[method] = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                var result = orgMethod[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_APPLY /* @min:%2eapply */](this, args);
                // items may be added, removed or moved so need to make some new dynamic properties
                _makeDynamicObject(state, target, name, "Patching");
                return result;
            };
        });
    }
}
function _getOwnPropGetter(target, name) {
    var propDesc = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.objGetOwnPropertyDescriptor)(target, name);
    return propDesc && propDesc.get;
}
function _createDynamicProperty(state, theConfig, name, value) {
    // Does not appear to be dynamic so lets make it so
    var detail = {
        n: name,
        h: [],
        trk: function (handler) {
            if (handler && handler.fn) {
                if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.arrIndexOf)(detail.h, handler) === -1) {
                    // Add this handler to the collection that should be notified when the value changes
                    detail.h[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_PUSH /* @min:%2epush */](handler);
                }
                state.trk(handler, detail);
            }
        },
        clr: function (handler) {
            var idx = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.arrIndexOf)(detail.h, handler);
            if (idx !== -1) {
                detail.h[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_SPLICE /* @min:%2esplice */](idx, 1);
            }
        }
    };
    // Flag to optimize lookup response time by avoiding additional function calls
    var checkDynamic = true;
    var isObjectOrArray = false;
    function _getProperty() {
        if (checkDynamic) {
            isObjectOrArray = isObjectOrArray || (0,_DynamicSupport__WEBPACK_IMPORTED_MODULE_2__._canMakeDynamic)(_getProperty, state, value);
            // Make sure that if it's an object that we make it dynamic
            if (value && !value[_DynamicSupport__WEBPACK_IMPORTED_MODULE_2__.CFG_HANDLER_LINK] && isObjectOrArray) {
                // It doesn't look like it's already dynamic so lets make sure it's converted the object into a dynamic Config as well
                value = _makeDynamicObject(state, value, name, "Converting");
            }
            // If it needed to be converted it now has been
            checkDynamic = false;
        }
        // If there is an active handler then add it to the tracking set of handlers
        var activeHandler = state.act;
        if (activeHandler) {
            detail.trk(activeHandler);
        }
        return value;
    }
    // Tag this getter as our dynamic property and provide shortcut for notifying a change
    _getProperty[state.prop] = {
        chng: function () {
            state.add(detail);
        }
    };
    function _setProperty(newValue) {
        if (value !== newValue) {
            if (!!_getProperty[state.ro] && !state.upd) {
                // field is marked as readonly so return false
                (0,_DynamicSupport__WEBPACK_IMPORTED_MODULE_2__.throwInvalidAccess)("[" + name + "] is read-only:" + (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.dumpObj)(theConfig));
            }
            if (checkDynamic) {
                isObjectOrArray = isObjectOrArray || (0,_DynamicSupport__WEBPACK_IMPORTED_MODULE_2__._canMakeDynamic)(_getProperty, state, value);
                checkDynamic = false;
            }
            // The value must be a plain object or an array to enforce the reference (in-place updates)
            var isReferenced = isObjectOrArray && _getProperty[state.rf];
            if (isObjectOrArray) {
                // We are about to replace a plain object or an array
                if (isReferenced) {
                    // Reassign the properties from the current value to the same properties from the newValue
                    // This will set properties not in the newValue to undefined
                    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.objForEachKey)(value, function (key) {
                        value[key] = newValue ? newValue[key] : _JavaScriptSDK_InternalConstants__WEBPACK_IMPORTED_MODULE_3__.UNDEFINED_VALUE;
                    });
                    // Now assign / re-assign value with all of the keys from newValue
                    try {
                        (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.objForEachKey)(newValue, function (key, theValue) {
                            _setDynamicProperty(state, value, key, theValue);
                        });
                        // Now drop newValue so when we assign value later it keeps the existing reference
                        newValue = value;
                    }
                    catch (e) {
                        // Unable to convert to dynamic property so just leave as non-dynamic
                        _throwDynamicError((state.hdlr || {})[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_LOGGER /* @min:%2elogger */], name, "Assigning", e);
                        // Mark as not an object or array so we don't try and do this again
                        isObjectOrArray = false;
                    }
                }
                else if (value && value[_DynamicSupport__WEBPACK_IMPORTED_MODULE_2__.CFG_HANDLER_LINK]) {
                    // As we are replacing the value, if it's already dynamic then we need to notify the listeners
                    // for every property it has already
                    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.objForEachKey)(value, function (key) {
                        // Check if the value is dynamic
                        var getter = _getOwnPropGetter(value, key);
                        if (getter) {
                            // And if it is tell it's listeners that the value has changed
                            var valueState = getter[state.prop];
                            valueState && valueState.chng();
                        }
                    });
                }
            }
            if (newValue !== value) {
                var newIsObjectOrArray = newValue && (0,_DynamicSupport__WEBPACK_IMPORTED_MODULE_2__._canMakeDynamic)(_getProperty, state, newValue);
                if (!isReferenced && newIsObjectOrArray) {
                    // As the newValue is an object/array lets preemptively make it dynamic
                    newValue = _makeDynamicObject(state, newValue, name, "Converting");
                }
                // Now assign the internal "value" to the newValue
                value = newValue;
                isObjectOrArray = newIsObjectOrArray;
            }
            // Cause any listeners to be scheduled for notification
            state.add(detail);
        }
    }
    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.objDefine)(theConfig, detail.n, { g: _getProperty, s: _setProperty });
}
function _setDynamicProperty(state, target, name, value) {
    if (target) {
        // To be a dynamic property it needs to have a get function
        var getter = _getOwnPropGetter(target, name);
        var isDynamic = getter && !!getter[state.prop];
        if (!isDynamic) {
            _createDynamicProperty(state, target, name, value);
        }
        else {
            // Looks like it's already dynamic just assign the new value
            target[name] = value;
        }
    }
    return target;
}
function _setDynamicPropertyState(state, target, name, flags) {
    if (target) {
        // To be a dynamic property it needs to have a get function
        var getter = _getOwnPropGetter(target, name);
        var isDynamic = getter && !!getter[state.prop];
        var inPlace = flags && flags[0 /* _eSetDynamicPropertyFlags.inPlace */];
        var rdOnly = flags && flags[1 /* _eSetDynamicPropertyFlags.readOnly */];
        var blkProp = flags && flags[2 /* _eSetDynamicPropertyFlags.blockDynamicProperty */];
        if (!isDynamic) {
            if (blkProp) {
                try {
                    // Attempt to mark the target as blocked from conversion
                    (0,_DynamicSupport__WEBPACK_IMPORTED_MODULE_2__.blockDynamicConversion)(target);
                }
                catch (e) {
                    _throwDynamicError((state.hdlr || {})[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_LOGGER /* @min:%2elogger */], name, "Blocking", e);
                }
            }
            try {
                // Make sure it's dynamic so that we can tag the property as per the state
                _setDynamicProperty(state, target, name, target[name]);
                getter = _getOwnPropGetter(target, name);
            }
            catch (e) {
                // Unable to convert to dynamic property so just leave as non-dynamic
                _throwDynamicError((state.hdlr || {})[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_LOGGER /* @min:%2elogger */], name, "State", e);
            }
        }
        // Assign the optional flags if true
        if (inPlace) {
            getter[state.rf] = inPlace;
        }
        if (rdOnly) {
            getter[state.ro] = rdOnly;
        }
        if (blkProp) {
            getter[state.blkVal] = true;
        }
    }
    return target;
}
function _makeDynamicObject(state, target, name, desc) {
    try {
        // Assign target with new value properties (converting into dynamic properties in the process)
        (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.objForEachKey)(target, function (key, value) {
            // Assign and/or make the property dynamic
            _setDynamicProperty(state, target, key, value);
        });
        if (!target[_DynamicSupport__WEBPACK_IMPORTED_MODULE_2__.CFG_HANDLER_LINK]) {
            // Link the config back to the dynamic config details
            (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.objDefineProp)(target, _DynamicSupport__WEBPACK_IMPORTED_MODULE_2__.CFG_HANDLER_LINK, {
                get: function () {
                    return state[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_HDLR /* @min:%2ehdlr */];
                }
            });
            _patchArray(state, target, name);
        }
    }
    catch (e) {
        // Unable to convert to dynamic property so just leave as non-dynamic
        _throwDynamicError((state.hdlr || {})[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_LOGGER /* @min:%2elogger */], name, desc, e);
    }
    return target;
}
//# sourceMappingURL=DynamicProperty.js.map

/***/ }),
/* 47 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "_applyDefaultValue": () => (/* binding */ _applyDefaultValue)
/* harmony export */ });
/* harmony import */ var _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(30);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(38);
/*
 * Application Insights JavaScript SDK - Core, 3.3.0
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */




function _isConfigDefaults(value) {
    return (value && (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isObject)(value) && (value.isVal || value.fb || (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objHasOwn)(value, "v") || (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objHasOwn)(value, "mrg") || (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objHasOwn)(value, "ref") || value.set));
}
function _getDefault(dynamicHandler, theConfig, cfgDefaults) {
    var defValue;
    var isDefaultValid = cfgDefaults.dfVal || _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isDefined;
    // There is a fallback config key so try and grab that first
    if (theConfig && cfgDefaults.fb) {
        var fallbacks = cfgDefaults.fb;
        if (!(0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isArray)(fallbacks)) {
            fallbacks = [fallbacks];
        }
        for (var lp = 0; lp < fallbacks[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LENGTH /* @min:%2elength */]; lp++) {
            var fallback = fallbacks[lp];
            var fbValue = theConfig[fallback];
            if (isDefaultValid(fbValue)) {
                defValue = fbValue;
            }
            else if (dynamicHandler) {
                // Needed to ensure that the fallback value (and potentially) new field is also dynamic even if null/undefined
                fbValue = dynamicHandler.cfg[fallback];
                if (isDefaultValid(fbValue)) {
                    defValue = fbValue;
                }
                // Needed to ensure that the fallback value (and potentially) new field is also dynamic even if null/undefined
                dynamicHandler.set(dynamicHandler.cfg, (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.asString)(fallback), fbValue);
            }
            if (isDefaultValid(defValue)) {
                // We have a valid default so break out of the look
                break;
            }
        }
    }
    // If the value is still not defined and we have a default value then use that
    if (!isDefaultValid(defValue) && isDefaultValid(cfgDefaults.v)) {
        defValue = cfgDefaults.v;
    }
    return defValue;
}
/**
 * Recursively resolve the default value
 * @param dynamicHandler
 * @param theConfig
 * @param cfgDefaults
 * @returns
 */
function _resolveDefaultValue(dynamicHandler, theConfig, cfgDefaults) {
    var theValue = cfgDefaults;
    if (cfgDefaults && _isConfigDefaults(cfgDefaults)) {
        theValue = _getDefault(dynamicHandler, theConfig, cfgDefaults);
    }
    if (theValue) {
        if (_isConfigDefaults(theValue)) {
            theValue = _resolveDefaultValue(dynamicHandler, theConfig, theValue);
        }
        var newValue_1;
        if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isArray)(theValue)) {
            newValue_1 = [];
            newValue_1[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LENGTH /* @min:%2elength */] = theValue[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LENGTH /* @min:%2elength */];
        }
        else if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(theValue)) {
            newValue_1 = {};
        }
        if (newValue_1) {
            (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objForEachKey)(theValue, function (key, value) {
                if (value && _isConfigDefaults(value)) {
                    value = _resolveDefaultValue(dynamicHandler, theConfig, value);
                }
                newValue_1[key] = value;
            });
            theValue = newValue_1;
        }
    }
    return theValue;
}
/**
 * Applies the default value on the config property and makes sure that it's dynamic
 * @param theConfig
 * @param name
 * @param defaultValue
 */
function _applyDefaultValue(dynamicHandler, theConfig, name, defaultValue) {
    // Resolve the initial config value from the provided value or use the defined default
    var isValid;
    var setFn;
    var defValue;
    var cfgDefaults = defaultValue;
    var mergeDf;
    var reference;
    var readOnly;
    var blkDynamicValue;
    if (_isConfigDefaults(cfgDefaults)) {
        // looks like a IConfigDefault
        isValid = cfgDefaults.isVal;
        setFn = cfgDefaults.set;
        readOnly = cfgDefaults[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_RD_ONLY /* @min:%2erdOnly */];
        blkDynamicValue = cfgDefaults[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_BLK_VAL /* @min:%2eblkVal */];
        mergeDf = cfgDefaults.mrg;
        reference = cfgDefaults.ref;
        if (!reference && (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(reference)) {
            reference = !!mergeDf;
        }
        defValue = _getDefault(dynamicHandler, theConfig, cfgDefaults);
    }
    else {
        defValue = defaultValue;
    }
    if (blkDynamicValue) {
        // Mark the property so that any value assigned will be blocked from conversion, we need to do this
        // before assigning or fetching the value to ensure it's not converted
        dynamicHandler[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_BLK_VAL /* @min:%2eblkVal */](theConfig, name);
    }
    // Set the value to the default value;
    var theValue;
    var usingDefault = true;
    var cfgValue = theConfig[name];
    // try and get and user provided values
    if (cfgValue || !(0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(cfgValue)) {
        // Use the defined theConfig[name] value
        theValue = cfgValue;
        usingDefault = false;
        // The values are different and we have a special default value check, which is used to
        // override config values like empty strings to continue using the default
        if (isValid && theValue !== defValue && !isValid(theValue)) {
            theValue = defValue;
            usingDefault = true;
        }
        if (setFn) {
            theValue = setFn(theValue, defValue, theConfig);
            usingDefault = theValue === defValue;
        }
    }
    if (!usingDefault) {
        if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(theValue) || (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isArray)(defValue)) {
            // we are using the user supplied value and it's an object
            if (mergeDf && defValue && ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(defValue) || (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isArray)(defValue))) {
                // Resolve/apply the defaults
                (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objForEachKey)(defValue, function (dfName, dfValue) {
                    // Sets the value and makes it dynamic (if it doesn't already exist)
                    _applyDefaultValue(dynamicHandler, theValue, dfName, dfValue);
                });
            }
        }
    }
    else if (defValue) {
        // Just resolve the default
        theValue = _resolveDefaultValue(dynamicHandler, theConfig, defValue);
    }
    else {
        theValue = defValue;
    }
    // if (theValue && usingDefault && (isPlainObject(theValue) || isArray(theValue))) {
    //     theValue = _cfgDeepCopy(theValue);
    // }
    // Needed to ensure that the (potentially) new field is dynamic even if null/undefined
    dynamicHandler.set(theConfig, name, theValue);
    if (reference) {
        dynamicHandler.ref(theConfig, name);
    }
    if (readOnly) {
        dynamicHandler[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_RD_ONLY /* @min:%2erdOnly */](theConfig, name);
    }
}
//# sourceMappingURL=ConfigDefaults.js.map

/***/ }),
/* 48 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "_createState": () => (/* binding */ _createState)
/* harmony export */ });
/* harmony import */ var _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(30);
/* harmony import */ var _JavaScriptSDK_AggregationError__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(49);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(38);
/*
 * Application Insights JavaScript SDK - Core, 3.3.0
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */





var symPrefix = "[[ai_";
var symPostfix = "]]";
function _createState(cfgHandler) {
    var _a;
    var dynamicPropertySymbol = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.newSymbol)(symPrefix + "get" + cfgHandler.uid + symPostfix);
    var dynamicPropertyReadOnly = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.newSymbol)(symPrefix + "ro" + cfgHandler.uid + symPostfix);
    var dynamicPropertyReferenced = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.newSymbol)(symPrefix + "rf" + cfgHandler.uid + symPostfix);
    var dynamicPropertyBlockValue = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.newSymbol)(symPrefix + "blkVal" + cfgHandler.uid + symPostfix);
    var dynamicPropertyDetail = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.newSymbol)(symPrefix + "dtl" + cfgHandler.uid + symPostfix);
    var _waitingHandlers = null;
    var _watcherTimer = null;
    var theState;
    function _useHandler(activeHandler, callback) {
        var prevWatcher = theState.act;
        try {
            theState.act = activeHandler;
            if (activeHandler && activeHandler[dynamicPropertyDetail]) {
                // Clear out the previously tracked details for this handler, so that access are re-evaluated
                (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrForEach)(activeHandler[dynamicPropertyDetail], function (detail) {
                    detail.clr(activeHandler);
                });
                activeHandler[dynamicPropertyDetail] = [];
            }
            callback({
                cfg: cfgHandler.cfg,
                set: cfgHandler.set.bind(cfgHandler),
                setDf: cfgHandler[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_SET_DF /* @min:%2esetDf */].bind(cfgHandler),
                ref: cfgHandler.ref.bind(cfgHandler),
                rdOnly: cfgHandler[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_RD_ONLY /* @min:%2erdOnly */].bind(cfgHandler)
            });
        }
        catch (e) {
            var logger = cfgHandler[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LOGGER /* @min:%2elogger */];
            if (logger) {
                // Don't let one individual failure break everyone
                logger[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_THROW_INTERNAL /* @min:%2ethrowInternal */](1 /* eLoggingSeverity.CRITICAL */, 107 /* _eInternalMessageId.ConfigWatcherException */, (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.dumpObj)(e));
            }
            // Re-throw the exception so that any true "error" is reported back to the called
            throw e;
        }
        finally {
            theState.act = prevWatcher || null;
        }
    }
    function _notifyWatchers() {
        if (_waitingHandlers) {
            var notifyHandlers = _waitingHandlers;
            _waitingHandlers = null;
            // Stop any timer as we are running them now anyway
            _watcherTimer && _watcherTimer[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_CANCEL /* @min:%2ecancel */]();
            _watcherTimer = null;
            var watcherFailures_1 = [];
            // Now run the handlers
            (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrForEach)(notifyHandlers, function (handler) {
                if (handler) {
                    if (handler[dynamicPropertyDetail]) {
                        (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrForEach)(handler[dynamicPropertyDetail], function (detail) {
                            // Clear out this handler from  previously tracked details, so that access are re-evaluated
                            detail.clr(handler);
                        });
                        handler[dynamicPropertyDetail] = null;
                    }
                    // The handler may have self removed as part of another handler so re-check
                    if (handler.fn) {
                        try {
                            _useHandler(handler, handler.fn);
                        }
                        catch (e) {
                            // Don't let a single failing watcher cause other watches to fail
                            watcherFailures_1[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_PUSH /* @min:%2epush */](e);
                        }
                    }
                }
            });
            // During notification we may have had additional updates -- so notify those updates as well
            if (_waitingHandlers) {
                try {
                    _notifyWatchers();
                }
                catch (e) {
                    watcherFailures_1[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_PUSH /* @min:%2epush */](e);
                }
            }
            if (watcherFailures_1[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LENGTH /* @min:%2elength */] > 0) {
                (0,_JavaScriptSDK_AggregationError__WEBPACK_IMPORTED_MODULE_2__.throwAggregationError)("Watcher error(s): ", watcherFailures_1);
            }
        }
    }
    function _addWatcher(detail) {
        if (detail && detail.h[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LENGTH /* @min:%2elength */] > 0) {
            if (!_waitingHandlers) {
                _waitingHandlers = [];
            }
            if (!_watcherTimer) {
                _watcherTimer = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.scheduleTimeout)(function () {
                    _watcherTimer = null;
                    _notifyWatchers();
                }, 0);
            }
            // Add all of the handlers for this detail (if not already present) - using normal for-loop for performance
            for (var idx = 0; idx < detail.h[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LENGTH /* @min:%2elength */]; idx++) {
                var handler = detail.h[idx];
                // Add this handler to the collection of handlers to re-execute
                if (handler && (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrIndexOf)(_waitingHandlers, handler) === -1) {
                    _waitingHandlers[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_PUSH /* @min:%2epush */](handler);
                }
            }
        }
    }
    function _trackHandler(handler, detail) {
        if (handler) {
            var details = handler[dynamicPropertyDetail] = handler[dynamicPropertyDetail] || [];
            if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrIndexOf)(details, detail) === -1) {
                // If this detail is not already listed as tracked then add it so that we re-evaluate it's usage
                details[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_PUSH /* @min:%2epush */](detail);
            }
        }
    }
    theState = (_a = {
            prop: dynamicPropertySymbol,
            ro: dynamicPropertyReadOnly,
            rf: dynamicPropertyReferenced
        },
        _a[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_BLK_VAL /* @min:blkVal */] = dynamicPropertyBlockValue,
        _a[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_HDLR /* @min:hdlr */] = cfgHandler,
        _a.add = _addWatcher,
        _a[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_NOTIFY /* @min:notify */] = _notifyWatchers,
        _a.use = _useHandler,
        _a.trk = _trackHandler,
        _a);
    return theState;
}
//# sourceMappingURL=DynamicState.js.map

/***/ }),
/* 49 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "throwAggregationError": () => (/* binding */ throwAggregationError)
/* harmony export */ });
/* harmony import */ var _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(30);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(38);
/*
 * Application Insights JavaScript SDK - Core, 3.3.0
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */




var aggregationErrorType;
/**
 * Throws an Aggregation Error which includes all of the errors that led to this error occurring
 * @param message - The message describing the aggregation error (the sourceError details are added to this)
 * @param sourceErrors - An array of the errors that caused this situation
 */
function throwAggregationError(message, sourceErrors) {
    if (!aggregationErrorType) {
        aggregationErrorType = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.createCustomError)("AggregationError", function (self, args) {
            if (args[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LENGTH /* @min:%2elength */] > 1) {
                // Save the provided errors
                self.errors = args[1];
            }
        });
    }
    var theMessage = message || "One or more errors occurred.";
    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrForEach)(sourceErrors, function (srcError, idx) {
        theMessage += "\n".concat(idx, " > ").concat((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.dumpObj)(srcError));
    });
    throw new aggregationErrorType(theMessage, sourceErrors || []);
}
//# sourceMappingURL=AggregationError.js.map

/***/ }),
/* 50 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DiagnosticLogger": () => (/* binding */ DiagnosticLogger),
/* harmony export */   "_InternalLogMessage": () => (/* binding */ _InternalLogMessage),
/* harmony export */   "_logInternalMessage": () => (/* binding */ _logInternalMessage),
/* harmony export */   "_throwInternal": () => (/* binding */ _throwInternal),
/* harmony export */   "_warnToConsole": () => (/* binding */ _warnToConsole),
/* harmony export */   "safeGetLogger": () => (/* binding */ safeGetLogger)
/* harmony export */ });
/* harmony import */ var _microsoft_dynamicproto_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(35);
/* harmony import */ var _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(30);
/* harmony import */ var _Config_DynamicConfig__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(40);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38);
/* harmony import */ var _DbgExtensionUtils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(51);
/* harmony import */ var _EnvUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(44);
/* harmony import */ var _InternalConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(39);
/*
 * Application Insights JavaScript SDK - Core, 3.3.0
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */



var _a;







var STR_WARN_TO_CONSOLE = "warnToConsole";
/**
 * For user non actionable traces use AI Internal prefix.
 */
var AiNonUserActionablePrefix = "AI (Internal): ";
/**
 * Prefix of the traces in portal.
 */
var AiUserActionablePrefix = "AI: ";
/**
 *  Session storage key for the prefix for the key indicating message type already logged
 */
var AIInternalMessagePrefix = "AITR_";
var defaultValues = {
    loggingLevelConsole: 0,
    loggingLevelTelemetry: 1,
    maxMessageLimit: 25,
    enableDebug: false
};
var _logFuncs = (_a = {},
    _a[0 /* eLoggingSeverity.DISABLED */] = null,
    _a[1 /* eLoggingSeverity.CRITICAL */] = "errorToConsole",
    _a[2 /* eLoggingSeverity.WARNING */] = STR_WARN_TO_CONSOLE,
    _a[3 /* eLoggingSeverity.DEBUG */] = "debugToConsole",
    _a);
function _sanitizeDiagnosticText(text) {
    if (text) {
        return "\"" + text[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_REPLACE /* @min:%2ereplace */](/\"/g, _InternalConstants__WEBPACK_IMPORTED_MODULE_1__.STR_EMPTY) + "\"";
    }
    return _InternalConstants__WEBPACK_IMPORTED_MODULE_1__.STR_EMPTY;
}
function _logToConsole(func, message) {
    var theConsole = (0,_EnvUtils__WEBPACK_IMPORTED_MODULE_2__.getConsole)();
    if (!!theConsole) {
        var logFunc = "log";
        if (theConsole[func]) {
            logFunc = func;
        }
        if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.isFunction)(theConsole[logFunc])) {
            theConsole[logFunc](message);
        }
    }
}
var _InternalLogMessage = /** @class */ (function () {
    function _InternalLogMessage(msgId, msg, isUserAct, properties) {
        if (isUserAct === void 0) { isUserAct = false; }
        var _self = this;
        _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_MESSAGE_ID /* @min:%2emessageId */] = msgId;
        _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_MESSAGE /* @min:%2emessage */] =
            (isUserAct ? AiUserActionablePrefix : AiNonUserActionablePrefix) +
                msgId;
        var strProps = _InternalConstants__WEBPACK_IMPORTED_MODULE_1__.STR_EMPTY;
        if ((0,_EnvUtils__WEBPACK_IMPORTED_MODULE_2__.hasJSON)()) {
            strProps = (0,_EnvUtils__WEBPACK_IMPORTED_MODULE_2__.getJSON)().stringify(properties);
        }
        var diagnosticText = (msg ? " message:" + _sanitizeDiagnosticText(msg) : _InternalConstants__WEBPACK_IMPORTED_MODULE_1__.STR_EMPTY) +
            (properties ? " props:" + _sanitizeDiagnosticText(strProps) : _InternalConstants__WEBPACK_IMPORTED_MODULE_1__.STR_EMPTY);
        _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_MESSAGE /* @min:%2emessage */] += diagnosticText;
    }
    _InternalLogMessage.dataType = "MessageData";
    return _InternalLogMessage;
}());

function safeGetLogger(core, config) {
    return (core || {})[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_LOGGER /* @min:%2elogger */] || new DiagnosticLogger(config);
}
var DiagnosticLogger = /** @class */ (function () {
    function DiagnosticLogger(config) {
        this.identifier = "DiagnosticLogger";
        /**
         * The internal logging queue
         */
        this.queue = [];
        /**
         * Count of internal messages sent
         */
        var _messageCount = 0;
        /**
         * Holds information about what message types were already logged to console or sent to server.
         */
        var _messageLogged = {};
        var _loggingLevelConsole;
        var _loggingLevelTelemetry;
        var _maxInternalMessageLimit;
        var _enableDebug;
        var _unloadHandler;
        (0,_microsoft_dynamicproto_js__WEBPACK_IMPORTED_MODULE_4__["default"])(DiagnosticLogger, this, function (_self) {
            _unloadHandler = _setDefaultsFromConfig(config || {});
            _self.consoleLoggingLevel = function () { return _loggingLevelConsole; };
            /**
             * This method will throw exceptions in debug mode or attempt to log the error as a console warning.
             * @param severity - {LoggingSeverity} - The severity of the log message
             * @param message - {_InternalLogMessage} - The log message.
             */
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_THROW_INTERNAL /* @min:%2ethrowInternal */] = function (severity, msgId, msg, properties, isUserAct) {
                if (isUserAct === void 0) { isUserAct = false; }
                var message = new _InternalLogMessage(msgId, msg, isUserAct, properties);
                if (_enableDebug) {
                    throw (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.dumpObj)(message);
                }
                else {
                    // Get the logging function and fallback to warnToConsole of for some reason errorToConsole doesn't exist
                    var logFunc = _logFuncs[severity] || STR_WARN_TO_CONSOLE;
                    if (!(0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.isUndefined)(message[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_MESSAGE /* @min:%2emessage */])) {
                        if (isUserAct) {
                            // check if this message type was already logged to console for this page view and if so, don't log it again
                            var messageKey = +message[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_MESSAGE_ID /* @min:%2emessageId */];
                            if (!_messageLogged[messageKey] && _loggingLevelConsole >= severity) {
                                _self[logFunc](message[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_MESSAGE /* @min:%2emessage */]);
                                _messageLogged[messageKey] = true;
                            }
                        }
                        else {
                            // Only log traces if the console Logging Level is >= the throwInternal severity level
                            if (_loggingLevelConsole >= severity) {
                                _self[logFunc](message[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_MESSAGE /* @min:%2emessage */]);
                            }
                        }
                        _logInternalMessage(severity, message);
                    }
                    else {
                        _debugExtMsg("throw" + (severity === 1 /* eLoggingSeverity.CRITICAL */ ? "Critical" : "Warning"), message);
                    }
                }
            };
            _self.debugToConsole = function (message) {
                _logToConsole("debug", message);
                _debugExtMsg("warning", message);
            };
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_WARN_TO_CONSOLE /* @min:%2ewarnToConsole */] = function (message) {
                _logToConsole("warn", message);
                _debugExtMsg("warning", message);
            };
            _self.errorToConsole = function (message) {
                _logToConsole("error", message);
                _debugExtMsg("error", message);
            };
            _self.resetInternalMessageCount = function () {
                _messageCount = 0;
                _messageLogged = {};
            };
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_LOG_INTERNAL_MESSAGE /* @min:%2elogInternalMessage */] = _logInternalMessage;
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_UNLOAD /* @min:%2eunload */] = function (isAsync) {
                _unloadHandler && _unloadHandler.rm();
                _unloadHandler = null;
            };
            function _logInternalMessage(severity, message) {
                if (_areInternalMessagesThrottled()) {
                    return;
                }
                // check if this message type was already logged for this session and if so, don't log it again
                var logMessage = true;
                var messageKey = AIInternalMessagePrefix + message[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_MESSAGE_ID /* @min:%2emessageId */];
                // if the session storage is not available, limit to only one message type per page view
                if (_messageLogged[messageKey]) {
                    logMessage = false;
                }
                else {
                    _messageLogged[messageKey] = true;
                }
                if (logMessage) {
                    // Push the event in the internal queue
                    if (severity <= _loggingLevelTelemetry) {
                        _self.queue[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_PUSH /* @min:%2epush */](message);
                        _messageCount++;
                        _debugExtMsg((severity === 1 /* eLoggingSeverity.CRITICAL */ ? "error" : "warn"), message);
                    }
                    // When throttle limit reached, send a special event
                    if (_messageCount === _maxInternalMessageLimit) {
                        var throttleLimitMessage = "Internal events throttle limit per PageView reached for this app.";
                        var throttleMessage = new _InternalLogMessage(23 /* _eInternalMessageId.MessageLimitPerPVExceeded */, throttleLimitMessage, false);
                        _self.queue[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_PUSH /* @min:%2epush */](throttleMessage);
                        if (severity === 1 /* eLoggingSeverity.CRITICAL */) {
                            _self.errorToConsole(throttleLimitMessage);
                        }
                        else {
                            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_WARN_TO_CONSOLE /* @min:%2ewarnToConsole */](throttleLimitMessage);
                        }
                    }
                }
            }
            function _setDefaultsFromConfig(config) {
                // make sure the config is dynamic
                return (0,_Config_DynamicConfig__WEBPACK_IMPORTED_MODULE_5__.onConfigChange)((0,_Config_DynamicConfig__WEBPACK_IMPORTED_MODULE_5__.createDynamicConfig)(config, defaultValues, _self).cfg, function (details) {
                    var config = details.cfg;
                    _loggingLevelConsole = config[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_LOGGING_LEVEL_CONSOL4 /* @min:%2eloggingLevelConsole */];
                    _loggingLevelTelemetry = config.loggingLevelTelemetry;
                    _maxInternalMessageLimit = config.maxMessageLimit;
                    _enableDebug = config.enableDebug;
                });
            }
            function _areInternalMessagesThrottled() {
                return _messageCount >= _maxInternalMessageLimit;
            }
            function _debugExtMsg(name, data) {
                var dbgExt = (0,_DbgExtensionUtils__WEBPACK_IMPORTED_MODULE_6__.getDebugExt)(config || {});
                if (dbgExt && dbgExt[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_DIAG_LOG /* @min:%2ediagLog */]) {
                    dbgExt[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_DIAG_LOG /* @min:%2ediagLog */](name, data);
                }
            }
        });
    }
// Removed Stub for DiagnosticLogger.prototype.consoleLoggingLevel.
// Removed Stub for DiagnosticLogger.prototype.throwInternal.
// Removed Stub for DiagnosticLogger.prototype.debugToConsole.
// Removed Stub for DiagnosticLogger.prototype.warnToConsole.
// Removed Stub for DiagnosticLogger.prototype.errorToConsole.
// Removed Stub for DiagnosticLogger.prototype.resetInternalMessageCount.
// Removed Stub for DiagnosticLogger.prototype.logInternalMessage.
// Removed Stub for DiagnosticLogger.prototype.unload.
    // This is a workaround for an IE bug when using dynamicProto() with classes that don't have any
    // non-dynamic functions or static properties/functions when using uglify-js to minify the resulting code.
    DiagnosticLogger.__ieDyn=1;

    return DiagnosticLogger;
}());

function _getLogger(logger) {
    return (logger || new DiagnosticLogger());
}
/**
 * This is a helper method which will call throwInternal on the passed logger, will throw exceptions in
 * debug mode or attempt to log the error as a console warning. This helper is provided mostly to better
 * support minification as logger.throwInternal() will not compress the publish "throwInternal" used throughout
 * the code.
 * @param logger - The Diagnostic Logger instance to use.
 * @param severity - {LoggingSeverity} - The severity of the log message
 * @param message - {_InternalLogMessage} - The log message.
 */
function _throwInternal(logger, severity, msgId, msg, properties, isUserAct) {
    if (isUserAct === void 0) { isUserAct = false; }
    _getLogger(logger)[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_THROW_INTERNAL /* @min:%2ethrowInternal */](severity, msgId, msg, properties, isUserAct);
}
/**
 * This is a helper method which will call warnToConsole on the passed logger with the provided message.
 * @param logger - The Diagnostic Logger instance to use.
 * @param message - {_InternalLogMessage} - The log message.
 */
function _warnToConsole(logger, message) {
    _getLogger(logger)[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_WARN_TO_CONSOLE /* @min:%2ewarnToConsole */](message);
}
/**
 * Logs a message to the internal queue.
 * @param logger - The Diagnostic Logger instance to use.
 * @param severity - {LoggingSeverity} - The severity of the log message
 * @param message - {_InternalLogMessage} - The message to log.
 */
function _logInternalMessage(logger, severity, message) {
    _getLogger(logger)[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_LOG_INTERNAL_MESSAGE /* @min:%2elogInternalMessage */](severity, message);
}
//# sourceMappingURL=DiagnosticLogger.js.map

/***/ }),
/* 51 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getDebugExt": () => (/* binding */ getDebugExt),
/* harmony export */   "getDebugListener": () => (/* binding */ getDebugListener)
/* harmony export */ });
/* harmony import */ var _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(30);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(38);
/* harmony import */ var _InternalConstants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(39);
/*
 * Application Insights JavaScript SDK - Core, 3.3.0
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */





var listenerFuncs = [_InternalConstants__WEBPACK_IMPORTED_MODULE_0__.STR_EVENTS_SENT, _InternalConstants__WEBPACK_IMPORTED_MODULE_0__.STR_EVENTS_DISCARDED, _InternalConstants__WEBPACK_IMPORTED_MODULE_0__.STR_EVENTS_SEND_REQUEST, _InternalConstants__WEBPACK_IMPORTED_MODULE_0__.STR_PERF_EVENT];
var _aiNamespace = null;
var _debugListener;
function _listenerProxyFunc(name, config) {
    return function () {
        var args = arguments;
        var dbgExt = getDebugExt(config);
        if (dbgExt) {
            var listener = dbgExt.listener;
            if (listener && listener[name]) {
                listener[name][_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_APPLY /* @min:%2eapply */](listener, args);
            }
        }
    };
}
function _getExtensionNamespace() {
    // Cache the lookup of the global namespace object
    var target = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_2__.getInst)("Microsoft");
    if (target) {
        _aiNamespace = target["ApplicationInsights"];
    }
    return _aiNamespace;
}
function getDebugExt(config) {
    var ns = _aiNamespace;
    if (!ns && config.disableDbgExt !== true) {
        ns = _aiNamespace || _getExtensionNamespace();
    }
    return ns ? ns["ChromeDbgExt"] : null;
}
function getDebugListener(config) {
    if (!_debugListener) {
        _debugListener = {};
        for (var lp = 0; lp < listenerFuncs[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LENGTH /* @min:%2elength */]; lp++) {
            _debugListener[listenerFuncs[lp]] = _listenerProxyFunc(listenerFuncs[lp], config);
        }
    }
    return _debugListener;
}
//# sourceMappingURL=DbgExtensionUtils.js.map

/***/ }),
/* 52 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FullVersionString": () => (/* binding */ FullVersionString),
/* harmony export */   "Version": () => (/* binding */ Version),
/* harmony export */   "createGuid": () => (/* binding */ createGuid),
/* harmony export */   "extend": () => (/* binding */ extend),
/* harmony export */   "getCommonSchemaMetaData": () => (/* binding */ getCommonSchemaMetaData),
/* harmony export */   "getCookieValue": () => (/* binding */ getCookieValue),
/* harmony export */   "getFieldValueType": () => (/* binding */ getFieldValueType),
/* harmony export */   "getTenantId": () => (/* binding */ getTenantId),
/* harmony export */   "getTime": () => (/* binding */ getTime),
/* harmony export */   "isArrayValid": () => (/* binding */ isArrayValid),
/* harmony export */   "isChromium": () => (/* binding */ isChromium),
/* harmony export */   "isDocumentObjectAvailable": () => (/* binding */ isDocumentObjectAvailable),
/* harmony export */   "isGreaterThanZero": () => (/* binding */ isGreaterThanZero),
/* harmony export */   "isLatency": () => (/* binding */ isLatency),
/* harmony export */   "isUint8ArrayAvailable": () => (/* binding */ isUint8ArrayAvailable),
/* harmony export */   "isValueAssigned": () => (/* binding */ isValueAssigned),
/* harmony export */   "isValueKind": () => (/* binding */ isValueKind),
/* harmony export */   "isWindowObjectAvailable": () => (/* binding */ isWindowObjectAvailable),
/* harmony export */   "openXhr": () => (/* binding */ openXhr),
/* harmony export */   "sanitizeProperty": () => (/* binding */ sanitizeProperty),
/* harmony export */   "setProcessTelemetryTimings": () => (/* binding */ setProcessTelemetryTimings)
/* harmony export */ });
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(30);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(44);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(53);
/* harmony import */ var _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(34);
/* harmony import */ var _InternalConstants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(32);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(36);
/*
 * 1DS JS SDK Core, 4.3.0
 * Copyright (c) Microsoft and contributors. All rights reserved.
 * (Microsoft Internal Only)
 */
var _a;
/**
* Utils.ts
* @author  Abhilash Panwar (abpanwar) Hector Hernandez (hectorh)
* @copyright Microsoft 2018
* File containing utility functions.
*/





var Version = '4.3.0';
var FullVersionString = "1DS-Web-JS-" + Version;
var ObjHasOwnProperty = _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_0__.ObjProto.hasOwnProperty;
// Defining here so we don't need to take (import) the ApplicationInsights Common module
var strDisabledPropertyName = "Microsoft_ApplicationInsights_BypassAjaxInstrumentation";
var strWithCredentials = "withCredentials";
var strTimeout = "timeout";
// If value is array just get the type for the first element
var _fieldTypeEventPropMap = (_a = {},
    _a[0 /* FieldValueSanitizerType.NotSet */] = 0 /* eEventPropertyType.Unspecified */,
    _a[2 /* FieldValueSanitizerType.Number */] = 6 /* eEventPropertyType.Double */,
    _a[1 /* FieldValueSanitizerType.String */] = 1 /* eEventPropertyType.String */,
    _a[3 /* FieldValueSanitizerType.Boolean */] = 7 /* eEventPropertyType.Bool */,
    _a[4096 /* FieldValueSanitizerType.Array */ | 2 /* FieldValueSanitizerType.Number */] = 6 /* eEventPropertyType.Double */,
    _a[4096 /* FieldValueSanitizerType.Array */ | 1 /* FieldValueSanitizerType.String */] = 1 /* eEventPropertyType.String */,
    _a[4096 /* FieldValueSanitizerType.Array */ | 3 /* FieldValueSanitizerType.Boolean */] = 7 /* eEventPropertyType.Bool */,
    _a);
/**
 * @ignore
 */
// let _uaDisallowsSameSiteNone = null;
var uInt8ArraySupported = null;
// var _areCookiesAvailable: boolean | undefined;
/**
 * Checks if document object is available
 */
var isDocumentObjectAvailable = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.hasDocument)();
/**
 * Checks if window object is available
 */
var isWindowObjectAvailable = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.hasWindow)();
/**
 * Checks if value is assigned to the given param.
 * @param value - The token from which the tenant id is to be extracted.
 * @returns True/false denoting if value is assigned to the param.
 */
function isValueAssigned(value) {
    /// <summary> takes a value and checks for undefined, null and empty string </summary>
    /// <param type="any"> value to be tested </param>
    /// <returns> true if value is null undefined or emptyString </returns>
    return !(value === _InternalConstants__WEBPACK_IMPORTED_MODULE_2__.STR_EMPTY || (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(value));
}
/**
 * Gets the tenant id from the tenant token.
 * @param apiKey - The token from which the tenant id is to be extracted.
 * @returns The tenant id.
 */
function getTenantId(apiKey) {
    if (apiKey) {
        var indexTenantId = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.strIndexOf)(apiKey, "-");
        if (indexTenantId > -1) {
            return (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.strLeft)(apiKey, indexTenantId);
        }
    }
    return _InternalConstants__WEBPACK_IMPORTED_MODULE_2__.STR_EMPTY;
}
/**
 * Checks if Uint8Array are available in the current environment. Safari and Firefox along with
 * ReactNative are known to not support Uint8Array properly.
 * @returns True if available, false otherwise.
 */
function isUint8ArrayAvailable() {
    if (uInt8ArraySupported === null) {
        uInt8ArraySupported = !(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.isUndefined)(Uint8Array) && !isSafariOrFirefox() && !(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_3__.isReactNative)();
    }
    return uInt8ArraySupported;
}
/**
 * Checks if the value is a valid EventLatency.
 * @param value - The value that needs to be checked.
 * @returns True if the value is in AWTEventLatency, false otherwise.
 */
function isLatency(value) {
    if (value && (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.isNumber)(value) && value >= 1 /* EventLatencyValue.Normal */ && value <= 4 /* EventLatencyValue.Immediate */) {
        return true;
    }
    return false;
}
/**
 * Sanitizes the Property. It checks the that the property name and value are valid. It also
 * checks/populates the correct type and pii of the property value.
 * @param name - property name                          - The property name.
 * @param property - The property value or an IEventProperty containing value,
 * type ,pii and customer content.
 * @returns IEventProperty containing valid name, value, pii and type or null if invalid.
 */
function sanitizeProperty(name, property, stringifyObjects) {
    // Check that property is valid
    if ((!property && !isValueAssigned(property)) || typeof name !== "string") {
        return null;
    }
    // Perf optimization -- only need to get the type once not multiple times
    var propType = typeof property;
    // If the property isn't IEventProperty (and is either string, number, boolean or array), convert it into one.
    if (propType === "string" || propType === "number" || propType === "boolean" || (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.isArray)(property)) {
        property = { value: property };
    }
    else if (propType === "object" && !ObjHasOwnProperty.call(property, "value")) {
        property = { value: stringifyObjects ? JSON.stringify(property) : property };
    }
    else if ((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(property[_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__._DYN_VALUE /* @min:%2evalue */])
        || property[_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__._DYN_VALUE /* @min:%2evalue */] === _InternalConstants__WEBPACK_IMPORTED_MODULE_2__.STR_EMPTY || (!(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.isString)(property[_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__._DYN_VALUE /* @min:%2evalue */])
        && !(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.isNumber)(property[_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__._DYN_VALUE /* @min:%2evalue */]) && !(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.isBoolean)(property[_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__._DYN_VALUE /* @min:%2evalue */])
        && !(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.isArray)(property[_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__._DYN_VALUE /* @min:%2evalue */]))) {
        // Since property is IEventProperty, we need to validate its value
        return null;
    }
    // We need to check that if the property value is an array, it is valid
    if ((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.isArray)(property[_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__._DYN_VALUE /* @min:%2evalue */]) &&
        !isArrayValid(property[_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__._DYN_VALUE /* @min:%2evalue */])) {
        return null;
    }
    // If either pii or cc is set convert value to string (since only string pii/cc is allowed).
    // If the value is a complex type like an array that can't be converted to string we will drop
    // the property.
    if (!(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(property[_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__._DYN_KIND /* @min:%2ekind */])) {
        if ((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.isArray)(property[_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__._DYN_VALUE /* @min:%2evalue */]) || !isValueKind(property[_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__._DYN_KIND /* @min:%2ekind */])) {
            return null;
        }
        property[_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__._DYN_VALUE /* @min:%2evalue */] = property[_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__._DYN_VALUE /* @min:%2evalue */].toString();
    }
    return property;
}
function getCommonSchemaMetaData(value, kind, type) {
    var encodedTypeValue = -1;
    if (!(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.isUndefined)(value)) {
        if (kind > 0) {
            if (kind === 32 /* eValueKind.CustomerContent_GenericContent */) {
                // encode customer content. Value can only be string. bit 13-16 are for cc
                encodedTypeValue = (1 << 13);
            }
            else if (kind <= 13) {
                // encode PII. Value can only be string. bits 5-12 are for Pii
                encodedTypeValue = (kind << 5);
            }
        }
        // isDataType checks that the "type" is a number so we don't need to check for undefined
        if (isDataType(type)) {
            // Data Type is provided and valid, so use that
            if (encodedTypeValue === -1) {
                // Don't return -1
                encodedTypeValue = 0;
            }
            encodedTypeValue |= type;
        }
        else {
            var propType = _fieldTypeEventPropMap[getFieldValueType(value)] || -1;
            if (encodedTypeValue !== -1 && propType !== -1) {
                // pii exists so we must return correct type
                encodedTypeValue |= propType;
            }
            else if (propType === 6 /* eEventPropertyType.Double */) {
                encodedTypeValue = propType;
            }
        }
    }
    return encodedTypeValue;
}
/**
 * Helper to get and decode the cookie value using decodeURIComponent, this is for historical
 * backward compatibility where the document.cookie value was decoded before parsing.
 * @param cookieMgr - The cookie manager to use
 * @param name - The name of the cookie to get
 * @param decode - A flag to indicate whether the cookie value should be decoded
 * @returns The decoded cookie value (if available) otherwise an empty string.
 */
function getCookieValue(cookieMgr, name, decode) {
    if (decode === void 0) { decode = true; }
    var cookieValue;
    if (cookieMgr) {
        cookieValue = cookieMgr.get(name);
        if (decode && cookieValue && decodeURIComponent) {
            cookieValue = decodeURIComponent(cookieValue);
        }
    }
    return cookieValue || _InternalConstants__WEBPACK_IMPORTED_MODULE_2__.STR_EMPTY;
}
/**
 * Create a new guid.
 * @param style - The style of guid to generated, defaults to Digits
 * Digits (Default) : 32 digits separated by hyphens: 00000000-0000-0000-0000-000000000000
 * Braces - 32 digits separated by hyphens, enclosed in braces: {00000000-0000-0000-0000-000000000000}
 * Parentheses - 32 digits separated by hyphens, enclosed in parentheses: (00000000-0000-0000-0000-000000000000)
 * Numeric - 32 digits: 00000000000000000000000000000000
 * @returns The formatted guid.
 */
function createGuid(style) {
    if (style === void 0) { style = "D" /* GuidStyle.Digits */; }
    var theGuid = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_5__.newGuid)();
    if (style === "B" /* GuidStyle.Braces */) {
        theGuid = "{" + theGuid + "}";
    }
    else if (style === "P" /* GuidStyle.Parentheses */) {
        theGuid = "(" + theGuid + ")";
    }
    else if (style === "N" /* GuidStyle.Numeric */) {
        theGuid = theGuid.replace(/-/g, _InternalConstants__WEBPACK_IMPORTED_MODULE_2__.STR_EMPTY);
    }
    return theGuid;
}
/**
 * Pass in the objects to merge as arguments.
 * @param obj1 - object to merge.  Set this argument to 'true' for a deep extend.
 * @param obj2 - object to merge.
 * @param obj3 - object to merge.
 * @param obj4 - object to merge.
 * @param obj5 - object to merge.
 * @returns The extended object.
 */
function extend(obj, obj2, obj3, obj4, obj5) {
    // Variables
    var extended = {};
    var deep = false;
    var i = 0;
    var length = arguments[_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__._DYN_LENGTH /* @min:%2elength */];
    var theArgs = arguments;
    // Check if a deep merge
    if ((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.isBoolean)(theArgs[0])) {
        deep = theArgs[0];
        i++;
    }
    // Loop through each object and conduct a merge
    for (; i < length; i++) {
        var obj = theArgs[i];
        (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.objForEachKey)(obj, function (prop, value) {
            // If deep merge and property is an object, merge properties
            if (deep && value && (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.isObject)(value)) {
                if ((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.isArray)(value)) {
                    extended[prop] = extended[prop] || [];
                    (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.arrForEach)(value, function (arrayValue, arrayIndex) {
                        if (arrayValue && (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.isObject)(arrayValue)) {
                            extended[prop][arrayIndex] = extend(true, extended[prop][arrayIndex], arrayValue);
                        }
                        else {
                            extended[prop][arrayIndex] = arrayValue;
                        }
                    });
                }
                else {
                    extended[prop] = extend(true, extended[prop], value);
                }
            }
            else {
                extended[prop] = value;
            }
        });
    }
    return extended;
}
var getTime = _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.perfNow;
function isValueKind(value) {
    // Always assume that it's a number (no type checking) for performance as this is used during the JSON serialization
    if (value === 0 /* eValueKind.NotSet */ || ((value > 0 /* eValueKind.NotSet */ && value <= 13 /* eValueKind.Pii_IPV4AddressLegacy */) || value === 32 /* eValueKind.CustomerContent_GenericContent */)) {
        return true;
    }
    return false;
}
function isDataType(value) {
    // Remark: 0 returns false, but it doesn't affect encoding anyways
    // Always assume that it's a number (no type checking) for performance as this is used during the JSON serialization
    if (value >= 0 && value <= 9) {
        return true;
    }
    return false;
}
function isSafariOrFirefox() {
    var nav = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.getNavigator)();
    // If non-browser navigator will be undefined
    if (!(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.isUndefined)(nav) && nav.userAgent) {
        var ua = nav.userAgent.toLowerCase();
        if ((ua[_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__._DYN_INDEX_OF /* @min:%2eindexOf */]("safari") >= 0 || ua[_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__._DYN_INDEX_OF /* @min:%2eindexOf */]("firefox") >= 0) && ua[_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__._DYN_INDEX_OF /* @min:%2eindexOf */]("chrome") < 0) {
            return true;
        }
    }
    return false;
}
function isArrayValid(value) {
    return value[_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__._DYN_LENGTH /* @min:%2elength */] > 0;
}
function setProcessTelemetryTimings(event, identifier) {
    var evt = event;
    evt[_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__._DYN_TIMINGS /* @min:%2etimings */] = evt[_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__._DYN_TIMINGS /* @min:%2etimings */] || {};
    evt[_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__._DYN_TIMINGS /* @min:%2etimings */][_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__._DYN_PROCESS_TELEMETRY_ST0 /* @min:%2eprocessTelemetryStart */] = evt[_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__._DYN_TIMINGS /* @min:%2etimings */][_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__._DYN_PROCESS_TELEMETRY_ST0 /* @min:%2eprocessTelemetryStart */] || {};
    evt[_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__._DYN_TIMINGS /* @min:%2etimings */][_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__._DYN_PROCESS_TELEMETRY_ST0 /* @min:%2eprocessTelemetryStart */][identifier] = getTime();
}
/**
 * Returns a bitwise value for the FieldValueSanitizerType enum representing the decoded type of the passed value
 * @param value The value to determine the type
 */
function getFieldValueType(value) {
    var theType = 0 /* FieldValueSanitizerType.NotSet */;
    if (value !== null && value !== undefined) {
        var objType = typeof value;
        if (objType === "string") {
            theType = 1 /* FieldValueSanitizerType.String */;
        }
        else if (objType === "number") {
            theType = 2 /* FieldValueSanitizerType.Number */;
        }
        else if (objType === "boolean") {
            theType = 3 /* FieldValueSanitizerType.Boolean */;
        }
        else if (objType === _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_0__.strShimObject) {
            theType = 4 /* FieldValueSanitizerType.Object */;
            if ((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.isArray)(value)) {
                theType = 4096 /* FieldValueSanitizerType.Array */;
                if (value[_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__._DYN_LENGTH /* @min:%2elength */] > 0) {
                    // Empty arrays are not supported and are considered to be the same as null
                    theType |= getFieldValueType(value[0]);
                }
            }
            else if (ObjHasOwnProperty.call(value, "value")) {
                // Looks like an IEventProperty
                theType = 8192 /* FieldValueSanitizerType.EventProperty */ | getFieldValueType(value[_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__._DYN_VALUE /* @min:%2evalue */]);
            }
        }
    }
    return theType;
}
/**
 * Helper to identify whether we are running in a chromium based browser environment
 */
function isChromium() {
    return !!(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.getInst)("chrome");
}
/**
 * Create and open an XMLHttpRequest object
 * @param method - The request method
 * @param urlString - The url
 * @param withCredentials - Option flag indicating that credentials should be sent
 * @param disabled - Optional flag indicating that the XHR object should be marked as disabled and not tracked (default is false)
 * @param isSync - Optional flag indicating if the instance should be a synchronous request (defaults to false)
 * @param timeout - Optional value identifying the timeout value that should be assigned to the XHR request
 * @returns A new opened XHR request
 */
function openXhr(method, urlString, withCredentials, disabled, isSync, timeout) {
    if (disabled === void 0) { disabled = false; }
    if (isSync === void 0) { isSync = false; }
    function _wrapSetXhrProp(xhr, prop, value) {
        try {
            xhr[prop] = value;
        }
        catch (e) {
            // - Wrapping as depending on the environment setting the property may fail (non-terminally)
        }
    }
    var xhr = new XMLHttpRequest();
    if (disabled) {
        // Tag the instance so it's not tracked (trackDependency)
        // If the environment has locked down the XMLHttpRequest (preventExtensions and/or freeze), this would
        // cause the request to fail and we no telemetry would be sent
        _wrapSetXhrProp(xhr, strDisabledPropertyName, disabled);
    }
    if (withCredentials) {
        // Some libraries require that the withCredentials flag is set "before" open and
        // - Wrapping as IE 10 has started throwing when setting before open
        _wrapSetXhrProp(xhr, strWithCredentials, withCredentials);
    }
    xhr.open(method, urlString, !isSync);
    if (withCredentials) {
        // withCredentials should be set AFTER open (https://xhr.spec.whatwg.org/#the-withcredentials-attribute)
        // And older firefox instances from 11+ will throw for sync events (current versions don't) which happens during unload processing
        _wrapSetXhrProp(xhr, strWithCredentials, withCredentials);
    }
    // Only set the timeout for asynchronous requests as
    // "Timeout shouldn't be used for synchronous XMLHttpRequests requests used in a document environment or it will throw an InvalidAccessError exception.""
    // https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/timeout
    if (!isSync && timeout) {
        _wrapSetXhrProp(xhr, strTimeout, timeout);
    }
    return xhr;
}
/**
 * Check to see if the value is > 0
 * @param value - The value to check
 * @returns true if > 0 otherwise false
 */
function isGreaterThanZero(value) {
    return value > 0;
}
//# sourceMappingURL=Utils.js.map

/***/ }),
/* 53 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Undefined": () => (/* binding */ Undefined),
/* harmony export */   "generateW3CId": () => (/* binding */ generateW3CId),
/* harmony export */   "newGuid": () => (/* binding */ newGuid),
/* harmony export */   "strEndsWith": () => (/* binding */ strEndsWith)
/* harmony export */ });
/* harmony import */ var _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(34);
/* harmony import */ var _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(30);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(38);
/* harmony import */ var _InternalConstants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(39);
/* harmony import */ var _RandomHelper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(43);
/*
 * Application Insights JavaScript SDK - Core, 3.3.0
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */








// Added to help with minfication
var Undefined = _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_0__.strShimUndefined;
function newGuid() {
    var uuid = generateW3CId();
    return (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.strSubstring)(uuid, 0, 8) + "-" + (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.strSubstring)(uuid, 8, 12) + "-" + (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.strSubstring)(uuid, 12, 16) + "-" + (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.strSubstring)(uuid, 16, 20) + "-" + (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.strSubstring)(uuid, 20);
}
/**
 * The strEndsWith() method determines whether a string ends with the characters of a specified string, returning true or false as appropriate.
 * @param value - The value to check whether it ends with the search value.
 * @param search - The characters to be searched for at the end of the value.
 * @returns true if the given search value is found at the end of the string, otherwise false.
 */
function strEndsWith(value, search) {
    if (value && search) {
        var len = value[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_LENGTH /* @min:%2elength */];
        var start = len - search[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_LENGTH /* @min:%2elength */];
        return (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.strSubstring)(value, start >= 0 ? start : 0, len) === search;
    }
    return false;
}
/**
 * generate W3C trace id
 */
function generateW3CId() {
    var hexValues = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];
    // rfc4122 version 4 UUID without dashes and with lowercase letters
    var oct = _InternalConstants__WEBPACK_IMPORTED_MODULE_3__.STR_EMPTY, tmp;
    for (var a = 0; a < 4; a++) {
        tmp = (0,_RandomHelper__WEBPACK_IMPORTED_MODULE_4__.random32)();
        oct +=
            hexValues[tmp & 0xF] +
                hexValues[tmp >> 4 & 0xF] +
                hexValues[tmp >> 8 & 0xF] +
                hexValues[tmp >> 12 & 0xF] +
                hexValues[tmp >> 16 & 0xF] +
                hexValues[tmp >> 20 & 0xF] +
                hexValues[tmp >> 24 & 0xF] +
                hexValues[tmp >> 28 & 0xF];
    }
    // "Set the two most significant bits (bits 6 and 7) of the clock_seq_hi_and_reserved to zero and one, respectively"
    var clockSequenceHi = hexValues[8 + ((0,_RandomHelper__WEBPACK_IMPORTED_MODULE_4__.random32)() & 0x03) | 0];
    return (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.strSubstr)(oct, 0, 8) + (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.strSubstr)(oct, 9, 4) + "4" + (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.strSubstr)(oct, 13, 3) + clockSequenceHi + (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.strSubstr)(oct, 16, 3) + (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.strSubstr)(oct, 19, 12);
}
//# sourceMappingURL=CoreUtils.js.map

/***/ }),
/* 54 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AppInsightsCore": () => (/* binding */ AppInsightsCore)
/* harmony export */ });
/* harmony import */ var _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(33);
/* harmony import */ var _microsoft_dynamicproto_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(35);
/* harmony import */ var _nevware21_ts_async__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(56);
/* harmony import */ var _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(30);
/* harmony import */ var _Config_DynamicConfig__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(40);
/* harmony import */ var _JavaScriptSDK_Enums_InitActiveStatusEnum__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(55);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(38);
/* harmony import */ var _AsyncUtils__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(60);
/* harmony import */ var _Constants__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(68);
/* harmony import */ var _CookieMgr__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(58);
/* harmony import */ var _DataCacheHelper__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(42);
/* harmony import */ var _DbgExtensionUtils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(51);
/* harmony import */ var _DiagnosticLogger__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(50);
/* harmony import */ var _HelperFuncs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(45);
/* harmony import */ var _InternalConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(39);
/* harmony import */ var _NotificationManager__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(57);
/* harmony import */ var _PerfManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(37);
/* harmony import */ var _ProcessTelemetryContext__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(61);
/* harmony import */ var _TelemetryHelpers__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(62);
/* harmony import */ var _TelemetryInitializerPlugin__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(64);
/* harmony import */ var _UnloadHandlerContainer__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(67);
/* harmony import */ var _UnloadHookContainer__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(66);
/*
 * Application Insights JavaScript SDK - Core, 3.3.0
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */



var _a;






















var strValidationError = "Plugins must provide initialize method";
var strNotificationManager = "_notificationManager";
var strSdkUnloadingError = "SDK is still unloading...";
var strSdkNotInitialized = "SDK is not initialized";
var maxInitQueueSize = 100;
var maxInitTimeout = 50000;
// const strPluginUnloadFailed = "Failed to unload plugin";
/**
 * The default settings for the config.
 * WE MUST include all defaults here to ensure that the config is created with all of the properties
 * defined as dynamic.
 */
var defaultConfig = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objDeepFreeze)((_a = {
        cookieCfg: {}
    },
    _a[_InternalConstants__WEBPACK_IMPORTED_MODULE_1__.STR_EXTENSIONS] = { rdOnly: true, ref: true, v: [] },
    _a[_InternalConstants__WEBPACK_IMPORTED_MODULE_1__.STR_CHANNELS] = { rdOnly: true, ref: true, v: [] },
    _a[_InternalConstants__WEBPACK_IMPORTED_MODULE_1__.STR_EXTENSION_CONFIG] = { ref: true, v: {} },
    _a[_InternalConstants__WEBPACK_IMPORTED_MODULE_1__.STR_CREATE_PERF_MGR] = _InternalConstants__WEBPACK_IMPORTED_MODULE_1__.UNDEFINED_VALUE,
    _a.loggingLevelConsole = 0 /* eLoggingSeverity.DISABLED */,
    _a.diagnosticLogInterval = _InternalConstants__WEBPACK_IMPORTED_MODULE_1__.UNDEFINED_VALUE,
    _a));
/**
 * Helper to create the default performance manager
 * @param core
 * @param notificationMgr
 */
function _createPerfManager(core, notificationMgr) {
    return new _PerfManager__WEBPACK_IMPORTED_MODULE_2__.PerfManager(notificationMgr);
}
function _validateExtensions(logger, channelPriority, allExtensions) {
    var _a;
    // Concat all available extensions
    var coreExtensions = [];
    var channels = [];
    // Check if any two extensions have the same priority, then warn to console
    // And extract the local extensions from the
    var extPriorities = {};
    // Extension validation
    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrForEach)(allExtensions, function (ext) {
        // Check for ext.initialize
        if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(ext) || (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(ext[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_INITIALIZE /* @min:%2einitialize */])) {
            (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.throwError)(strValidationError);
        }
        var extPriority = ext[_InternalConstants__WEBPACK_IMPORTED_MODULE_1__.STR_PRIORITY /* @min:%2epriority */];
        var identifier = ext[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_IDENTIFIER /* @min:%2eidentifier */];
        if (ext && extPriority) {
            if (!(0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(extPriorities[extPriority])) {
                (0,_DiagnosticLogger__WEBPACK_IMPORTED_MODULE_4__._warnToConsole)(logger, "Two extensions have same priority #" + extPriority + " - " + extPriorities[extPriority] + ", " + identifier);
            }
            else {
                // set a value
                extPriorities[extPriority] = identifier;
            }
        }
        // Split extensions to core and channels
        if (!extPriority || extPriority < channelPriority) {
            // Add to core extension that will be managed by AppInsightsCore
            coreExtensions[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_PUSH /* @min:%2epush */](ext);
        }
        else {
            channels[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_PUSH /* @min:%2epush */](ext);
        }
    });
    return _a = {},
        _a[_InternalConstants__WEBPACK_IMPORTED_MODULE_1__.STR_CORE /* @min:core */] = coreExtensions,
        _a[_InternalConstants__WEBPACK_IMPORTED_MODULE_1__.STR_CHANNELS /* @min:channels */] = channels,
        _a;
}
function _isPluginPresent(thePlugin, plugins) {
    var exists = false;
    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrForEach)(plugins, function (plugin) {
        if (plugin === thePlugin) {
            exists = true;
            return -1;
        }
    });
    return exists;
}
function _deepMergeConfig(details, target, newValues, merge) {
    // Lets assign the new values to the existing config
    if (newValues) {
        (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objForEachKey)(newValues, function (key, value) {
            if (merge) {
                if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value) && (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(target[key])) {
                    // The target is an object and it has a value
                    _deepMergeConfig(details, target[key], value, merge);
                }
            }
            if (merge && (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value) && (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(target[key])) {
                // The target is an object and it has a value
                _deepMergeConfig(details, target[key], value, merge);
            }
            else {
                // Just Assign (replace) and/or make the property dynamic
                details.set(target, key, value);
            }
        });
    }
}
function _findWatcher(listeners, newWatcher) {
    var theListener = null;
    var idx = -1;
    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrForEach)(listeners, function (listener, lp) {
        if (listener.w === newWatcher) {
            theListener = listener;
            idx = lp;
            return -1;
        }
    });
    return { i: idx, l: theListener };
}
function _addDelayedCfgListener(listeners, newWatcher) {
    var theListener = _findWatcher(listeners, newWatcher).l;
    if (!theListener) {
        theListener = {
            w: newWatcher,
            rm: function () {
                var fnd = _findWatcher(listeners, newWatcher);
                if (fnd.i !== -1) {
                    listeners[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_SPLICE /* @min:%2esplice */](fnd.i, 1);
                }
            }
        };
        listeners[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_PUSH /* @min:%2epush */](theListener);
    }
    return theListener;
}
function _registerDelayedCfgListener(config, listeners, logger) {
    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrForEach)(listeners, function (listener) {
        var unloadHdl = (0,_Config_DynamicConfig__WEBPACK_IMPORTED_MODULE_5__.onConfigChange)(config, listener.w, logger);
        delete listener.w; // Clear the listener reference so it will get garbage collected.
        // replace the remove function
        listener.rm = function () {
            unloadHdl.rm();
        };
    });
}
// Moved this outside of the closure to reduce the retained memory footprint
function _initDebugListener(configHandler, unloadContainer, notificationManager, debugListener) {
    // Will get recalled if any referenced config values are changed
    unloadContainer.add(configHandler[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_WATCH /* @min:%2ewatch */](function (details) {
        var disableDbgExt = details.cfg.disableDbgExt;
        if (disableDbgExt === true && debugListener) {
            // Remove any previously loaded debug listener
            notificationManager[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_REMOVE_NOTIFICATION_0 /* @min:%2eremoveNotificationListener */](debugListener);
            debugListener = null;
        }
        if (notificationManager && !debugListener && disableDbgExt !== true) {
            debugListener = (0,_DbgExtensionUtils__WEBPACK_IMPORTED_MODULE_6__.getDebugListener)(details.cfg);
            notificationManager[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_ADD_NOTIFICATION_LIS1 /* @min:%2eaddNotificationListener */](debugListener);
        }
    }));
    return debugListener;
}
// Moved this outside of the closure to reduce the retained memory footprint
function _createUnloadHook(unloadHook) {
    return (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objDefine)({
        rm: function () {
            unloadHook.rm();
        }
    }, "toJSON", { v: function () { return "aicore::onCfgChange<" + JSON.stringify(unloadHook) + ">"; } });
}
/**
 * @group Classes
 * @group Entrypoint
 */
var AppInsightsCore = /** @class */ (function () {
    function AppInsightsCore() {
        // NOTE!: DON'T set default values here, instead set them in the _initDefaults() function as it is also called during teardown()
        var _configHandler;
        var _isInitialized;
        var _logger;
        var _eventQueue;
        var _notificationManager;
        var _perfManager;
        var _cfgPerfManager;
        var _cookieManager;
        var _pluginChain;
        var _configExtensions;
        var _channelConfig;
        var _channels;
        var _isUnloading;
        var _telemetryInitializerPlugin;
        var _internalLogsEventName;
        var _evtNamespace;
        var _unloadHandlers;
        var _hookContainer;
        var _debugListener;
        var _traceCtx;
        var _instrumentationKey;
        var _cfgListeners;
        var _extensions;
        var _pluginVersionStringArr;
        var _pluginVersionString;
        var _activeStatus; // to indicate if ikey or endpoint url promised is resolved or not
        var _endpoint;
        var _initInMemoMaxSize; // max event count limit during wait for init promises to be resolved
        var _isStatusSet; // track if active status is set in case of init timeout and init promises setting the status twice
        var _initTimer;
        /**
         * Internal log poller
         */
        var _internalLogPoller;
        var _internalLogPollerListening;
        var _forceStopInternalLogPoller;
        (0,_microsoft_dynamicproto_js__WEBPACK_IMPORTED_MODULE_7__["default"])(AppInsightsCore, this, function (_self) {
            // Set the default values (also called during teardown)
            _initDefaults();
            // Special internal method to allow the unit tests and DebugPlugin to hook embedded objects
            _self["_getDbgPlgTargets"] = function () {
                return [_extensions, _eventQueue];
            };
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_IS_INITIALIZED /* @min:%2eisInitialized */] = function () { return _isInitialized; };
            // since version 3.3.0
            _self.activeStatus = function () { return _activeStatus; };
            // since version 3.3.0
            // internal
            _self._setPendingStatus = function () {
                _activeStatus = 3 /* eActiveStatus.PENDING */;
            };
            // Creating the self.initialize = ()
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_INITIALIZE /* @min:%2einitialize */] = function (config, extensions, logger, notificationManager) {
                if (_isUnloading) {
                    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.throwError)(strSdkUnloadingError);
                }
                // Make sure core is only initialized once
                if (_self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_IS_INITIALIZED /* @min:%2eisInitialized */]()) {
                    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.throwError)("Core cannot be initialized more than once");
                }
                _configHandler = (0,_Config_DynamicConfig__WEBPACK_IMPORTED_MODULE_5__.createDynamicConfig)(config, defaultConfig, logger || _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LOGGER /* @min:%2elogger */], false);
                // Re-assigning the local config property so we don't have any references to the passed value and it can be garbage collected
                config = _configHandler.cfg;
                // This will be "re-run" if the referenced config properties are changed
                _addUnloadHook(_configHandler[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_WATCH /* @min:%2ewatch */](function (details) {
                    var rootCfg = details.cfg;
                    var isPending = _activeStatus === 3 /* eActiveStatus.PENDING */;
                    if (isPending) {
                        // means waiting for previous promises to be resolved, won't apply new changes
                        return;
                    }
                    _initInMemoMaxSize = rootCfg.initInMemoMaxSize || maxInitQueueSize;
                    // app Insights core only handle ikey and endpointurl, aisku will handle cs
                    var ikey = rootCfg[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_INSTRUMENTATION_KEY /* @min:%2einstrumentationKey */];
                    var endpointUrl = rootCfg.endpointUrl; // do not need to validate endpoint url, if it is null, default one will be set by sender
                    if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(ikey)) {
                        _instrumentationKey = null;
                        // if new ikey is null, set status to be inactive, all new events will be saved in memory or dropped
                        _activeStatus = _JavaScriptSDK_Enums_InitActiveStatusEnum__WEBPACK_IMPORTED_MODULE_8__.ActiveStatus[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN__INACTIVE /* @min:%2eINACTIVE */];
                        var msg = "Please provide instrumentation key";
                        if (!_isInitialized) {
                            // only throw error during initialization
                            (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.throwError)(msg);
                        }
                        else {
                            (0,_DiagnosticLogger__WEBPACK_IMPORTED_MODULE_4__._throwInternal)(_logger, 1 /* eLoggingSeverity.CRITICAL */, 100 /* _eInternalMessageId.InvalidInstrumentationKey */, msg);
                            _releaseQueues();
                        }
                        return;
                    }
                    var promises = [];
                    if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isPromiseLike)(ikey)) {
                        promises[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_PUSH /* @min:%2epush */](ikey);
                        _instrumentationKey = null; // reset current local ikey variable (otherwise it will always be the previous ikeys if timeout is called before promise cb)
                    }
                    else {
                        // string
                        _instrumentationKey = ikey;
                    }
                    if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isPromiseLike)(endpointUrl)) {
                        promises[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_PUSH /* @min:%2epush */](endpointUrl);
                        _endpoint = null; // reset current local endpoint variable (otherwise it will always be the previous urls if timeout is called before promise cb)
                    }
                    else {
                        // string or null
                        _endpoint = endpointUrl;
                    }
                    // at least have one promise
                    if (promises[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LENGTH /* @min:%2elength */]) {
                        // reset to false for new dynamic changes
                        _isStatusSet = false;
                        _activeStatus = 3 /* eActiveStatus.PENDING */;
                        var initTimeout = (0,_HelperFuncs__WEBPACK_IMPORTED_MODULE_9__.isNotNullOrUndefined)(rootCfg.initTimeOut) ? rootCfg.initTimeOut : maxInitTimeout; // rootCfg.initTimeOut could be 0
                        var allPromises = (0,_nevware21_ts_async__WEBPACK_IMPORTED_MODULE_10__.createAllSettledPromise)(promises);
                        _initTimer = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.scheduleTimeout)(function () {
                            // set _isStatusSet to true
                            // set active status
                            // release queues
                            _initTimer = null;
                            if (!_isStatusSet) {
                                _setStatus();
                            }
                        }, initTimeout);
                        (0,_nevware21_ts_async__WEBPACK_IMPORTED_MODULE_10__.doAwaitResponse)(allPromises, function (response) {
                            try {
                                if (_isStatusSet) {
                                    // promises take too long to resolve, ignore them
                                    // active status should be set by timeout already
                                    return;
                                }
                                if (!response.rejected) {
                                    var values = response[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_VALUE /* @min:%2evalue */];
                                    if (values && values[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LENGTH /* @min:%2elength */]) {
                                        // ikey
                                        var ikeyRes = values[0];
                                        _instrumentationKey = ikeyRes && ikeyRes[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_VALUE /* @min:%2evalue */];
                                        // endpoint
                                        if (values[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LENGTH /* @min:%2elength */] > 1) {
                                            var endpointRes = values[1];
                                            _endpoint = endpointRes && endpointRes[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_VALUE /* @min:%2evalue */];
                                        }
                                    }
                                    if (_instrumentationKey) {
                                        // if ikey is null, no need to trigger extra dynamic changes for extensions
                                        config[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_INSTRUMENTATION_KEY /* @min:%2einstrumentationKey */] = _instrumentationKey; // set config.instrumentationKey for extensions to consume
                                        config.endpointUrl = _endpoint; // set config.endpointUrl for extensions to consume
                                    }
                                }
                                // set _isStatusSet to true
                                // set active status
                                // release queues
                                _setStatus();
                            }
                            catch (e) {
                                if (!_isStatusSet) {
                                    _setStatus();
                                }
                            }
                        });
                    }
                    else {
                        // means no promises
                        _setStatus();
                    }
                    //_instrumentationKey = details.cfg.instrumentationKey;
                    // Mark the extensionConfig and all first level keys as referenced
                    // This is so that calls to getExtCfg() will always return the same object
                    // Even when a user may "re-assign" the plugin properties (or it's unloaded/reloaded)
                    var extCfg = details.ref(details.cfg, _InternalConstants__WEBPACK_IMPORTED_MODULE_1__.STR_EXTENSION_CONFIG);
                    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objForEachKey)(extCfg, function (key) {
                        details.ref(extCfg, key);
                    });
                }));
                _notificationManager = notificationManager;
                // Initialize the debug listener outside of the closure to reduce the retained memory footprint
                _debugListener = _initDebugListener(_configHandler, _hookContainer, _notificationManager && _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_GET_NOTIFY_MGR /* @min:%2egetNotifyMgr */](), _debugListener);
                _initPerfManager();
                _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LOGGER /* @min:%2elogger */] = logger;
                var cfgExtensions = config[_InternalConstants__WEBPACK_IMPORTED_MODULE_1__.STR_EXTENSIONS /* @min:%2eextensions */];
                // Extension validation
                _configExtensions = [];
                _configExtensions[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_PUSH /* @min:%2epush */].apply(_configExtensions, (0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_11__.__spreadArrayFn)((0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_11__.__spreadArrayFn)([], extensions, false), cfgExtensions, false));
                _channelConfig = config[_InternalConstants__WEBPACK_IMPORTED_MODULE_1__.STR_CHANNELS /* @min:%2echannels */];
                _initPluginChain(null);
                if (!_channels || _channels[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LENGTH /* @min:%2elength */] === 0) {
                    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.throwError)("No " + _InternalConstants__WEBPACK_IMPORTED_MODULE_1__.STR_CHANNELS + " available");
                }
                if (_channelConfig && _channelConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LENGTH /* @min:%2elength */] > 1) {
                    var teeController = _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_GET_PLUGIN /* @min:%2egetPlugin */]("TeeChannelController");
                    if (!teeController || !teeController.plugin) {
                        (0,_DiagnosticLogger__WEBPACK_IMPORTED_MODULE_4__._throwInternal)(_logger, 1 /* eLoggingSeverity.CRITICAL */, 28 /* _eInternalMessageId.SenderNotInitialized */, "TeeChannel required");
                    }
                }
                _registerDelayedCfgListener(config, _cfgListeners, _logger);
                _cfgListeners = null;
                _isInitialized = true;
                if (_activeStatus === _JavaScriptSDK_Enums_InitActiveStatusEnum__WEBPACK_IMPORTED_MODULE_8__.ActiveStatus.ACTIVE) {
                    _releaseQueues();
                }
            };
            _self.getChannels = function () {
                var controls = [];
                if (_channels) {
                    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrForEach)(_channels, function (channel) {
                        controls[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_PUSH /* @min:%2epush */](channel);
                    });
                }
                return (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objFreeze)(controls);
            };
            _self.track = function (telemetryItem) {
                (0,_PerfManager__WEBPACK_IMPORTED_MODULE_2__.doPerf)(_self[_InternalConstants__WEBPACK_IMPORTED_MODULE_1__.STR_GET_PERF_MGR /* @min:%2egetPerfMgr */](), function () { return "AppInsightsCore:track"; }, function () {
                    if (telemetryItem === null) {
                        _notifyInvalidEvent(telemetryItem);
                        // throw error
                        (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.throwError)("Invalid telemetry item");
                    }
                    // do basic validation before sending it through the pipeline
                    if (!telemetryItem[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_NAME /* @min:%2ename */] && (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(telemetryItem[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_NAME /* @min:%2ename */])) {
                        _notifyInvalidEvent(telemetryItem);
                        (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.throwError)("telemetry name required");
                    }
                    // setup default iKey if not passed in
                    telemetryItem[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_I_KEY /* @min:%2eiKey */] = telemetryItem[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_I_KEY /* @min:%2eiKey */] || _instrumentationKey;
                    // add default timestamp if not passed in
                    telemetryItem[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_TIME /* @min:%2etime */] = telemetryItem[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_TIME /* @min:%2etime */] || (0,_HelperFuncs__WEBPACK_IMPORTED_MODULE_9__.toISOString)(new Date());
                    // Common Schema 4.0
                    telemetryItem.ver = telemetryItem.ver || "4.0";
                    if (!_isUnloading && _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_IS_INITIALIZED /* @min:%2eisInitialized */]() && _activeStatus === _JavaScriptSDK_Enums_InitActiveStatusEnum__WEBPACK_IMPORTED_MODULE_8__.ActiveStatus.ACTIVE) {
                        // Process the telemetry plugin chain
                        _createTelCtx()[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_PROCESS_NEXT /* @min:%2eprocessNext */](telemetryItem);
                    }
                    else if (_activeStatus !== _JavaScriptSDK_Enums_InitActiveStatusEnum__WEBPACK_IMPORTED_MODULE_8__.ActiveStatus[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN__INACTIVE /* @min:%2eINACTIVE */]) {
                        // Queue events until all extensions are initialized
                        if (_eventQueue[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LENGTH /* @min:%2elength */] <= _initInMemoMaxSize) {
                            // set limit, if full, stop adding new events
                            _eventQueue[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_PUSH /* @min:%2epush */](telemetryItem);
                        }
                    }
                }, function () { return ({ item: telemetryItem }); }, !(telemetryItem.sync));
            };
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_GET_PROCESS_TEL_CONT2 /* @min:%2egetProcessTelContext */] = _createTelCtx;
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_GET_NOTIFY_MGR /* @min:%2egetNotifyMgr */] = function () {
                if (!_notificationManager) {
                    _notificationManager = new _NotificationManager__WEBPACK_IMPORTED_MODULE_12__.NotificationManager(_configHandler.cfg);
                    // For backward compatibility only
                    _self[strNotificationManager] = _notificationManager;
                }
                return _notificationManager;
            };
            /**
             * Adds a notification listener. The SDK calls methods on the listener when an appropriate notification is raised.
             * The added plugins must raise notifications. If the plugins do not implement the notifications, then no methods will be
             * called.
             * @param listener - An INotificationListener object.
             */
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_ADD_NOTIFICATION_LIS1 /* @min:%2eaddNotificationListener */] = function (listener) {
                _self.getNotifyMgr()[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_ADD_NOTIFICATION_LIS1 /* @min:%2eaddNotificationListener */](listener);
            };
            /**
             * Removes all instances of the listener.
             * @param listener - INotificationListener to remove.
             */
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_REMOVE_NOTIFICATION_0 /* @min:%2eremoveNotificationListener */] = function (listener) {
                if (_notificationManager) {
                    _notificationManager[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_REMOVE_NOTIFICATION_0 /* @min:%2eremoveNotificationListener */](listener);
                }
            };
            _self.getCookieMgr = function () {
                if (!_cookieManager) {
                    _cookieManager = (0,_CookieMgr__WEBPACK_IMPORTED_MODULE_13__.createCookieMgr)(_configHandler.cfg, _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LOGGER /* @min:%2elogger */]);
                }
                return _cookieManager;
            };
            _self.setCookieMgr = function (cookieMgr) {
                if (_cookieManager !== cookieMgr) {
                    (0,_AsyncUtils__WEBPACK_IMPORTED_MODULE_14__.runTargetUnload)(_cookieManager, false);
                    _cookieManager = cookieMgr;
                }
            };
            _self[_InternalConstants__WEBPACK_IMPORTED_MODULE_1__.STR_GET_PERF_MGR /* @min:%2egetPerfMgr */] = function () {
                return _perfManager || _cfgPerfManager || (0,_PerfManager__WEBPACK_IMPORTED_MODULE_2__.getGblPerfMgr)();
            };
            _self.setPerfMgr = function (perfMgr) {
                _perfManager = perfMgr;
            };
            _self.eventCnt = function () {
                return _eventQueue[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LENGTH /* @min:%2elength */];
            };
            _self.releaseQueue = function () {
                if (_isInitialized && _eventQueue[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LENGTH /* @min:%2elength */] > 0) {
                    var eventQueue = _eventQueue;
                    _eventQueue = [];
                    if (_activeStatus === 2 /* eActiveStatus.ACTIVE */) {
                        (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrForEach)(eventQueue, function (event) {
                            event[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_I_KEY /* @min:%2eiKey */] = event[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_I_KEY /* @min:%2eiKey */] || _instrumentationKey;
                            _createTelCtx()[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_PROCESS_NEXT /* @min:%2eprocessNext */](event);
                        });
                    }
                    else {
                        // new one for msg ikey
                        (0,_DiagnosticLogger__WEBPACK_IMPORTED_MODULE_4__._throwInternal)(_logger, 2 /* eLoggingSeverity.WARNING */, 20 /* _eInternalMessageId.FailedToSendQueuedTelemetry */, "core init status is not active");
                    }
                }
            };
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_POLL_INTERNAL_LOGS /* @min:%2epollInternalLogs */] = function (eventName) {
                _internalLogsEventName = eventName || null;
                _forceStopInternalLogPoller = false;
                _internalLogPoller && _internalLogPoller[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_CANCEL /* @min:%2ecancel */]();
                return _startLogPoller(true);
            };
            function _setStatus() {
                _isStatusSet = true;
                if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(_instrumentationKey)) {
                    _activeStatus = _JavaScriptSDK_Enums_InitActiveStatusEnum__WEBPACK_IMPORTED_MODULE_8__.ActiveStatus[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN__INACTIVE /* @min:%2eINACTIVE */];
                    (0,_DiagnosticLogger__WEBPACK_IMPORTED_MODULE_4__._throwInternal)(_logger, 1 /* eLoggingSeverity.CRITICAL */, 112 /* _eInternalMessageId.InitPromiseException */, "ikey can't be resolved from promises");
                }
                else {
                    _activeStatus = _JavaScriptSDK_Enums_InitActiveStatusEnum__WEBPACK_IMPORTED_MODULE_8__.ActiveStatus.ACTIVE;
                }
                _releaseQueues();
            }
            function _releaseQueues() {
                if (_isInitialized) {
                    _self.releaseQueue();
                    _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_POLL_INTERNAL_LOGS /* @min:%2epollInternalLogs */]();
                }
            }
            function _startLogPoller(alwaysStart) {
                if ((!_internalLogPoller || !_internalLogPoller[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_ENABLED /* @min:%2eenabled */]) && !_forceStopInternalLogPoller) {
                    var shouldStart = alwaysStart || (_logger && _logger.queue[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LENGTH /* @min:%2elength */] > 0);
                    if (shouldStart) {
                        if (!_internalLogPollerListening) {
                            _internalLogPollerListening = true;
                            // listen for any configuration changes so that changes to the
                            // interval will cause the timer to be re-initialized
                            _addUnloadHook(_configHandler[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_WATCH /* @min:%2ewatch */](function (details) {
                                var interval = details.cfg.diagnosticLogInterval;
                                if (!interval || !(interval > 0)) {
                                    interval = 10000;
                                }
                                var isRunning = false;
                                if (_internalLogPoller) {
                                    // It was already created so remember it's running and cancel
                                    isRunning = _internalLogPoller[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_ENABLED /* @min:%2eenabled */];
                                    _internalLogPoller[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_CANCEL /* @min:%2ecancel */]();
                                }
                                // Create / reconfigure
                                _internalLogPoller = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.createTimeout)(_flushInternalLogs, interval);
                                _internalLogPoller.unref();
                                // Restart if previously running
                                _internalLogPoller[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_ENABLED /* @min:%2eenabled */] = isRunning;
                            }));
                        }
                        _internalLogPoller[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_ENABLED /* @min:%2eenabled */] = true;
                    }
                }
                return _internalLogPoller;
            }
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_STOP_POLLING_INTERNA3 /* @min:%2estopPollingInternalLogs */] = function () {
                _forceStopInternalLogPoller = true;
                _internalLogPoller && _internalLogPoller[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_CANCEL /* @min:%2ecancel */]();
                _flushInternalLogs();
            };
            // Add addTelemetryInitializer
            (0,_HelperFuncs__WEBPACK_IMPORTED_MODULE_9__.proxyFunctions)(_self, function () { return _telemetryInitializerPlugin; }, ["addTelemetryInitializer"]);
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_UNLOAD /* @min:%2eunload */] = function (isAsync, unloadComplete, cbTimeout) {
                var _a;
                if (isAsync === void 0) { isAsync = true; }
                if (!_isInitialized) {
                    // The SDK is not initialized
                    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.throwError)(strSdkNotInitialized);
                }
                // Check if the SDK still unloading so throw
                if (_isUnloading) {
                    // The SDK is already unloading
                    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.throwError)(strSdkUnloadingError);
                }
                var unloadState = (_a = {
                        reason: 50 /* TelemetryUnloadReason.SdkUnload */
                    },
                    _a[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_IS_ASYNC /* @min:isAsync */] = isAsync,
                    _a.flushComplete = false,
                    _a);
                var result;
                if (isAsync && !unloadComplete) {
                    result = (0,_nevware21_ts_async__WEBPACK_IMPORTED_MODULE_10__.createPromise)(function (resolve) {
                        // Set the callback to the promise resolve callback
                        unloadComplete = resolve;
                    });
                }
                var processUnloadCtx = (0,_ProcessTelemetryContext__WEBPACK_IMPORTED_MODULE_15__.createProcessTelemetryUnloadContext)(_getPluginChain(), _self);
                processUnloadCtx[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_ON_COMPLETE /* @min:%2eonComplete */](function () {
                    _hookContainer.run(_self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LOGGER /* @min:%2elogger */]);
                    // Run any "unload" functions for the _cookieManager, _notificationManager and _logger
                    (0,_AsyncUtils__WEBPACK_IMPORTED_MODULE_14__.doUnloadAll)([_cookieManager, _notificationManager, _logger], isAsync, function () {
                        _initDefaults();
                        unloadComplete && unloadComplete(unloadState);
                    });
                }, _self);
                function _doUnload(flushComplete) {
                    unloadState.flushComplete = flushComplete;
                    _isUnloading = true;
                    // Run all of the unload handlers first (before unloading the plugins)
                    _unloadHandlers.run(processUnloadCtx, unloadState);
                    // Stop polling the internal logs
                    _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_STOP_POLLING_INTERNA3 /* @min:%2estopPollingInternalLogs */]();
                    // Start unloading the components, from this point onwards the SDK should be considered to be in an unstable state
                    processUnloadCtx[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_PROCESS_NEXT /* @min:%2eprocessNext */](unloadState);
                }
                _flushInternalLogs();
                if (!_flushChannels(isAsync, _doUnload, 6 /* SendRequestReason.SdkUnload */, cbTimeout)) {
                    _doUnload(false);
                }
                return result;
            };
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_GET_PLUGIN /* @min:%2egetPlugin */] = _getPlugin;
            _self.addPlugin = function (plugin, replaceExisting, isAsync, addCb) {
                if (!plugin) {
                    addCb && addCb(false);
                    _logOrThrowError(strValidationError);
                    return;
                }
                var existingPlugin = _getPlugin(plugin[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_IDENTIFIER /* @min:%2eidentifier */]);
                if (existingPlugin && !replaceExisting) {
                    addCb && addCb(false);
                    _logOrThrowError("Plugin [" + plugin[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_IDENTIFIER /* @min:%2eidentifier */] + "] is already loaded!");
                    return;
                }
                var updateState = {
                    reason: 16 /* TelemetryUpdateReason.PluginAdded */
                };
                function _addPlugin(removed) {
                    _configExtensions[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_PUSH /* @min:%2epush */](plugin);
                    updateState.added = [plugin];
                    // Re-Initialize the plugin chain
                    _initPluginChain(updateState);
                    addCb && addCb(true);
                }
                if (existingPlugin) {
                    var removedPlugins_1 = [existingPlugin.plugin];
                    var unloadState = {
                        reason: 2 /* TelemetryUnloadReason.PluginReplace */,
                        isAsync: !!isAsync
                    };
                    _removePlugins(removedPlugins_1, unloadState, function (removed) {
                        if (!removed) {
                            // Previous plugin was successfully removed or was not installed
                            addCb && addCb(false);
                        }
                        else {
                            updateState.removed = removedPlugins_1;
                            updateState.reason |= 32 /* TelemetryUpdateReason.PluginRemoved */;
                            _addPlugin(true);
                        }
                    });
                }
                else {
                    _addPlugin(false);
                }
            };
            _self.updateCfg = function (newConfig, mergeExisting) {
                if (mergeExisting === void 0) { mergeExisting = true; }
                var updateState;
                if (_self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_IS_INITIALIZED /* @min:%2eisInitialized */]()) {
                    updateState = {
                        reason: 1 /* TelemetryUpdateReason.ConfigurationChanged */,
                        cfg: _configHandler.cfg,
                        oldCfg: (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.deepExtend)({}, _configHandler.cfg),
                        newConfig: (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.deepExtend)({}, newConfig),
                        merge: mergeExisting
                    };
                    newConfig = updateState.newConfig;
                    var cfg = _configHandler.cfg;
                    // replace the immutable (if initialized) values
                    // We don't currently allow updating the extensions and channels via the update config
                    // So overwriting any user provided values to reuse the existing values
                    newConfig[_InternalConstants__WEBPACK_IMPORTED_MODULE_1__.STR_EXTENSIONS /* @min:%2eextensions */] = cfg[_InternalConstants__WEBPACK_IMPORTED_MODULE_1__.STR_EXTENSIONS /* @min:%2eextensions */];
                    newConfig[_InternalConstants__WEBPACK_IMPORTED_MODULE_1__.STR_CHANNELS /* @min:%2echannels */] = cfg[_InternalConstants__WEBPACK_IMPORTED_MODULE_1__.STR_CHANNELS /* @min:%2echannels */];
                }
                // Explicitly blocking any previous config watchers so that they don't get called because
                // of this bulk update (Probably not necessary)
                _configHandler._block(function (details) {
                    // Lets assign the new values to the existing config either overwriting or re-assigning
                    var theConfig = details.cfg;
                    _deepMergeConfig(details, theConfig, newConfig, mergeExisting);
                    if (!mergeExisting) {
                        // Remove (unassign) the values "missing" from the newConfig and also not in the default config
                        (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objForEachKey)(theConfig, function (key) {
                            if (!(0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objHasOwn)(newConfig, key)) {
                                // Set the value to undefined
                                details.set(theConfig, key, _InternalConstants__WEBPACK_IMPORTED_MODULE_1__.UNDEFINED_VALUE);
                            }
                        });
                    }
                    // Apply defaults to the new config
                    details[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_SET_DF /* @min:%2esetDf */](theConfig, defaultConfig);
                }, true);
                // Now execute all of the listeners (synchronously) so they update their values immediately
                _configHandler[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_NOTIFY /* @min:%2enotify */]();
                if (updateState) {
                    _doUpdate(updateState);
                }
            };
            _self.evtNamespace = function () {
                return _evtNamespace;
            };
            _self.flush = _flushChannels;
            _self.getTraceCtx = function (createNew) {
                if (!_traceCtx) {
                    _traceCtx = (0,_TelemetryHelpers__WEBPACK_IMPORTED_MODULE_16__.createDistributedTraceContext)();
                }
                return _traceCtx;
            };
            _self.setTraceCtx = function (traceCtx) {
                _traceCtx = traceCtx || null;
            };
            _self.addUnloadHook = _addUnloadHook;
            // Create the addUnloadCb
            (0,_HelperFuncs__WEBPACK_IMPORTED_MODULE_9__.proxyFunctionAs)(_self, "addUnloadCb", function () { return _unloadHandlers; }, "add");
            _self.onCfgChange = function (handler) {
                var unloadHook;
                if (!_isInitialized) {
                    unloadHook = _addDelayedCfgListener(_cfgListeners, handler);
                }
                else {
                    unloadHook = (0,_Config_DynamicConfig__WEBPACK_IMPORTED_MODULE_5__.onConfigChange)(_configHandler.cfg, handler, _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LOGGER /* @min:%2elogger */]);
                }
                return _createUnloadHook(unloadHook);
            };
            _self.getWParam = function () {
                return ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.hasDocument)() || !!_configHandler.cfg.enableWParam) ? 0 : -1;
            };
            function _setPluginVersions() {
                var thePlugins = {};
                _pluginVersionStringArr = [];
                var _addPluginVersions = function (plugins) {
                    if (plugins) {
                        (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrForEach)(plugins, function (plugin) {
                            if (plugin[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_IDENTIFIER /* @min:%2eidentifier */] && plugin[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_VERSION /* @min:%2eversion */] && !thePlugins[plugin.identifier]) {
                                var ver = plugin[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_IDENTIFIER /* @min:%2eidentifier */] + "=" + plugin[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_VERSION /* @min:%2eversion */];
                                _pluginVersionStringArr[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_PUSH /* @min:%2epush */](ver);
                                thePlugins[plugin.identifier] = plugin;
                            }
                        });
                    }
                };
                _addPluginVersions(_channels);
                if (_channelConfig) {
                    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrForEach)(_channelConfig, function (channels) {
                        _addPluginVersions(channels);
                    });
                }
                _addPluginVersions(_configExtensions);
            }
            function _initDefaults() {
                _isInitialized = false;
                // Use a default logger so initialization errors are not dropped on the floor with full logging
                _configHandler = (0,_Config_DynamicConfig__WEBPACK_IMPORTED_MODULE_5__.createDynamicConfig)({}, defaultConfig, _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LOGGER /* @min:%2elogger */]);
                // Set the logging level to critical so that any critical initialization failures are displayed on the console
                _configHandler.cfg[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LOGGING_LEVEL_CONSOL4 /* @min:%2eloggingLevelConsole */] = 1 /* eLoggingSeverity.CRITICAL */;
                // Define _self.config
                (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objDefine)(_self, "config", {
                    g: function () { return _configHandler.cfg; },
                    s: function (newValue) {
                        _self.updateCfg(newValue, false);
                    }
                });
                (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objDefine)(_self, "pluginVersionStringArr", {
                    g: function () {
                        if (!_pluginVersionStringArr) {
                            _setPluginVersions();
                        }
                        return _pluginVersionStringArr;
                    }
                });
                (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objDefine)(_self, "pluginVersionString", {
                    g: function () {
                        if (!_pluginVersionString) {
                            if (!_pluginVersionStringArr) {
                                _setPluginVersions();
                            }
                            _pluginVersionString = _pluginVersionStringArr.join(";");
                        }
                        return _pluginVersionString || _InternalConstants__WEBPACK_IMPORTED_MODULE_1__.STR_EMPTY;
                    }
                });
                (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objDefine)(_self, "logger", {
                    g: function () {
                        if (!_logger) {
                            _logger = new _DiagnosticLogger__WEBPACK_IMPORTED_MODULE_4__.DiagnosticLogger(_configHandler.cfg);
                            _configHandler[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LOGGER /* @min:%2elogger */] = _logger;
                        }
                        return _logger;
                    },
                    s: function (newLogger) {
                        _configHandler[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LOGGER /* @min:%2elogger */] = newLogger;
                        if (_logger !== newLogger) {
                            (0,_AsyncUtils__WEBPACK_IMPORTED_MODULE_14__.runTargetUnload)(_logger, false);
                            _logger = newLogger;
                        }
                    }
                });
                _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LOGGER /* @min:%2elogger */] = new _DiagnosticLogger__WEBPACK_IMPORTED_MODULE_4__.DiagnosticLogger(_configHandler.cfg);
                _extensions = [];
                var cfgExtensions = _self.config[_InternalConstants__WEBPACK_IMPORTED_MODULE_1__.STR_EXTENSIONS /* @min:%2eextensions */] || [];
                cfgExtensions.splice(0, cfgExtensions[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LENGTH /* @min:%2elength */]);
                (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrAppend)(cfgExtensions, _extensions);
                _telemetryInitializerPlugin = new _TelemetryInitializerPlugin__WEBPACK_IMPORTED_MODULE_17__.TelemetryInitializerPlugin();
                _eventQueue = [];
                (0,_AsyncUtils__WEBPACK_IMPORTED_MODULE_14__.runTargetUnload)(_notificationManager, false);
                _notificationManager = null;
                _perfManager = null;
                _cfgPerfManager = null;
                (0,_AsyncUtils__WEBPACK_IMPORTED_MODULE_14__.runTargetUnload)(_cookieManager, false);
                _cookieManager = null;
                _pluginChain = null;
                _configExtensions = [];
                _channelConfig = null;
                _channels = null;
                _isUnloading = false;
                _internalLogsEventName = null;
                _evtNamespace = (0,_DataCacheHelper__WEBPACK_IMPORTED_MODULE_18__.createUniqueNamespace)("AIBaseCore", true);
                _unloadHandlers = (0,_UnloadHandlerContainer__WEBPACK_IMPORTED_MODULE_19__.createUnloadHandlerContainer)();
                _traceCtx = null;
                _instrumentationKey = null;
                _hookContainer = (0,_UnloadHookContainer__WEBPACK_IMPORTED_MODULE_20__.createUnloadHookContainer)();
                _cfgListeners = [];
                _pluginVersionString = null;
                _pluginVersionStringArr = null;
                _forceStopInternalLogPoller = false;
                _internalLogPoller = null;
                _internalLogPollerListening = false;
                _activeStatus = 0 /* eActiveStatus.NONE */; // default is None
                _endpoint = null;
                _initInMemoMaxSize = null;
                _isStatusSet = false;
                _initTimer = null;
            }
            function _createTelCtx() {
                var theCtx = (0,_ProcessTelemetryContext__WEBPACK_IMPORTED_MODULE_15__.createProcessTelemetryContext)(_getPluginChain(), _configHandler.cfg, _self);
                theCtx[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_ON_COMPLETE /* @min:%2eonComplete */](_startLogPoller);
                return theCtx;
            }
            // Initialize or Re-initialize the plugins
            function _initPluginChain(updateState) {
                // Extension validation
                var theExtensions = _validateExtensions(_self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LOGGER /* @min:%2elogger */], _Constants__WEBPACK_IMPORTED_MODULE_21__.ChannelControllerPriority, _configExtensions);
                _pluginChain = null;
                _pluginVersionString = null;
                _pluginVersionStringArr = null;
                // Get the primary channel queue and include as part of the normal extensions
                _channels = (_channelConfig || [])[0] || [];
                // Add any channels provided in the extensions and sort them
                _channels = (0,_TelemetryHelpers__WEBPACK_IMPORTED_MODULE_16__.sortPlugins)((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrAppend)(_channels, theExtensions[_InternalConstants__WEBPACK_IMPORTED_MODULE_1__.STR_CHANNELS /* @min:%2echannels */]));
                // Create an array of all extensions, including the _channels
                var allExtensions = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrAppend)((0,_TelemetryHelpers__WEBPACK_IMPORTED_MODULE_16__.sortPlugins)(theExtensions[_InternalConstants__WEBPACK_IMPORTED_MODULE_1__.STR_CORE /* @min:%2ecore */]), _channels);
                // Required to allow plugins to call core.getPlugin() during their own initialization
                _extensions = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objFreeze)(allExtensions);
                // This has a side effect of adding the extensions passed during initialization
                // into the config.extensions, so you can see all of the extensions loaded.
                // This will also get updated by the addPlugin() and remove plugin code.
                var cfgExtensions = _self.config[_InternalConstants__WEBPACK_IMPORTED_MODULE_1__.STR_EXTENSIONS /* @min:%2eextensions */] || [];
                cfgExtensions.splice(0, cfgExtensions[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LENGTH /* @min:%2elength */]);
                (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrAppend)(cfgExtensions, _extensions);
                var rootCtx = _createTelCtx();
                // Initializing the channels first
                if (_channels && _channels[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LENGTH /* @min:%2elength */] > 0) {
                    (0,_TelemetryHelpers__WEBPACK_IMPORTED_MODULE_16__.initializePlugins)(rootCtx[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_CREATE_NEW /* @min:%2ecreateNew */](_channels), allExtensions);
                }
                // Now initialize the normal extensions (explicitly not including the _channels as this can cause duplicate initialization)
                (0,_TelemetryHelpers__WEBPACK_IMPORTED_MODULE_16__.initializePlugins)(rootCtx, allExtensions);
                if (updateState) {
                    _doUpdate(updateState);
                }
            }
            function _getPlugin(pluginIdentifier) {
                var theExt = null;
                var thePlugin = null;
                var channelHosts = [];
                (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrForEach)(_extensions, function (ext) {
                    if (ext[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_IDENTIFIER /* @min:%2eidentifier */] === pluginIdentifier && ext !== _telemetryInitializerPlugin) {
                        thePlugin = ext;
                        return -1;
                    }
                    if (ext.getChannel) {
                        channelHosts[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_PUSH /* @min:%2epush */](ext);
                    }
                });
                if (!thePlugin && channelHosts[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LENGTH /* @min:%2elength */] > 0) {
                    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrForEach)(channelHosts, function (host) {
                        thePlugin = host.getChannel(pluginIdentifier);
                        if (!thePlugin) {
                            return -1;
                        }
                    });
                }
                if (thePlugin) {
                    theExt = {
                        plugin: thePlugin,
                        setEnabled: function (enabled) {
                            (0,_TelemetryHelpers__WEBPACK_IMPORTED_MODULE_16__._getPluginState)(thePlugin)[_InternalConstants__WEBPACK_IMPORTED_MODULE_1__.STR_DISABLED] = !enabled;
                        },
                        isEnabled: function () {
                            var pluginState = (0,_TelemetryHelpers__WEBPACK_IMPORTED_MODULE_16__._getPluginState)(thePlugin);
                            return !pluginState[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_TEARDOWN /* @min:%2eteardown */] && !pluginState[_InternalConstants__WEBPACK_IMPORTED_MODULE_1__.STR_DISABLED];
                        },
                        remove: function (isAsync, removeCb) {
                            var _a;
                            if (isAsync === void 0) { isAsync = true; }
                            var pluginsToRemove = [thePlugin];
                            var unloadState = (_a = {
                                    reason: 1 /* TelemetryUnloadReason.PluginUnload */
                                },
                                _a[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_IS_ASYNC /* @min:isAsync */] = isAsync,
                                _a);
                            _removePlugins(pluginsToRemove, unloadState, function (removed) {
                                if (removed) {
                                    // Re-Initialize the plugin chain
                                    _initPluginChain({
                                        reason: 32 /* TelemetryUpdateReason.PluginRemoved */,
                                        removed: pluginsToRemove
                                    });
                                }
                                removeCb && removeCb(removed);
                            });
                        }
                    };
                }
                return theExt;
            }
            function _getPluginChain() {
                if (!_pluginChain) {
                    // copy the collection of extensions
                    var extensions = (_extensions || []).slice();
                    // During add / remove this may get called again, so don't read if already present
                    if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrIndexOf)(extensions, _telemetryInitializerPlugin) === -1) {
                        extensions[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_PUSH /* @min:%2epush */](_telemetryInitializerPlugin);
                    }
                    _pluginChain = (0,_ProcessTelemetryContext__WEBPACK_IMPORTED_MODULE_15__.createTelemetryProxyChain)((0,_TelemetryHelpers__WEBPACK_IMPORTED_MODULE_16__.sortPlugins)(extensions), _configHandler.cfg, _self);
                }
                return _pluginChain;
            }
            function _removePlugins(thePlugins, unloadState, removeComplete) {
                if (thePlugins && thePlugins[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LENGTH /* @min:%2elength */] > 0) {
                    var unloadChain = (0,_ProcessTelemetryContext__WEBPACK_IMPORTED_MODULE_15__.createTelemetryProxyChain)(thePlugins, _configHandler.cfg, _self);
                    var unloadCtx = (0,_ProcessTelemetryContext__WEBPACK_IMPORTED_MODULE_15__.createProcessTelemetryUnloadContext)(unloadChain, _self);
                    unloadCtx[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_ON_COMPLETE /* @min:%2eonComplete */](function () {
                        var removed = false;
                        // Remove the listed config extensions
                        var newConfigExtensions = [];
                        (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrForEach)(_configExtensions, function (plugin, idx) {
                            if (!_isPluginPresent(plugin, thePlugins)) {
                                newConfigExtensions[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_PUSH /* @min:%2epush */](plugin);
                            }
                            else {
                                removed = true;
                            }
                        });
                        _configExtensions = newConfigExtensions;
                        _pluginVersionString = null;
                        _pluginVersionStringArr = null;
                        // Re-Create the channel config
                        var newChannelConfig = [];
                        if (_channelConfig) {
                            (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrForEach)(_channelConfig, function (queue, idx) {
                                var newQueue = [];
                                (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrForEach)(queue, function (channel) {
                                    if (!_isPluginPresent(channel, thePlugins)) {
                                        newQueue[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_PUSH /* @min:%2epush */](channel);
                                    }
                                    else {
                                        removed = true;
                                    }
                                });
                                newChannelConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_PUSH /* @min:%2epush */](newQueue);
                            });
                            _channelConfig = newChannelConfig;
                        }
                        removeComplete && removeComplete(removed);
                        _startLogPoller();
                    });
                    unloadCtx[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_PROCESS_NEXT /* @min:%2eprocessNext */](unloadState);
                }
                else {
                    removeComplete(false);
                }
            }
            function _flushInternalLogs() {
                if (_logger && _logger.queue) {
                    var queue = _logger.queue.slice(0);
                    _logger.queue[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LENGTH /* @min:%2elength */] = 0;
                    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrForEach)(queue, function (logMessage) {
                        var _a;
                        var item = (_a = {},
                            _a[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_NAME /* @min:name */] = _internalLogsEventName ? _internalLogsEventName : "InternalMessageId: " + logMessage[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_MESSAGE_ID /* @min:%2emessageId */],
                            _a[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_I_KEY /* @min:iKey */] = _instrumentationKey,
                            _a[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_TIME /* @min:time */] = (0,_HelperFuncs__WEBPACK_IMPORTED_MODULE_9__.toISOString)(new Date()),
                            _a.baseType = _DiagnosticLogger__WEBPACK_IMPORTED_MODULE_4__._InternalLogMessage.dataType,
                            _a.baseData = { message: logMessage[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_MESSAGE /* @min:%2emessage */] },
                            _a);
                        _self.track(item);
                    });
                }
            }
            function _flushChannels(isAsync, callBack, sendReason, cbTimeout) {
                // Setting waiting to one so that we don't call the callBack until we finish iterating
                var waiting = 1;
                var doneIterating = false;
                var cbTimer = null;
                cbTimeout = cbTimeout || 5000;
                function doCallback() {
                    waiting--;
                    if (doneIterating && waiting === 0) {
                        cbTimer && cbTimer[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_CANCEL /* @min:%2ecancel */]();
                        cbTimer = null;
                        callBack && callBack(doneIterating);
                        callBack = null;
                    }
                }
                if (_channels && _channels[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LENGTH /* @min:%2elength */] > 0) {
                    var flushCtx = _createTelCtx()[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_CREATE_NEW /* @min:%2ecreateNew */](_channels);
                    flushCtx.iterate(function (plugin) {
                        if (plugin.flush) {
                            waiting++;
                            var handled_1 = false;
                            // Not all channels will call this callback for every scenario
                            if (!plugin.flush(isAsync, function () {
                                handled_1 = true;
                                doCallback();
                            }, sendReason)) {
                                if (!handled_1) {
                                    // If any channel doesn't return true and it didn't call the callback, then we should assume that the callback
                                    // will never be called, so use a timeout to allow the channel(s) some time to "finish" before triggering any
                                    // followup function (such as unloading)
                                    if (isAsync && cbTimer == null) {
                                        cbTimer = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.scheduleTimeout)(function () {
                                            cbTimer = null;
                                            doCallback();
                                        }, cbTimeout);
                                    }
                                    else {
                                        doCallback();
                                    }
                                }
                            }
                        }
                    });
                }
                doneIterating = true;
                doCallback();
                return true;
            }
            function _initPerfManager() {
                // Save the previous config based performance manager creator to avoid creating new perf manager instances if unchanged
                var prevCfgPerfMgr;
                // Will get recalled if any referenced config values are changed
                _addUnloadHook(_configHandler[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_WATCH /* @min:%2ewatch */](function (details) {
                    var enablePerfMgr = details.cfg.enablePerfMgr;
                    if (enablePerfMgr) {
                        var createPerfMgr = details.cfg[_InternalConstants__WEBPACK_IMPORTED_MODULE_1__.STR_CREATE_PERF_MGR /* @min:%2ecreatePerfMgr */];
                        if (prevCfgPerfMgr !== createPerfMgr) {
                            if (!createPerfMgr) {
                                createPerfMgr = _createPerfManager;
                            }
                            // Set the performance manager creation function if not defined
                            (0,_HelperFuncs__WEBPACK_IMPORTED_MODULE_9__.getSetValue)(details.cfg, _InternalConstants__WEBPACK_IMPORTED_MODULE_1__.STR_CREATE_PERF_MGR, createPerfMgr);
                            prevCfgPerfMgr = createPerfMgr;
                            // Remove any existing config based performance manager
                            _cfgPerfManager = null;
                        }
                        // Only create the performance manager if it's not already created or manually set
                        if (!_perfManager && !_cfgPerfManager && (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isFunction)(createPerfMgr)) {
                            // Create a new config based performance manager
                            _cfgPerfManager = createPerfMgr(_self, _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_GET_NOTIFY_MGR /* @min:%2egetNotifyMgr */]());
                        }
                    }
                    else {
                        // Remove any existing config based performance manager
                        _cfgPerfManager = null;
                        // Clear the previous cached value so it can be GC'd
                        prevCfgPerfMgr = null;
                    }
                }));
            }
            function _doUpdate(updateState) {
                var updateCtx = (0,_ProcessTelemetryContext__WEBPACK_IMPORTED_MODULE_15__.createProcessTelemetryUpdateContext)(_getPluginChain(), _self);
                updateCtx[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_ON_COMPLETE /* @min:%2eonComplete */](_startLogPoller);
                if (!_self._updateHook || _self._updateHook(updateCtx, updateState) !== true) {
                    updateCtx[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_PROCESS_NEXT /* @min:%2eprocessNext */](updateState);
                }
            }
            function _logOrThrowError(message) {
                var logger = _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LOGGER /* @min:%2elogger */];
                if (logger) {
                    // there should always be a logger
                    (0,_DiagnosticLogger__WEBPACK_IMPORTED_MODULE_4__._throwInternal)(logger, 2 /* eLoggingSeverity.WARNING */, 73 /* _eInternalMessageId.PluginException */, message);
                    _startLogPoller();
                }
                else {
                    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.throwError)(message);
                }
            }
            function _notifyInvalidEvent(telemetryItem) {
                var manager = _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_GET_NOTIFY_MGR /* @min:%2egetNotifyMgr */]();
                if (manager) {
                    manager[_InternalConstants__WEBPACK_IMPORTED_MODULE_1__.STR_EVENTS_DISCARDED /* @min:%2eeventsDiscarded */]([telemetryItem], 2 /* eEventsDiscardedReason.InvalidEvent */);
                }
            }
            function _addUnloadHook(hooks) {
                _hookContainer.add(hooks);
            }
        });
    }
// Removed Stub for AppInsightsCore.prototype.initialize.
// Removed Stub for AppInsightsCore.prototype.getChannels.
// Removed Stub for AppInsightsCore.prototype.track.
// Removed Stub for AppInsightsCore.prototype.getProcessTelContext.
// Removed Stub for AppInsightsCore.prototype.getNotifyMgr.
// Removed Stub for AppInsightsCore.prototype.addNotificationListener.
// Removed Stub for AppInsightsCore.prototype.removeNotificationListener.
// Removed Stub for AppInsightsCore.prototype.getCookieMgr.
// Removed Stub for AppInsightsCore.prototype.setCookieMgr.
// Removed Stub for AppInsightsCore.prototype.getPerfMgr.
// Removed Stub for AppInsightsCore.prototype.setPerfMgr.
// Removed Stub for AppInsightsCore.prototype.eventCnt.
// Removed Stub for AppInsightsCore.prototype.pollInternalLogs.
// Removed Stub for AppInsightsCore.prototype.stopPollingInternalLogs.
// Removed Stub for AppInsightsCore.prototype.addTelemetryInitializer.
// Removed Stub for AppInsightsCore.prototype.unload.
// Removed Stub for AppInsightsCore.prototype.getPlugin.
// Removed Stub for AppInsightsCore.prototype.addPlugin.
// Removed Stub for AppInsightsCore.prototype.updateCfg.
// Removed Stub for AppInsightsCore.prototype.evtNamespace.
// Removed Stub for AppInsightsCore.prototype.addUnloadCb.
// Removed Stub for AppInsightsCore.prototype.flush.
// Removed Stub for AppInsightsCore.prototype.getTraceCtx.
// Removed Stub for AppInsightsCore.prototype.setTraceCtx.
// Removed Stub for AppInsightsCore.prototype.addUnloadHook.
// Removed Stub for AppInsightsCore.prototype.onCfgChange.
// Removed Stub for AppInsightsCore.prototype.activeStatus.
// Removed Stub for AppInsightsCore.prototype._setPendingStatus.
// Removed Stub for AppInsightsCore.prototype.releaseQueue.
// Removed Stub for AppInsightsCore.prototype._updateHook.
    // This is a workaround for an IE bug when using dynamicProto() with classes that don't have any
    // non-dynamic functions or static properties/functions when using uglify-js to minify the resulting code.
    AppInsightsCore.__ieDyn=1;

    return AppInsightsCore;
}());

//# sourceMappingURL=AppInsightsCore.js.map

/***/ }),
/* 55 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ActiveStatus": () => (/* binding */ ActiveStatus)
/* harmony export */ });
/* harmony import */ var _EnumHelperFuncs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(29);
/*
 * Application Insights JavaScript SDK - Core, 3.3.0
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */

var ActiveStatus = (0,_EnumHelperFuncs__WEBPACK_IMPORTED_MODULE_0__.createEnumStyle)({
    NONE: 0 /* eActiveStatus.NONE */,
    PENDING: 3 /* eActiveStatus.PENDING */,
    INACTIVE: 1 /* eActiveStatus.INACTIVE */,
    ACTIVE: 2 /* eActiveStatus.ACTIVE */
});
//# sourceMappingURL=InitActiveStatusEnum.js.map

/***/ }),
/* 56 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PolyPromise": () => (/* binding */ PolyPromise),
/* harmony export */   "arrForEachAsync": () => (/* binding */ arrForEachAsync),
/* harmony export */   "createAllPromise": () => (/* binding */ createAllPromise),
/* harmony export */   "createAllSettledPromise": () => (/* binding */ createAllSettledPromise),
/* harmony export */   "createAnyPromise": () => (/* binding */ createAnyPromise),
/* harmony export */   "createAsyncAllPromise": () => (/* binding */ createAsyncAllPromise),
/* harmony export */   "createAsyncAllSettledPromise": () => (/* binding */ createAsyncAllSettledPromise),
/* harmony export */   "createAsyncAnyPromise": () => (/* binding */ createAsyncAnyPromise),
/* harmony export */   "createAsyncPromise": () => (/* binding */ createAsyncPromise),
/* harmony export */   "createAsyncRacePromise": () => (/* binding */ createAsyncRacePromise),
/* harmony export */   "createAsyncRejectedPromise": () => (/* binding */ createAsyncRejectedPromise),
/* harmony export */   "createAsyncResolvedPromise": () => (/* binding */ createAsyncResolvedPromise),
/* harmony export */   "createIdleAllPromise": () => (/* binding */ createIdleAllPromise),
/* harmony export */   "createIdleAllSettledPromise": () => (/* binding */ createIdleAllSettledPromise),
/* harmony export */   "createIdleAnyPromise": () => (/* binding */ createIdleAnyPromise),
/* harmony export */   "createIdlePromise": () => (/* binding */ createIdlePromise),
/* harmony export */   "createIdleRacePromise": () => (/* binding */ createIdleRacePromise),
/* harmony export */   "createIdleRejectedPromise": () => (/* binding */ createIdleRejectedPromise),
/* harmony export */   "createIdleResolvedPromise": () => (/* binding */ createIdleResolvedPromise),
/* harmony export */   "createNativeAllPromise": () => (/* binding */ createNativeAllPromise),
/* harmony export */   "createNativeAllSettledPromise": () => (/* binding */ createNativeAllSettledPromise),
/* harmony export */   "createNativeAnyPromise": () => (/* binding */ createNativeAnyPromise),
/* harmony export */   "createNativePromise": () => (/* binding */ createNativePromise),
/* harmony export */   "createNativeRacePromise": () => (/* binding */ createNativeRacePromise),
/* harmony export */   "createNativeRejectedPromise": () => (/* binding */ createNativeRejectedPromise),
/* harmony export */   "createNativeResolvedPromise": () => (/* binding */ createNativeResolvedPromise),
/* harmony export */   "createPromise": () => (/* binding */ createPromise),
/* harmony export */   "createRacePromise": () => (/* binding */ createRacePromise),
/* harmony export */   "createRejectedPromise": () => (/* binding */ createRejectedPromise),
/* harmony export */   "createResolvedPromise": () => (/* binding */ createResolvedPromise),
/* harmony export */   "createSyncAllPromise": () => (/* binding */ createSyncAllPromise),
/* harmony export */   "createSyncAllSettledPromise": () => (/* binding */ createSyncAllSettledPromise),
/* harmony export */   "createSyncAnyPromise": () => (/* binding */ createSyncAnyPromise),
/* harmony export */   "createSyncPromise": () => (/* binding */ createSyncPromise),
/* harmony export */   "createSyncRacePromise": () => (/* binding */ createSyncRacePromise),
/* harmony export */   "createSyncRejectedPromise": () => (/* binding */ createSyncRejectedPromise),
/* harmony export */   "createSyncResolvedPromise": () => (/* binding */ createSyncResolvedPromise),
/* harmony export */   "createTaskScheduler": () => (/* binding */ createTaskScheduler),
/* harmony export */   "createTimeoutPromise": () => (/* binding */ createTimeoutPromise),
/* harmony export */   "doAwait": () => (/* binding */ doAwait),
/* harmony export */   "doAwaitResponse": () => (/* binding */ doAwaitResponse),
/* harmony export */   "doFinally": () => (/* binding */ doFinally),
/* harmony export */   "doWhileAsync": () => (/* binding */ doWhileAsync),
/* harmony export */   "iterForOfAsync": () => (/* binding */ iterForOfAsync),
/* harmony export */   "setCreatePromiseImpl": () => (/* binding */ setCreatePromiseImpl),
/* harmony export */   "setDefaultIdlePromiseTimeout": () => (/* binding */ setDefaultIdlePromiseTimeout),
/* harmony export */   "setDefaultIdleTimeout": () => (/* binding */ setDefaultIdleTimeout),
/* harmony export */   "setPromiseDebugState": () => (/* binding */ setPromiseDebugState)
/* harmony export */ });
/* harmony import */ var _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(30);
/*!
 * NevWare21 Solutions LLC - ts-async, 0.5.2
 * https://github.com/nevware21/ts-async
 * Copyright (c) NevWare21 Solutions LLC and contributors. All rights reserved.
 * Licensed under the MIT license.
 */


var STR_PROMISE = "Promise";
var DONE = "done";
var VALUE = "value";
var RETURN = "return";
var REJECTED = "rejected";

function doAwaitResponse(value, cb) {
    return doAwait(value, function (value) {
        return cb ? cb({
            status: "fulfilled",
            rejected: false,
            value: value
        }) : value;
    }, function (reason) {
        return cb ? cb({
            status: REJECTED,
            rejected: true,
            reason: reason
        }) : reason;
    });
}
function doAwait(value, resolveFn, rejectFn, finallyFn) {
    var result = value;
    try {
        if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isPromiseLike)(value)) {
            if (resolveFn || rejectFn) {
                result = value.then(resolveFn, rejectFn);
            }
        }
        else {
            try {
                if (resolveFn) {
                    result = resolveFn(value);
                }
            }
            catch (err) {
                if (rejectFn) {
                    result = rejectFn(err);
                }
                else {
                    throw err;
                }
            }
        }
    }
    finally {
        if (finallyFn) {
            doFinally(result, finallyFn);
        }
    }
    return result;
}
function doFinally(value, finallyFn) {
    var result = value;
    if (finallyFn) {
        if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isPromiseLike)(value)) {
            if (value.finally) {
                result = value.finally(finallyFn);
            }
            else {
                result = value.then(function (value) {
                    finallyFn();
                    return value;
                }, function (reason) {
                    finallyFn();
                    throw reason;
                });
            }
        }
        else {
            finallyFn();
        }
    }
    return result;
}

var _debugState;
var _debugResult;
var _debugHandled;
var _promiseDebugEnabled = false;
function _addDebugState$1(thePromise, stateFn, resultFn, handledFn) {
    _debugState = _debugState || { toString: function () { return "[[PromiseState]]"; } };
    _debugResult = _debugResult || { toString: function () { return "[[PromiseResult]]"; } };
    _debugHandled = _debugHandled || { toString: function () { return "[[PromiseIsHandled]]"; } };
    var props = {};
    props[_debugState] = { get: stateFn };
    props[_debugResult] = { get: resultFn };
    props[_debugHandled] = { get: handledFn };
    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objDefineProperties)(thePromise, props);
}
function setPromiseDebugState(enabled, logger) {
    _promiseDebugEnabled = enabled;
}

var STRING_STATES =  [
    "pending", "resolving", "resolved", REJECTED
];

var DISPATCH_EVENT = "dispatchEvent";
var _hasInitEvent;
function _hasInitEventFn(doc) {
    var evt;
    if (doc && doc.createEvent) {
        evt = doc.createEvent("Event");
    }
    return (!!evt && evt.initEvent);
}
function emitEvent(target, evtName, populateEvent, useNewEvent) {
    var doc = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.getDocument)();
    !_hasInitEvent && (_hasInitEvent = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.createCachedValue)(!!(0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.safe)(_hasInitEventFn, [doc]).v));
    var theEvt = _hasInitEvent.v ? doc.createEvent("Event") : (useNewEvent ? new Event(evtName) : {});
    populateEvent && populateEvent(theEvt);
    if (_hasInitEvent.v) {
        theEvt.initEvent(evtName, false, true);
    }
    if (theEvt && target[DISPATCH_EVENT]) {
        target[DISPATCH_EVENT](theEvt);
    }
    else {
        var handler = target["on" + evtName];
        if (handler) {
            handler(theEvt);
        }
        else {
            var theConsole = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.getInst)("console");
            theConsole && (theConsole["error"] || theConsole["log"])(evtName, (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.dumpObj)(theEvt));
        }
    }
}

var NODE_UNHANDLED_REJECTION = "unhandledRejection";
var UNHANDLED_REJECTION = NODE_UNHANDLED_REJECTION.toLowerCase();
var _currentPromiseId = [];
var _uniquePromiseId = 0;
var _unhandledRejectionTimeout = 10;
var _aggregationError;
var _hasPromiseRejectionEvent;
function dumpFnObj(value) {
    if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isFunction)(value)) {
        return value.toString();
    }
    return (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.dumpObj)(value);
}
/*#__NO_SIDE_EFFECTS__*/
function _createAggregationError(values) {
    !_aggregationError && (_aggregationError = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.createCachedValue)((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.safe)(_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.getInst, ["AggregationError"]).v || (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.createCustomError)("AggregationError", function (self, args) {
        self.errors = args[0];
    })));
    return new _aggregationError.v(values);
}
function _createPromise(newPromise, processor, executor) {
    var additionalArgs = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrSlice)(arguments, 3);
    var _state = 0 ;
    var _hasResolved = false;
    var _settledValue;
    var _queue = [];
    var _id = _uniquePromiseId++;
    var _parentId = _currentPromiseId.length > 0 ? _currentPromiseId[_currentPromiseId.length - 1] : undefined;
    var _handled = false;
    var _unHandledRejectionHandler = null;
    var _thePromise;
    function _then(onResolved, onRejected) {
        try {
            _currentPromiseId.push(_id);
            _handled = true;
            _unHandledRejectionHandler && _unHandledRejectionHandler.cancel();
            _unHandledRejectionHandler = null;
            var thenPromise = newPromise(function (resolve, reject) {
                _queue.push(function () {
                    try {
                        var handler = _state === 2  ? onResolved : onRejected;
                        var value = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(handler) ? _settledValue : ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isFunction)(handler) ? handler(_settledValue) : handler);
                        if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isPromiseLike)(value)) {
                            value.then(resolve, reject);
                        }
                        else if (handler) {
                            resolve(value);
                        }
                        else if (_state === 3 ) {
                            reject(value);
                        }
                        else {
                            resolve(value);
                        }
                    }
                    catch (e) {
                        reject(e);
                    }
                });
                if (_hasResolved) {
                    _processQueue();
                }
            }, additionalArgs);
            return thenPromise;
        }
        finally {
            _currentPromiseId.pop();
        }
    }
    function _catch(onRejected) {
        return _then(undefined, onRejected);
    }
    function _finally(onFinally) {
        var thenFinally = onFinally;
        var catchFinally = onFinally;
        if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isFunction)(onFinally)) {
            thenFinally = function (value) {
                onFinally && onFinally();
                return value;
            };
            catchFinally = function (reason) {
                onFinally && onFinally();
                throw reason;
            };
        }
        return _then(thenFinally, catchFinally);
    }
    function _strState() {
        return STRING_STATES[_state];
    }
    function _processQueue() {
        if (_queue.length > 0) {
            var pending = _queue.slice();
            _queue = [];
            _handled = true;
            _unHandledRejectionHandler && _unHandledRejectionHandler.cancel();
            _unHandledRejectionHandler = null;
            processor(pending);
        }
    }
    function _createSettleIfFn(newState, allowState) {
        return function (theValue) {
            if (_state === allowState) {
                if (newState === 2  && (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isPromiseLike)(theValue)) {
                    _state = 1 ;
                    theValue.then(_createSettleIfFn(2 , 1 ), _createSettleIfFn(3 , 1 ));
                    return;
                }
                _state = newState;
                _hasResolved = true;
                _settledValue = theValue;
                _processQueue();
                if (!_handled && newState === 3  && !_unHandledRejectionHandler) {
                    _unHandledRejectionHandler = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.scheduleTimeout)(_notifyUnhandledRejection, _unhandledRejectionTimeout);
                }
            }
        };
    }
    function _notifyUnhandledRejection() {
        if (!_handled) {
            _handled = true;
            if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isNode)()) {
                process.emit(NODE_UNHANDLED_REJECTION, _settledValue, _thePromise);
            }
            else {
                var gbl = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.getWindow)() || (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.getGlobal)();
                !_hasPromiseRejectionEvent && (_hasPromiseRejectionEvent = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.createCachedValue)((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.safe)((_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.getInst), [STR_PROMISE + "RejectionEvent"]).v));
                emitEvent(gbl, UNHANDLED_REJECTION, function (theEvt) {
                    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objDefine)(theEvt, "promise", { g: function () { return _thePromise; } });
                    theEvt.reason = _settledValue;
                    return theEvt;
                }, !!_hasPromiseRejectionEvent.v);
            }
        }
    }
    _thePromise = {
        then: _then,
        "catch": _catch,
        finally: _finally
    };
    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objDefineProp)(_thePromise, "state", {
        get: _strState
    });
    if (_promiseDebugEnabled) {
        _addDebugState$1(_thePromise, _strState, function () { return (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objToString)(_settledValue); }, function () { return _handled; });
    }
    if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.hasSymbol)()) {
        _thePromise[(0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.getKnownSymbol)(11 )] = "IPromise";
    }
    function _toString() {
        return "IPromise" + (_promiseDebugEnabled ? "[" + _id + (!(0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(_parentId) ? (":" + _parentId) : "") + "]" : "") + " " + _strState() + (_hasResolved ? (" - " + dumpFnObj(_settledValue)) : "") + ("");
    }
    _thePromise.toString = _toString;
    (function _initialize() {
        if (!(0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isFunction)(executor)) {
            (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.throwTypeError)(STR_PROMISE + ": executor is not a function - " + dumpFnObj(executor));
        }
        var _rejectFn = _createSettleIfFn(3 , 0 );
        try {
            executor.call(_thePromise, _createSettleIfFn(2 , 0 ), _rejectFn);
        }
        catch (e) {
            _rejectFn(e);
        }
    })();
    return _thePromise;
}
/*#__NO_SIDE_EFFECTS__*/
function _createAllPromise(newPromise) {
    return function (input) {
        var additionalArgs = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrSlice)(arguments, 1);
        return newPromise(function (resolve, reject) {
            try {
                var values_1 = [];
                var pending_1 = 1;
                (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.iterForOf)(input, function (item, idx) {
                    if (item) {
                        pending_1++;
                        doAwait(item, function (value) {
                            values_1[idx] = value;
                            if (--pending_1 === 0) {
                                resolve(values_1);
                            }
                        }, reject);
                    }
                });
                pending_1--;
                if (pending_1 === 0) {
                    resolve(values_1);
                }
            }
            catch (e) {
                reject(e);
            }
        }, additionalArgs);
    };
}
/*#__NO_SIDE_EFFECTS__*/
function _createResolvedPromise(newPromise) {
    return function (value) {
        var additionalArgs = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrSlice)(arguments, 1);
        if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isPromiseLike)(value)) {
            return value;
        }
        return newPromise(function (resolve) {
            resolve(value);
        }, additionalArgs);
    };
}
/*#__NO_SIDE_EFFECTS__*/
function _createRejectedPromise(newPromise) {
    return function (reason) {
        var additionalArgs = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrSlice)(arguments, 1);
        return newPromise(function (_resolve, reject) {
            reject(reason);
        }, additionalArgs);
    };
}
/*#__NO_SIDE_EFFECTS__*/
function _createAllSettledPromise(newPromise) {
    return (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.createCachedValue)(function (input) {
        var additionalArgs = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrSlice)(arguments, 1);
        return newPromise(function (resolve, reject) {
            var values = [];
            var pending = 1;
            function processItem(item, idx) {
                pending++;
                doAwaitResponse(item, function (value) {
                    if (value.rejected) {
                        values[idx] = {
                            status: REJECTED,
                            reason: value.reason
                        };
                    }
                    else {
                        values[idx] = {
                            status: "fulfilled",
                            value: value.value
                        };
                    }
                    if (--pending === 0) {
                        resolve(values);
                    }
                });
            }
            try {
                if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isArray)(input)) {
                    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrForEach)(input, processItem);
                }
                else if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isIterable)(input)) {
                    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.iterForOf)(input, processItem);
                }
                else {
                    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.throwTypeError)("Input is not an iterable");
                }
                pending--;
                if (pending === 0) {
                    resolve(values);
                }
            }
            catch (e) {
                reject(e);
            }
        }, additionalArgs);
    });
}
/*#__NO_SIDE_EFFECTS__*/
function _createRacePromise(newPromise) {
    return (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.createCachedValue)(function (input) {
        var additionalArgs = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrSlice)(arguments, 1);
        return newPromise(function (resolve, reject) {
            var isDone = false;
            function processItem(item) {
                doAwaitResponse(item, function (value) {
                    if (!isDone) {
                        isDone = true;
                        if (value.rejected) {
                            reject(value.reason);
                        }
                        else {
                            resolve(value.value);
                        }
                    }
                });
            }
            try {
                if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isArray)(input)) {
                    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrForEach)(input, processItem);
                }
                else if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isIterable)(input)) {
                    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.iterForOf)(input, processItem);
                }
                else {
                    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.throwTypeError)("Input is not an iterable");
                }
            }
            catch (e) {
                reject(e);
            }
        }, additionalArgs);
    });
}
/*#__NO_SIDE_EFFECTS__*/
function _createAnyPromise(newPromise) {
    return (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.createCachedValue)(function (input) {
        var additionalArgs = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrSlice)(arguments, 1);
        return newPromise(function (resolve, reject) {
            var theErros = [];
            var pending = 1;
            var isDone = false;
            function processItem(item, idx) {
                pending++;
                doAwaitResponse(item, function (value) {
                    if (!value.rejected) {
                        isDone = true;
                        resolve(value.value);
                        return;
                    }
                    else {
                        theErros[idx] = value.reason;
                    }
                    if (--pending === 0 && !isDone) {
                        reject(_createAggregationError(theErros));
                    }
                });
            }
            try {
                if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isArray)(input)) {
                    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrForEach)(input, processItem);
                }
                else if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isIterable)(input)) {
                    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.iterForOf)(input, processItem);
                }
                else {
                    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.throwTypeError)("Input is not an iterable");
                }
                pending--;
                if (pending === 0 && !isDone) {
                    reject(_createAggregationError(theErros));
                }
            }
            catch (e) {
                reject(e);
            }
        }, additionalArgs);
    });
}

function syncItemProcessor(pending) {
    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrForEach)(pending, function (fn) {
        try {
            fn();
        }
        catch (e) {
        }
    });
}
function timeoutItemProcessor(timeout) {
    var callbackTimeout = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isNumber)(timeout) ? timeout : 0;
    return function (pending) {
        (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.scheduleTimeout)(function () {
            syncItemProcessor(pending);
        }, callbackTimeout);
    };
}
function idleItemProcessor(timeout) {
    var options;
    if (timeout >= 0) {
        options = {
            timeout: +timeout
        };
    }
    return function (pending) {
        (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.scheduleIdleCallback)(function (deadline) {
            syncItemProcessor(pending);
        }, options);
    };
}

var _allAsyncSettledCreator;
var _raceAsyncCreator;
var _anyAsyncCreator;
function createAsyncPromise(executor, timeout) {
    return _createPromise(createAsyncPromise, timeoutItemProcessor(timeout), executor, timeout);
}
var createAsyncAllPromise = /*#__PURE__*/ _createAllPromise(createAsyncPromise);
var createAsyncResolvedPromise = /*#__PURE__*/ _createResolvedPromise(createAsyncPromise);
var createAsyncRejectedPromise = /*#__PURE__*/ _createRejectedPromise(createAsyncPromise);
function createAsyncAllSettledPromise(input, timeout) {
    !_allAsyncSettledCreator && (_allAsyncSettledCreator = _createAllSettledPromise(createAsyncPromise));
    return _allAsyncSettledCreator.v(input, timeout);
}
function createAsyncRacePromise(values, timeout) {
    !_raceAsyncCreator && (_raceAsyncCreator = _createRacePromise(createAsyncPromise));
    return _raceAsyncCreator.v(values, timeout);
}
function createAsyncAnyPromise(values, timeout) {
    !_anyAsyncCreator && (_anyAsyncCreator = _createAnyPromise(createAsyncPromise));
    return _anyAsyncCreator.v(values, timeout);
}

var _promiseCls;
var _allCreator;
var _allNativeSettledCreator;
var _raceNativeCreator;
var _anyNativeCreator;
/*#__NO_SIDE_EFFECTS__*/
function _createNativePromiseHelper(name, func) {
    !_promiseCls && (_promiseCls = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.createCachedValue)(((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.safe)(_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.getInst, [STR_PROMISE]).v) || null));
    if (_promiseCls.v && _promiseCls.v[name]) {
        return (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.createCachedValue)(function (input, timeout) {
            return createNativePromise(function (resolve, reject) {
                _promiseCls.v[name](input).then(resolve, reject);
            });
        });
    }
    return func();
}
function createNativePromise(executor, timeout) {
    !_promiseCls && (_promiseCls = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.createCachedValue)(((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.safe)(_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.getInst, [STR_PROMISE]).v) || null));
    var PrmCls = _promiseCls.v;
    if (!PrmCls) {
        return createAsyncPromise(executor);
    }
    if (!(0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isFunction)(executor)) {
        (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.throwTypeError)(STR_PROMISE + ": executor is not a function - " + (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.dumpObj)(executor));
    }
    var _state = 0 ;
    function _strState() {
        return STRING_STATES[_state];
    }
    var thePromise = new PrmCls(function (resolve, reject) {
        function _resolve(value) {
            _state = 2 ;
            resolve(value);
        }
        function _reject(reason) {
            _state = 3 ;
            reject(reason);
        }
        executor(_resolve, _reject);
    });
    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objDefineProp)(thePromise, "state", {
        get: _strState
    });
    return thePromise;
}
function createNativeAllPromise(input, timeout) {
    !_allCreator && (_allCreator = _createNativePromiseHelper("all", function () { return (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.createCachedValue)(_createAllPromise(createNativePromise)); }));
    return _allCreator.v(input, timeout);
}
var createNativeResolvedPromise = /*#__PURE__*/ _createResolvedPromise(createNativePromise);
var createNativeRejectedPromise = /*#__PURE__*/ _createRejectedPromise(createNativePromise);
function createNativeAllSettledPromise(input, timeout) {
    !_allNativeSettledCreator && (_allNativeSettledCreator = _createNativePromiseHelper("allSettled", function () { return _createAllSettledPromise(createNativePromise); }));
    return _allNativeSettledCreator.v(input, timeout);
}
function createNativeRacePromise(values, timeout) {
    !_raceNativeCreator && (_raceNativeCreator = _createNativePromiseHelper("race", function () { return _createRacePromise(createNativePromise); }));
    return _raceNativeCreator.v(values, timeout);
}
function createNativeAnyPromise(values, timeout) {
    !_anyNativeCreator && (_anyNativeCreator = _createNativePromiseHelper("any", function () { return _createAnyPromise(createNativePromise); }));
    return _anyNativeCreator.v(values, timeout);
}

var _allSyncSettledCreator;
var _raceSyncCreator;
var _anySyncCreator;
function createSyncPromise(executor) {
    return _createPromise(createSyncPromise, syncItemProcessor, executor);
}
var createSyncAllPromise = /*#__PURE__*/ _createAllPromise(createSyncPromise);
var createSyncResolvedPromise = /*#__PURE__*/ _createResolvedPromise(createSyncPromise);
var createSyncRejectedPromise = /*#__PURE__*/ _createRejectedPromise(createSyncPromise);
function createSyncAllSettledPromise(input, timeout) {
    !_allSyncSettledCreator && (_allSyncSettledCreator = _createAllSettledPromise(createSyncPromise));
    return _allSyncSettledCreator.v(input, timeout);
}
function createSyncRacePromise(values, timeout) {
    !_raceSyncCreator && (_raceSyncCreator = _createRacePromise(createSyncPromise));
    return _raceSyncCreator.v(values, timeout);
}
function createSyncAnyPromise(values, timeout) {
    !_anySyncCreator && (_anySyncCreator = _createAnyPromise(createSyncPromise));
    return _anySyncCreator.v(values, timeout);
}

var _defaultIdleTimeout;
var _allIdleSettledCreator;
var _raceIdleCreator;
var _anyIdleCreator;
function setDefaultIdlePromiseTimeout(idleDeadline) {
    _defaultIdleTimeout = idleDeadline;
}
var setDefaultIdleTimeout = ( setDefaultIdlePromiseTimeout);
function createIdlePromise(executor, timeout) {
    var theTimeout = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(timeout) ? _defaultIdleTimeout : timeout;
    return _createPromise(createIdlePromise, idleItemProcessor(theTimeout), executor, theTimeout);
}
var createIdleAllPromise = /*#__PURE__*/ _createAllPromise(createIdlePromise);
var createIdleResolvedPromise = /*#__PURE__*/ _createResolvedPromise(createIdlePromise);
var createIdleRejectedPromise = /*#__PURE__*/ _createRejectedPromise(createIdlePromise);
function createIdleAllSettledPromise(input, timeout) {
    !_allIdleSettledCreator && (_allIdleSettledCreator = _createAllSettledPromise(createIdlePromise));
    return _allIdleSettledCreator.v(input, timeout);
}
function createIdleRacePromise(values, timeout) {
    !_raceIdleCreator && (_raceIdleCreator = _createRacePromise(createIdlePromise));
    return _raceIdleCreator.v(values, timeout);
}
function createIdleAnyPromise(values, timeout) {
    !_anyIdleCreator && (_anyIdleCreator = _createAnyPromise(createIdlePromise));
    return _anyIdleCreator.v(values, timeout);
}

var _promiseCreator;
var _allSettledCreator;
var _raceCreator;
var _anyCreator;
function setCreatePromiseImpl(creator) {
    _promiseCreator = creator ? (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.createCachedValue)(creator) : null;
}
function createPromise(executor, timeout) {
    !_promiseCreator && (_promiseCreator = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.createCachedValue)(createNativePromise));
    return _promiseCreator.v.call(this, executor, timeout);
}
var createAllPromise = /*#__PURE__*/ _createAllPromise(createPromise);
var createResolvedPromise = /*#__PURE__*/ _createResolvedPromise(createPromise);
var createRejectedPromise = /*#__PURE__*/ _createRejectedPromise(createPromise);
function createAllSettledPromise(input, timeout) {
    !_allSettledCreator && (_allSettledCreator = _createAllSettledPromise(createPromise));
    return _allSettledCreator.v(input, timeout);
}
function createRacePromise(values, timeout) {
    !_raceCreator && (_raceCreator = _createRacePromise(createPromise));
    return _raceCreator.v(values, timeout);
}
function createAnyPromise(values, timeout) {
    !_anyCreator && (_anyCreator = _createAnyPromise(createPromise));
    return _anyCreator.v(values, timeout);
}

function createTimeoutPromise(timeout, resolveReject, message) {
    return createPromise(function (resolve, reject) {
        (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.scheduleTimeout)(function () {
            (resolveReject ? resolve : reject)(!(0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(message) ? message : "Timeout of " + timeout + "ms exceeded");
        }, timeout);
    });
}

function _doneChk(isDone, state, value, thisArg) {
    var result = isDone;
    state.res = value;
    if (!result) {
        if (state.isDone && (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isFunction)(state.isDone)) {
            return doAwait(state.isDone.call(thisArg, state), function (done) {
                state.iter++;
                return !!done;
            });
        }
        else {
            result = !!state.isDone;
        }
    }
    state.iter++;
    return result;
}
function doWhileAsync(callbackFn, isDoneFn, thisArg) {
    var promise;
    var resolve;
    var reject = function (reason) {
        isDone = true;
        throw reason;
    };
    var isDone = false;
    var state = {
        st: (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.utcNow)(),
        iter: 0,
        isDone: isDoneFn || false
    };
    if (callbackFn) {
        var _createPromise_1 = function () {
            return createPromise(function (res, rej) {
                resolve = res;
                reject = rej;
            });
        };
        var _handleAsyncDone_1 = function (done) {
            isDone = !!done;
            if (!isDone) {
                _processNext_1();
            }
            else {
                resolve(state.res);
            }
        };
        var _processNext_1 = function () {
            while (!isDone) {
                try {
                    var cbResult = callbackFn.call(thisArg, state);
                    if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isPromiseLike)(cbResult)) {
                        promise = promise || _createPromise_1();
                        doAwait(cbResult, function (res) {
                            try {
                                doAwait(_doneChk(isDone, state, res, thisArg), _handleAsyncDone_1, reject);
                            }
                            catch (e) {
                                reject(e);
                            }
                        }, reject);
                        return promise;
                    }
                    else {
                        var dnRes = _doneChk(isDone, state, cbResult, thisArg);
                        if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isPromiseLike)(dnRes)) {
                            promise = promise || _createPromise_1();
                            doAwait(dnRes, _handleAsyncDone_1, reject);
                            return promise;
                        }
                        else {
                            isDone = !!dnRes;
                        }
                    }
                }
                catch (e) {
                    reject(e);
                    return promise;
                }
            }
            if (isDone && resolve) {
                resolve(state.res);
            }
            return promise || state.res;
        };
        return _processNext_1();
    }
}

function arrForEachAsync(theArray, callbackFn, thisArg) {
    if (theArray) {
        var len_1 = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.getLength)(theArray);
        if (len_1) {
            var isDone = function (state) {
                if (state.iter >= len_1 || state.res === -1) {
                    return true;
                }
            };
            return doWhileAsync(function (state) {
                var idx = state.iter;
                if (idx in theArray) {
                    return callbackFn.call(thisArg || theArray, theArray[idx], idx, theArray);
                }
            }, isDone);
        }
    }
}

var _iterSymbol;
var _iterAsyncSymbol;
function iterForOfAsync(iter, callbackFn, thisArg) {
    var err;
    var iterResult;
    var theIter = iter;
    function onFailed(failed) {
        err = { e: failed };
        if (theIter.throw) {
            iterResult = null;
            theIter.throw(err);
        }
        throw failed;
    }
    function onFinally() {
        try {
            if (iterResult && !iterResult[DONE]) {
                theIter[RETURN] && theIter[RETURN](iterResult);
            }
        }
        finally {
            if (err) {
                throw err.e;
            }
        }
    }
    if (iter) {
        if (!(0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isIterator)(iter)) {
            !_iterAsyncSymbol && (_iterAsyncSymbol = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.createCachedValue)((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.getKnownSymbol)(0 )));
            theIter = iter[_iterAsyncSymbol.v] ? iter[_iterAsyncSymbol.v]() : null;
            if (!theIter) {
                !_iterSymbol && (_iterSymbol = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.createCachedValue)((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.getKnownSymbol)(3 )));
                theIter = iter[_iterSymbol.v] ? iter[_iterSymbol.v]() : null;
            }
        }
        if (theIter && (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isIterator)(theIter)) {
            var result = void 0;
            try {
                result = doWhileAsync(function (state) {
                    return doAwait(theIter.next(), function (res) {
                        iterResult = res;
                        if (!res[DONE]) {
                            return (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.fnCall)(callbackFn, thisArg || theIter, iterResult[VALUE], state.iter, theIter);
                        }
                    }, function (reason) {
                        state.isDone = true;
                        onFailed(reason);
                    });
                }, function (state) {
                    if (!iterResult || iterResult[DONE] || state.res === -1) {
                        onFinally();
                        return true;
                    }
                }, thisArg || theIter);
                if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isPromiseLike)(result)) {
                    result = doFinally(result.catch(onFailed), onFinally);
                }
                return result;
            }
            catch (failed) {
                onFailed(failed);
            }
            finally {
                if (result && !(0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isPromiseLike)(result)) {
                    onFinally();
                }
            }
        }
    }
}

var REJECT = "reject";
var REJECTED_ERROR = "Rejected";
var _schedulerId = 0;
var _debugName;
var _debugIntState;
var _customErrors = {};
function _rejectDone() {
}
function _createError(type, evt, message) {
    !_customErrors[type] && (_customErrors[type] = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.createCustomError)(type));
    var now = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.utcNow)();
    return new (_customErrors[type])("Task [".concat(evt.id, "] ").concat(message || "", "- ").concat((evt.st ? "Running" : "Waiting"), ": ").concat(_calcTime(now, evt.st || evt.cr)));
}
function _calcTime(now, start) {
    return ((now - start) || "0") + " ms";
}
function _abortStaleTasks(taskQueue, staleTimeoutPeriod) {
    var now = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.utcNow)();
    var expired = now - staleTimeoutPeriod;
    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrForEach)(taskQueue, function (evt) {
        if (evt && !evt.rj && (evt.st && evt.st < expired) || (!evt.st && evt.cr && evt.cr < expired)) {
            evt && evt[REJECT](evt.rj || _createError("Aborted", evt, "Stale "));
        }
    });
}
function _removeTask(queue, taskDetail) {
    var idx = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrIndexOf)(queue, taskDetail);
    if (idx !== -1) {
        queue.splice(idx, 1);
    }
}
function _addDebugState(theScheduler, nameFn, stateFn) {
    _debugName = _debugName || { toString: function () { return "[[SchedulerName]]"; } };
    _debugIntState = _debugIntState || { toString: function () { return "[[SchedulerState]]"; } };
    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objDefineProp)(theScheduler, _debugName, { get: nameFn });
    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objDefineProp)(theScheduler, _debugIntState, { get: stateFn });
}
function createTaskScheduler(newPromise, name) {
    var _theTask;
    var _running = [];
    var _waiting = [];
    var _staleTimeoutPeriod = 600000;
    var _staleTimeoutCheckPeriod = _staleTimeoutPeriod / 10;
    var _taskCount = 0;
    var _schedulerName = (name ? (name + ".") : "") + _schedulerId++;
    var _blockedTimer;
    newPromise = newPromise || createPromise;
    var _startBlockedTimer = function () {
        var hasTasks = ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.getLength)(_running) + (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.getLength)(_waiting)) > 0;
        if (_staleTimeoutPeriod > 0) {
            if (!_blockedTimer) {
                _blockedTimer = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.scheduleTimeout)(function () {
                    _abortStaleTasks(_running, _staleTimeoutPeriod);
                    _abortStaleTasks(_waiting, _staleTimeoutPeriod);
                    _blockedTimer && (_blockedTimer.enabled = (((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.getLength)(_running) + (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.getLength)(_waiting)) > 0));
                }, _staleTimeoutCheckPeriod);
                _blockedTimer.unref();
            }
            _blockedTimer && (_blockedTimer.enabled = hasTasks);
        }
    };
    var _queueTask = function (startAction, taskName, timeout) {
        var _a;
        var taskId = _schedulerName + "." + _taskCount++;
        if (taskName) {
            taskId += "-(" + taskName + ")";
        }
        var newTask = (_a = {
                id: taskId,
                cr: (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.utcNow)(),
                to: timeout
            },
            _a[REJECT] = function (reason) {
                newTask.rj = reason || _createError(REJECTED_ERROR, newTask);
                newTask[REJECT] = _rejectDone;
            },
            _a);
        if (!_theTask) {
            newTask.p = newPromise(_runTask(newTask, startAction));
        }
        else {
            newTask.p = _waitForPreviousTask(newTask, _theTask, startAction);
        }
        _theTask = newTask;
        return newTask.p;
    };
    var _runTask = function (taskDetail, startAction) {
        taskDetail.st = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.utcNow)();
        _running.push(taskDetail);
        _startBlockedTimer();
        return function (onTaskResolve, onTaskReject) {
            var _promiseReject = function (reason) {
                taskDetail.rj = taskDetail.rj || reason || _createError(REJECTED_ERROR, taskDetail);
                taskDetail[REJECT] = _rejectDone;
                _doCleanup(taskDetail);
                onTaskResolve = null;
                onTaskReject && onTaskReject(reason);
                onTaskReject = null;
            };
            var taskId = taskDetail.id;
            if (taskDetail.rj) {
                _promiseReject(taskDetail.rj);
            }
            else {
                taskDetail[REJECT] = _promiseReject;
                try {
                    var startResult = startAction(taskId);
                    if (taskDetail.to && (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isPromiseLike)(startResult)) {
                        taskDetail.t = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.scheduleTimeout)(function () {
                            _promiseReject(_createError("Timeout", taskDetail));
                        }, taskDetail.to);
                    }
                    doAwait(startResult, function (theResult) {
                        _doCleanup(taskDetail);
                        try {
                            onTaskResolve && onTaskResolve(theResult);
                        }
                        catch (e) {
                            onTaskReject && onTaskReject(e);
                        }
                        onTaskReject = null;
                        onTaskResolve = null;
                    }, _promiseReject);
                }
                catch (e) {
                    _promiseReject(e);
                }
            }
        };
    };
    var _waitForPreviousTask = function (taskDetail, prevTask, startAction) {
        _waiting.push(taskDetail);
        _startBlockedTimer();
        return newPromise(function (onWaitResolve, onWaitReject) {
            doAwaitResponse(prevTask.p, function () {
                _removeTask(_waiting, taskDetail);
                _runTask(taskDetail, startAction)(onWaitResolve, onWaitReject);
            });
        });
    };
    var _doCleanup = function (taskDetail) {
        _removeTask(_running, taskDetail);
        taskDetail.t && taskDetail.t.cancel();
        taskDetail.t = null;
        if (_theTask && _theTask === taskDetail) {
            _theTask = null;
            if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.getLength)(_running) + (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.getLength)(_waiting) === 0) {
                _blockedTimer && _blockedTimer.cancel();
                _blockedTimer = null;
            }
        }
    };
    var theScheduler = {
        idle: true,
        queue: _queueTask,
        setStaleTimeout: function (staleTimeout, staleCheckPeriod) {
            _blockedTimer && _blockedTimer.cancel();
            _blockedTimer = null;
            _staleTimeoutPeriod = staleTimeout;
            _staleTimeoutCheckPeriod = staleCheckPeriod || staleTimeout / 10;
            _startBlockedTimer();
        }
    };
    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objDefine)(theScheduler, "idle", {
        g: function () {
            return (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.getLength)(_running) + (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.getLength)(_waiting) === 0;
        }
    });
    _addDebugState(theScheduler, function () { return _schedulerName; }, function () {
        return {
            l: _theTask,
            r: _running,
            w: _waiting
        };
    });
    return theScheduler;
}

var toStringTagSymbol = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.getKnownSymbol)(11 );
var PolyPromise = /*#__PURE__*/ (function () {
    function PolyPromiseImpl(executor) {
        this._$ = createAsyncPromise(executor);
        if (toStringTagSymbol) {
            this[toStringTagSymbol] = "Promise";
        }
        (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objDefineProp)(this, "state", {
            get: function () {
                return this._$.state;
            }
        });
    }
    PolyPromiseImpl.all = createAsyncAllPromise;
    PolyPromiseImpl.race = createAsyncRacePromise;
    PolyPromiseImpl.any = createAsyncAnyPromise;
    PolyPromiseImpl.reject = createAsyncRejectedPromise;
    PolyPromiseImpl.resolve = createAsyncResolvedPromise;
    PolyPromiseImpl.allSettled = createAsyncAllSettledPromise;
    var theProto = PolyPromiseImpl.prototype;
    theProto.then = function (onResolved, onRejected) {
        return this._$.then(onResolved, onRejected);
    };
    theProto.catch = function (onRejected) {
        return this._$.catch(onRejected);
    };
    theProto.finally = function (onfinally) {
        return this._$.finally(onfinally);
    };
    return PolyPromiseImpl;
}());


//# sourceMappingURL=ts-async.js.map


/***/ }),
/* 57 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NotificationManager": () => (/* binding */ NotificationManager)
/* harmony export */ });
/* harmony import */ var _microsoft_dynamicproto_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(35);
/* harmony import */ var _nevware21_ts_async__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(56);
/* harmony import */ var _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(30);
/* harmony import */ var _Config_DynamicConfig__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(40);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(38);
/* harmony import */ var _InternalConstants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(39);
/*
 * Application Insights JavaScript SDK - Core, 3.3.0
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */








var defaultValues = {
    perfEvtsSendAll: false
};
function _runScheduledListeners(asyncNotifications) {
    asyncNotifications.h = null;
    var callbacks = asyncNotifications.cb;
    asyncNotifications.cb = [];
    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrForEach)(callbacks, function (cb) {
        // Run the listener in a try-catch to ensure that a single listener failing doesn't prevent the others from running
        (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.safe)(cb.fn, [cb.arg]);
    });
}
// This function is used to combine the logic of running the listeners and handling the async notifications so that they don't
// create multiple timers if there are multiple async listeners.
function _runListeners(listeners, name, asyncNotifications, callback) {
    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrForEach)(listeners, function (listener) {
        if (listener && listener[name]) {
            if (asyncNotifications) {
                // Schedule the callback to be called after the current call stack has cleared.
                asyncNotifications.cb[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_PUSH /* @min:%2epush */]({
                    fn: callback,
                    arg: listener
                });
                asyncNotifications.h = asyncNotifications.h || (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.scheduleTimeout)(_runScheduledListeners, 0, asyncNotifications);
            }
            else {
                // Run the listener in a try-catch to ensure that a single listener failing doesn't prevent the others from running
                (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.safe)(callback, [listener]);
            }
        }
    });
}
/**
 * Class to manage sending notifications to all the listeners.
 */
var NotificationManager = /** @class */ (function () {
    function NotificationManager(config) {
        this.listeners = [];
        var perfEvtsSendAll;
        var unloadHandler;
        var _listeners = [];
        var _asyncNotifications = {
            h: null,
            cb: []
        };
        var cfgHandler = (0,_Config_DynamicConfig__WEBPACK_IMPORTED_MODULE_2__.createDynamicConfig)(config, defaultValues);
        unloadHandler = cfgHandler[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_WATCH /* @min:%2ewatch */](function (details) {
            perfEvtsSendAll = !!details.cfg.perfEvtsSendAll;
        });
        (0,_microsoft_dynamicproto_js__WEBPACK_IMPORTED_MODULE_3__["default"])(NotificationManager, this, function (_self) {
            (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objDefine)(_self, "listeners", {
                g: function () { return _listeners; }
            });
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_ADD_NOTIFICATION_LIS1 /* @min:%2eaddNotificationListener */] = function (listener) {
                _listeners[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_PUSH /* @min:%2epush */](listener);
            };
            /**
             * Removes all instances of the listener.
             * @param listener - AWTNotificationListener to remove.
             */
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_REMOVE_NOTIFICATION_0 /* @min:%2eremoveNotificationListener */] = function (listener) {
                var index = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrIndexOf)(_listeners, listener);
                while (index > -1) {
                    _listeners[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_SPLICE /* @min:%2esplice */](index, 1);
                    index = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrIndexOf)(_listeners, listener);
                }
            };
            /**
             * Notification for events sent.
             * @param events - The array of events that have been sent.
             */
            _self[_InternalConstants__WEBPACK_IMPORTED_MODULE_4__.STR_EVENTS_SENT /* @min:%2eeventsSent */] = function (events) {
                _runListeners(_listeners, _InternalConstants__WEBPACK_IMPORTED_MODULE_4__.STR_EVENTS_SENT, _asyncNotifications, function (listener) {
                    listener[_InternalConstants__WEBPACK_IMPORTED_MODULE_4__.STR_EVENTS_SENT /* @min:%2eeventsSent */](events);
                });
            };
            /**
             * Notification for events being discarded.
             * @param events - The array of events that have been discarded by the SDK.
             * @param reason - The reason for which the SDK discarded the events. The EventsDiscardedReason
             * constant should be used to check the different values.
             */
            _self[_InternalConstants__WEBPACK_IMPORTED_MODULE_4__.STR_EVENTS_DISCARDED /* @min:%2eeventsDiscarded */] = function (events, reason) {
                _runListeners(_listeners, _InternalConstants__WEBPACK_IMPORTED_MODULE_4__.STR_EVENTS_DISCARDED, _asyncNotifications, function (listener) {
                    listener[_InternalConstants__WEBPACK_IMPORTED_MODULE_4__.STR_EVENTS_DISCARDED /* @min:%2eeventsDiscarded */](events, reason);
                });
            };
            /**
             * [Optional] A function called when the events have been requested to be sent to the sever.
             * @param sendReason - The reason why the event batch is being sent.
             * @param isAsync - A flag which identifies whether the requests are being sent in an async or sync manner.
             */
            _self[_InternalConstants__WEBPACK_IMPORTED_MODULE_4__.STR_EVENTS_SEND_REQUEST /* @min:%2eeventsSendRequest */] = function (sendReason, isAsync) {
                _runListeners(_listeners, _InternalConstants__WEBPACK_IMPORTED_MODULE_4__.STR_EVENTS_SEND_REQUEST, isAsync ? _asyncNotifications : null, function (listener) {
                    listener[_InternalConstants__WEBPACK_IMPORTED_MODULE_4__.STR_EVENTS_SEND_REQUEST /* @min:%2eeventsSendRequest */](sendReason, isAsync);
                });
            };
            _self[_InternalConstants__WEBPACK_IMPORTED_MODULE_4__.STR_PERF_EVENT /* @min:%2eperfEvent */] = function (perfEvent) {
                if (perfEvent) {
                    // Send all events or only parent events
                    if (perfEvtsSendAll || !perfEvent[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_IS_CHILD_EVT /* @min:%2eisChildEvt */]()) {
                        _runListeners(_listeners, _InternalConstants__WEBPACK_IMPORTED_MODULE_4__.STR_PERF_EVENT, null, function (listener) {
                            if (perfEvent[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_IS_ASYNC /* @min:%2eisAsync */]) {
                                (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.scheduleTimeout)(function () { return listener[_InternalConstants__WEBPACK_IMPORTED_MODULE_4__.STR_PERF_EVENT /* @min:%2eperfEvent */](perfEvent); }, 0);
                            }
                            else {
                                listener[_InternalConstants__WEBPACK_IMPORTED_MODULE_4__.STR_PERF_EVENT /* @min:%2eperfEvent */](perfEvent);
                            }
                        });
                    }
                }
            };
            _self[_InternalConstants__WEBPACK_IMPORTED_MODULE_4__.STR_OFFLINE_STORE /* @min:%2eofflineEventsStored */] = function (events) {
                if (events && events[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LENGTH /* @min:%2elength */]) {
                    _runListeners(_listeners, _InternalConstants__WEBPACK_IMPORTED_MODULE_4__.STR_OFFLINE_STORE, _asyncNotifications, function (listener) {
                        listener[_InternalConstants__WEBPACK_IMPORTED_MODULE_4__.STR_OFFLINE_STORE /* @min:%2eofflineEventsStored */](events);
                    });
                }
            };
            _self[_InternalConstants__WEBPACK_IMPORTED_MODULE_4__.STR_OFFLINE_SENT /* @min:%2eofflineBatchSent */] = function (batch) {
                if (batch && batch[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_DATA /* @min:%2edata */]) {
                    _runListeners(_listeners, _InternalConstants__WEBPACK_IMPORTED_MODULE_4__.STR_OFFLINE_SENT, _asyncNotifications, function (listener) {
                        listener[_InternalConstants__WEBPACK_IMPORTED_MODULE_4__.STR_OFFLINE_SENT /* @min:%2eofflineBatchSent */](batch);
                    });
                }
            };
            _self[_InternalConstants__WEBPACK_IMPORTED_MODULE_4__.STR_OFFLINE_DROP /* @min:%2eofflineBatchDrop */] = function (cnt, reason) {
                if (cnt > 0) {
                    var rn_1 = reason || 0; // default is unknown
                    _runListeners(_listeners, _InternalConstants__WEBPACK_IMPORTED_MODULE_4__.STR_OFFLINE_DROP, _asyncNotifications, function (listener) {
                        listener[_InternalConstants__WEBPACK_IMPORTED_MODULE_4__.STR_OFFLINE_DROP /* @min:%2eofflineBatchDrop */](cnt, rn_1);
                    });
                }
            };
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_UNLOAD /* @min:%2eunload */] = function (isAsync) {
                var _finishUnload = function () {
                    unloadHandler && unloadHandler.rm();
                    unloadHandler = null;
                    _listeners = [];
                    // Clear any async listener
                    _asyncNotifications.h && _asyncNotifications.h[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_CANCEL /* @min:%2ecancel */]();
                    _asyncNotifications.h = null;
                    _asyncNotifications.cb = [];
                };
                var waiting;
                _runListeners(_listeners, "unload", null, function (listener) {
                    var asyncUnload = listener[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_UNLOAD /* @min:%2eunload */](isAsync);
                    if (asyncUnload) {
                        if (!waiting) {
                            waiting = [];
                        }
                        waiting[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_PUSH /* @min:%2epush */](asyncUnload);
                    }
                });
                if (waiting) {
                    return (0,_nevware21_ts_async__WEBPACK_IMPORTED_MODULE_5__.createPromise)(function (resolve) {
                        return (0,_nevware21_ts_async__WEBPACK_IMPORTED_MODULE_5__.doAwaitResponse)((0,_nevware21_ts_async__WEBPACK_IMPORTED_MODULE_5__.createAllPromise)(waiting), function () {
                            _finishUnload();
                            resolve();
                        });
                    });
                }
                else {
                    _finishUnload();
                }
            };
        });
    }
// Removed Stub for NotificationManager.prototype.addNotificationListener.
// Removed Stub for NotificationManager.prototype.removeNotificationListener.
// Removed Stub for NotificationManager.prototype.eventsSent.
// Removed Stub for NotificationManager.prototype.eventsDiscarded.
// Removed Stub for NotificationManager.prototype.eventsSendRequest.
// Removed Stub for NotificationManager.prototype.perfEvent.
// Removed Stub for NotificationManager.prototype.unload.
// Removed Stub for NotificationManager.prototype.offlineEventsStored.
// Removed Stub for NotificationManager.prototype.offlineBatchSent.
// Removed Stub for NotificationManager.prototype.offlineBatchDrop.
    // This is a workaround for an IE bug when using dynamicProto() with classes that don't have any
    // non-dynamic functions or static properties/functions when using uglify-js to minify the resulting code.
    NotificationManager.__ieDyn=1;

    return NotificationManager;
}());

//# sourceMappingURL=NotificationManager.js.map

/***/ }),
/* 58 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "areCookiesSupported": () => (/* binding */ areCookiesSupported),
/* harmony export */   "createCookieMgr": () => (/* binding */ createCookieMgr),
/* harmony export */   "safeGetCookieMgr": () => (/* binding */ safeGetCookieMgr),
/* harmony export */   "uaDisallowsSameSiteNone": () => (/* binding */ uaDisallowsSameSiteNone)
/* harmony export */ });
/* harmony import */ var _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(30);
/* harmony import */ var _Config_ConfigDefaultHelpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(59);
/* harmony import */ var _Config_DynamicConfig__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(40);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(38);
/* harmony import */ var _DiagnosticLogger__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(50);
/* harmony import */ var _EnvUtils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(44);
/* harmony import */ var _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(45);
/* harmony import */ var _InternalConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(39);
/*
 * Application Insights JavaScript SDK - Core, 3.3.0
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */
var _a, _b;








var strToGMTString = "toGMTString";
var strToUTCString = "toUTCString";
var strCookie = "cookie";
var strExpires = "expires";
var strIsCookieUseDisabled = "isCookieUseDisabled";
var strDisableCookiesUsage = "disableCookiesUsage";
var strConfigCookieMgr = "_ckMgr";
var _supportsCookies = null;
var _allowUaSameSite = null;
var _parsedCookieValue = null;
var _doc;
var _cookieCache = {};
var _globalCookieConfig = {};
// // `isCookieUseDisabled` is deprecated, so explicitly casting as a key of IConfiguration to avoid typing error
// // when both isCookieUseDisabled and disableCookiesUsage are used disableCookiesUsage will take precedent, which is
// // why its listed first
/**
 * Set the supported dynamic config values as undefined (or an empty object) so that
 * any listeners will be informed of any changes.
 * Explicitly NOT including the deprecated `isCookieUseDisabled` as we don't want to support
 * the v1 deprecated field as dynamic for updates
 */
var rootDefaultConfig = (_a = {
        cookieCfg: (0,_Config_ConfigDefaultHelpers__WEBPACK_IMPORTED_MODULE_0__.cfgDfMerge)((_b = {},
            _b[_InternalConstants__WEBPACK_IMPORTED_MODULE_1__.STR_DOMAIN] = { fb: "cookieDomain", dfVal: _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.isNotNullOrUndefined },
            _b.path = { fb: "cookiePath", dfVal: _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.isNotNullOrUndefined },
            _b.enabled = _InternalConstants__WEBPACK_IMPORTED_MODULE_1__.UNDEFINED_VALUE,
            _b.ignoreCookies = _InternalConstants__WEBPACK_IMPORTED_MODULE_1__.UNDEFINED_VALUE,
            _b.blockedCookies = _InternalConstants__WEBPACK_IMPORTED_MODULE_1__.UNDEFINED_VALUE,
            _b)),
        cookieDomain: _InternalConstants__WEBPACK_IMPORTED_MODULE_1__.UNDEFINED_VALUE,
        cookiePath: _InternalConstants__WEBPACK_IMPORTED_MODULE_1__.UNDEFINED_VALUE
    },
    _a[strDisableCookiesUsage] = _InternalConstants__WEBPACK_IMPORTED_MODULE_1__.UNDEFINED_VALUE,
    _a);
function _getDoc() {
    !_doc && (_doc = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.getLazy)(function () { return (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.getDocument)(); }));
}
/**
 * @ignore
 * DO NOT USE or export from the module, this is exposed as public to support backward compatibility of previous static utility methods only.
 * If you want to manager cookies either use the ICookieMgr available from the core instance via getCookieMgr() or create
 * your own instance of the CookieMgr and use that.
 * Using this directly for enabling / disabling cookie handling will not only affect your usage but EVERY user of cookies.
 * Example, if you are using a shared component that is also using Application Insights you will affect their cookie handling.
 * @param logger - The DiagnosticLogger to use for reporting errors.
 */
function _gblCookieMgr(config, logger) {
    // Stash the global instance against the BaseCookieMgr class
    var inst = createCookieMgr[strConfigCookieMgr] || _globalCookieConfig[strConfigCookieMgr];
    if (!inst) {
        // Note: not using the getSetValue() helper as that would require always creating a temporary cookieMgr
        // that ultimately is never used
        inst = createCookieMgr[strConfigCookieMgr] = createCookieMgr(config, logger);
        _globalCookieConfig[strConfigCookieMgr] = inst;
    }
    return inst;
}
function _isMgrEnabled(cookieMgr) {
    if (cookieMgr) {
        return cookieMgr.isEnabled();
    }
    return true;
}
function _isIgnoredCookie(cookieMgrCfg, name) {
    if (name && cookieMgrCfg && (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.isArray)(cookieMgrCfg.ignoreCookies)) {
        return (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.arrIndexOf)(cookieMgrCfg.ignoreCookies, name) !== -1;
    }
    return false;
}
function _isBlockedCookie(cookieMgrCfg, name) {
    if (name && cookieMgrCfg && (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.isArray)(cookieMgrCfg.blockedCookies)) {
        if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.arrIndexOf)(cookieMgrCfg.blockedCookies, name) !== -1) {
            return true;
        }
    }
    return _isIgnoredCookie(cookieMgrCfg, name);
}
function _isCfgEnabled(rootConfig, cookieMgrConfig) {
    var isCfgEnabled = cookieMgrConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__._DYN_ENABLED /* @min:%2eenabled */];
    if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.isNullOrUndefined)(isCfgEnabled)) {
        // Set the enabled from the provided setting or the legacy root values
        var cookieEnabled = void 0;
        // This field is deprecated and dynamic updates will not be fully supported
        if (!(0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.isUndefined)(rootConfig[strIsCookieUseDisabled])) {
            cookieEnabled = !rootConfig[strIsCookieUseDisabled];
        }
        // If this value is defined it takes precedent over the above
        if (!(0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.isUndefined)(rootConfig[strDisableCookiesUsage])) {
            cookieEnabled = !rootConfig[strDisableCookiesUsage];
        }
        // Not setting the cookieMgrConfig.enabled as that will update (set) the global dynamic config
        // So future "updates" then may not be as expected
        isCfgEnabled = cookieEnabled;
    }
    return isCfgEnabled;
}
/**
 * Helper to return the ICookieMgr from the core (if not null/undefined) or a default implementation
 * associated with the configuration or a legacy default.
 * @param core
 * @param config
 * @returns
 */
function safeGetCookieMgr(core, config) {
    var cookieMgr;
    if (core) {
        // Always returns an instance
        cookieMgr = core.getCookieMgr();
    }
    else if (config) {
        var cookieCfg = config.cookieCfg;
        if (cookieCfg && cookieCfg[strConfigCookieMgr]) {
            cookieMgr = cookieCfg[strConfigCookieMgr];
        }
        else {
            cookieMgr = createCookieMgr(config);
        }
    }
    if (!cookieMgr) {
        // Get or initialize the default global (legacy) cookie manager if we couldn't find one
        cookieMgr = _gblCookieMgr(config, (core || {})[_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__._DYN_LOGGER /* @min:%2elogger */]);
    }
    return cookieMgr;
}
function createCookieMgr(rootConfig, logger) {
    var _a;
    var cookieMgrConfig;
    var _path;
    var _domain;
    var unloadHandler;
    // Explicitly checking against false, so that setting to undefined will === true
    var _enabled;
    var _getCookieFn;
    var _setCookieFn;
    var _delCookieFn;
    // Make sure the root config is dynamic as it may be the global config
    rootConfig = (0,_Config_DynamicConfig__WEBPACK_IMPORTED_MODULE_5__.createDynamicConfig)(rootConfig || _globalCookieConfig, null, logger).cfg;
    // Will get recalled if the referenced configuration is changed
    unloadHandler = (0,_Config_DynamicConfig__WEBPACK_IMPORTED_MODULE_5__.onConfigChange)(rootConfig, function (details) {
        // Make sure the root config has all of the the defaults to the root config to ensure they are dynamic
        details[_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__._DYN_SET_DF /* @min:%2esetDf */](details.cfg, rootDefaultConfig);
        // Create and apply the defaults to the cookieCfg element
        cookieMgrConfig = details.ref(details.cfg, "cookieCfg"); // details.setDf(details.cfg.cookieCfg, defaultConfig);
        _path = cookieMgrConfig[_InternalConstants__WEBPACK_IMPORTED_MODULE_1__.STR_PATH /* @min:%2epath */] || "/";
        _domain = cookieMgrConfig[_InternalConstants__WEBPACK_IMPORTED_MODULE_1__.STR_DOMAIN /* @min:%2edomain */];
        // Explicitly checking against false, so that setting to undefined will === true
        _enabled = _isCfgEnabled(rootConfig, cookieMgrConfig) !== false;
        _getCookieFn = cookieMgrConfig.getCookie || _getCookieValue;
        _setCookieFn = cookieMgrConfig.setCookie || _setCookieValue;
        _delCookieFn = cookieMgrConfig.delCookie || _setCookieValue;
    }, logger);
    var cookieMgr = (_a = {
            isEnabled: function () {
                var enabled = _isCfgEnabled(rootConfig, cookieMgrConfig) !== false && _enabled && areCookiesSupported(logger);
                // Using an indirect lookup for any global cookie manager to support tree shaking for SDK's
                // that don't use the "applicationinsights-core" version of the default cookie function
                var gblManager = _globalCookieConfig[strConfigCookieMgr];
                if (enabled && gblManager && cookieMgr !== gblManager) {
                    // Make sure the GlobalCookie Manager instance (if not this instance) is also enabled.
                    // As the global (deprecated) functions may have been called (for backward compatibility)
                    enabled = _isMgrEnabled(gblManager);
                }
                return enabled;
            },
            setEnabled: function (value) {
                // Explicitly checking against false, so that setting to undefined will === true
                _enabled = value !== false;
                cookieMgrConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__._DYN_ENABLED /* @min:%2eenabled */] = value;
            },
            set: function (name, value, maxAgeSec, domain, path) {
                var result = false;
                if (_isMgrEnabled(cookieMgr) && !_isBlockedCookie(cookieMgrConfig, name)) {
                    var values = {};
                    var theValue = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.strTrim)(value || _InternalConstants__WEBPACK_IMPORTED_MODULE_1__.STR_EMPTY);
                    var idx = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.strIndexOf)(theValue, ";");
                    if (idx !== -1) {
                        theValue = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.strTrim)((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.strLeft)(value, idx));
                        values = _extractParts((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.strSubstring)(value, idx + 1));
                    }
                    // Only update domain if not already present (isUndefined) and the value is truthy (not null, undefined or empty string)
                    (0,_HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.setValue)(values, _InternalConstants__WEBPACK_IMPORTED_MODULE_1__.STR_DOMAIN, domain || _domain, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.isTruthy, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.isUndefined);
                    if (!(0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.isNullOrUndefined)(maxAgeSec)) {
                        var _isIE = (0,_EnvUtils__WEBPACK_IMPORTED_MODULE_6__.isIE)();
                        if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.isUndefined)(values[strExpires])) {
                            var nowMs = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.utcNow)();
                            // Only add expires if not already present
                            var expireMs = nowMs + (maxAgeSec * 1000);
                            // Sanity check, if zero or -ve then ignore
                            if (expireMs > 0) {
                                var expiry = new Date();
                                expiry.setTime(expireMs);
                                (0,_HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.setValue)(values, strExpires, _formatDate(expiry, !_isIE ? strToUTCString : strToGMTString) || _formatDate(expiry, _isIE ? strToGMTString : strToUTCString) || _InternalConstants__WEBPACK_IMPORTED_MODULE_1__.STR_EMPTY, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.isTruthy);
                            }
                        }
                        if (!_isIE) {
                            // Only replace if not already present
                            (0,_HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.setValue)(values, "max-age", _InternalConstants__WEBPACK_IMPORTED_MODULE_1__.STR_EMPTY + maxAgeSec, null, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.isUndefined);
                        }
                    }
                    var location_1 = (0,_EnvUtils__WEBPACK_IMPORTED_MODULE_6__.getLocation)();
                    if (location_1 && location_1[_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__._DYN_PROTOCOL /* @min:%2eprotocol */] === "https:") {
                        (0,_HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.setValue)(values, "secure", null, null, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.isUndefined);
                        // Only set same site if not also secure
                        if (_allowUaSameSite === null) {
                            _allowUaSameSite = !uaDisallowsSameSiteNone(((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.getNavigator)() || {})[_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__._DYN_USER_AGENT /* @min:%2euserAgent */]);
                        }
                        if (_allowUaSameSite) {
                            (0,_HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.setValue)(values, "SameSite", "None", null, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.isUndefined);
                        }
                    }
                    (0,_HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.setValue)(values, _InternalConstants__WEBPACK_IMPORTED_MODULE_1__.STR_PATH, path || _path, null, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.isUndefined);
                    //let setCookieFn = cookieMgrConfig.setCookie || _setCookieValue;
                    _setCookieFn(name, _formatCookieValue(theValue, values));
                    result = true;
                }
                return result;
            },
            get: function (name) {
                var value = _InternalConstants__WEBPACK_IMPORTED_MODULE_1__.STR_EMPTY;
                if (_isMgrEnabled(cookieMgr) && !_isIgnoredCookie(cookieMgrConfig, name)) {
                    value = _getCookieFn(name);
                }
                return value;
            },
            del: function (name, path) {
                var result = false;
                if (_isMgrEnabled(cookieMgr)) {
                    // Only remove the cookie if the manager and cookie support has not been disabled
                    result = cookieMgr.purge(name, path);
                }
                return result;
            },
            purge: function (name, path) {
                var _a;
                var result = false;
                if (areCookiesSupported(logger)) {
                    // Setting the expiration date in the past immediately removes the cookie
                    var values = (_a = {},
                        _a[_InternalConstants__WEBPACK_IMPORTED_MODULE_1__.STR_PATH] = path ? path : "/",
                        _a[strExpires] = "Thu, 01 Jan 1970 00:00:01 GMT",
                        _a);
                    if (!(0,_EnvUtils__WEBPACK_IMPORTED_MODULE_6__.isIE)()) {
                        // Set max age to expire now
                        values["max-age"] = "0";
                    }
                    // let delCookie = cookieMgrConfig.delCookie || _setCookieValue;
                    _delCookieFn(name, _formatCookieValue(_InternalConstants__WEBPACK_IMPORTED_MODULE_1__.STR_EMPTY, values));
                    result = true;
                }
                return result;
            }
        },
        _a[_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__._DYN_UNLOAD /* @min:unload */] = function (isAsync) {
            unloadHandler && unloadHandler.rm();
            unloadHandler = null;
        },
        _a);
    // Associated this cookie manager with the config
    cookieMgr[strConfigCookieMgr] = cookieMgr;
    return cookieMgr;
}
/*
* Helper method to tell if document.cookie object is supported by the runtime
*/
function areCookiesSupported(logger) {
    if (_supportsCookies === null) {
        _supportsCookies = false;
        !_doc && _getDoc();
        try {
            var doc = _doc.v || {};
            _supportsCookies = doc[strCookie] !== undefined;
        }
        catch (e) {
            (0,_DiagnosticLogger__WEBPACK_IMPORTED_MODULE_7__._throwInternal)(logger, 2 /* eLoggingSeverity.WARNING */, 68 /* _eInternalMessageId.CannotAccessCookie */, "Cannot access document.cookie - " + (0,_HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.getExceptionName)(e), { exception: (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.dumpObj)(e) });
        }
    }
    return _supportsCookies;
}
function _extractParts(theValue) {
    var values = {};
    if (theValue && theValue[_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__._DYN_LENGTH /* @min:%2elength */]) {
        var parts = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.strTrim)(theValue)[_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__._DYN_SPLIT /* @min:%2esplit */](";");
        (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.arrForEach)(parts, function (thePart) {
            thePart = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.strTrim)(thePart || _InternalConstants__WEBPACK_IMPORTED_MODULE_1__.STR_EMPTY);
            if (thePart) {
                var idx = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.strIndexOf)(thePart, "=");
                if (idx === -1) {
                    values[thePart] = null;
                }
                else {
                    values[(0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.strTrim)((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.strLeft)(thePart, idx))] = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.strTrim)((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.strSubstring)(thePart, idx + 1));
                }
            }
        });
    }
    return values;
}
function _formatDate(theDate, func) {
    if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.isFunction)(theDate[func])) {
        return theDate[func]();
    }
    return null;
}
function _formatCookieValue(value, values) {
    var cookieValue = value || _InternalConstants__WEBPACK_IMPORTED_MODULE_1__.STR_EMPTY;
    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.objForEachKey)(values, function (name, theValue) {
        cookieValue += "; " + name + (!(0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.isNullOrUndefined)(theValue) ? "=" + theValue : _InternalConstants__WEBPACK_IMPORTED_MODULE_1__.STR_EMPTY);
    });
    return cookieValue;
}
function _getCookieValue(name) {
    var cookieValue = _InternalConstants__WEBPACK_IMPORTED_MODULE_1__.STR_EMPTY;
    !_doc && _getDoc();
    if (_doc.v) {
        var theCookie = _doc.v[strCookie] || _InternalConstants__WEBPACK_IMPORTED_MODULE_1__.STR_EMPTY;
        if (_parsedCookieValue !== theCookie) {
            _cookieCache = _extractParts(theCookie);
            _parsedCookieValue = theCookie;
        }
        cookieValue = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.strTrim)(_cookieCache[name] || _InternalConstants__WEBPACK_IMPORTED_MODULE_1__.STR_EMPTY);
    }
    return cookieValue;
}
function _setCookieValue(name, cookieValue) {
    !_doc && _getDoc();
    if (_doc.v) {
        _doc.v[strCookie] = name + "=" + cookieValue;
    }
}
function uaDisallowsSameSiteNone(userAgent) {
    if (!(0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.isString)(userAgent)) {
        return false;
    }
    // Cover all iOS based browsers here. This includes:
    // - Safari on iOS 12 for iPhone, iPod Touch, iPad
    // - WkWebview on iOS 12 for iPhone, iPod Touch, iPad
    // - Chrome on iOS 12 for iPhone, iPod Touch, iPad
    // All of which are broken by SameSite=None, because they use the iOS networking stack
    if ((0,_HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.strContains)(userAgent, "CPU iPhone OS 12") || (0,_HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.strContains)(userAgent, "iPad; CPU OS 12")) {
        return true;
    }
    // Cover Mac OS X based browsers that use the Mac OS networking stack. This includes:
    // - Safari on Mac OS X
    // This does not include:
    // - Internal browser on Mac OS X
    // - Chrome on Mac OS X
    // - Chromium on Mac OS X
    // Because they do not use the Mac OS networking stack.
    if ((0,_HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.strContains)(userAgent, "Macintosh; Intel Mac OS X 10_14") && (0,_HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.strContains)(userAgent, "Version/") && (0,_HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.strContains)(userAgent, "Safari")) {
        return true;
    }
    // Cover Mac OS X internal browsers that use the Mac OS networking stack. This includes:
    // - Internal browser on Mac OS X
    // This does not include:
    // - Safari on Mac OS X
    // - Chrome on Mac OS X
    // - Chromium on Mac OS X
    // Because they do not use the Mac OS networking stack.
    if ((0,_HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.strContains)(userAgent, "Macintosh; Intel Mac OS X 10_14") && (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.strEndsWith)(userAgent, "AppleWebKit/605.1.15 (KHTML, like Gecko)")) {
        return true;
    }
    // Cover Chrome 50-69, because some versions are broken by SameSite=None, and none in this range require it.
    // Note: this covers some pre-Chromium Edge versions, but pre-Chromim Edge does not require SameSite=None, so this is fine.
    // Note: this regex applies to Windows, Mac OS X, and Linux, deliberately.
    if ((0,_HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.strContains)(userAgent, "Chrome/5") || (0,_HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.strContains)(userAgent, "Chrome/6")) {
        return true;
    }
    // Unreal Engine runs Chromium 59, but does not advertise as Chrome until 4.23. Treat versions of Unreal
    // that don't specify their Chrome version as lacking support for SameSite=None.
    if ((0,_HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.strContains)(userAgent, "UnrealEngine") && !(0,_HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.strContains)(userAgent, "Chrome")) {
        return true;
    }
    // UCBrowser < 12.13.2 ignores Set-Cookie headers with SameSite=None
    // NB: this rule isn't complete - you need regex to make a complete rule.
    // See: https://www.chromium.org/updates/same-site/incompatible-clients
    if ((0,_HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.strContains)(userAgent, "UCBrowser/12") || (0,_HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.strContains)(userAgent, "UCBrowser/11")) {
        return true;
    }
    return false;
}
//# sourceMappingURL=CookieMgr.js.map

/***/ }),
/* 59 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cfgDfBlockPropValue": () => (/* binding */ cfgDfBlockPropValue),
/* harmony export */   "cfgDfBoolean": () => (/* binding */ cfgDfBoolean),
/* harmony export */   "cfgDfFunc": () => (/* binding */ cfgDfFunc),
/* harmony export */   "cfgDfMerge": () => (/* binding */ cfgDfMerge),
/* harmony export */   "cfgDfSet": () => (/* binding */ cfgDfSet),
/* harmony export */   "cfgDfString": () => (/* binding */ cfgDfString),
/* harmony export */   "cfgDfValidate": () => (/* binding */ cfgDfValidate)
/* harmony export */ });
/* harmony import */ var _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(30);
/* harmony import */ var _JavaScriptSDK_InternalConstants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(39);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(38);
/*
 * Application Insights JavaScript SDK - Core, 3.3.0
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */





/**
 * @internal
 * @ignore
 * @param str
 * @param defaultValue
 * @returns
 */
function _stringToBoolOrDefault(theValue, defaultValue, theConfig) {
    if (!theValue && (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(theValue)) {
        return defaultValue;
    }
    if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isBoolean)(theValue)) {
        return theValue;
    }
    return (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.asString)(theValue)[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_TO_LOWER_CASE /* @min:%2etoLowerCase */]() === "true";
}
/**
 * Helper which returns an IConfigDefaultCheck instance with the field defined as an object
 * that should be merged
 * @param defaultValue - The default value to apply it not provided or it's not valid
 * @returns a new IConfigDefaultCheck structure
 */
function cfgDfMerge(defaultValue) {
    return {
        mrg: true,
        v: defaultValue
    };
}
/**
 * Helper which returns an IConfigDefaultCheck instance with the provided field set function
 * @param setter - The IConfigCheckFn function to validate the user provided value
 * @param defaultValue - The default value to apply it not provided or it's not valid
 * @returns a new IConfigDefaultCheck structure
 */
function cfgDfSet(setter, defaultValue) {
    return {
        set: setter,
        v: defaultValue
    };
}
/**
 * Helper which returns an IConfigDefaultCheck instance with the provided field validator
 * @param validator - The IConfigCheckFn function to validate the user provided value
 * @param defaultValue - The default value to apply it not provided or it's not valid
 * @param fallBackName - The fallback configuration name if the current value is not available
 * @returns a new IConfigDefaultCheck structure
 */
function cfgDfValidate(validator, defaultValue, fallBackName) {
    return {
        fb: fallBackName,
        isVal: validator,
        v: defaultValue
    };
}
/**
 * Helper which returns an IConfigDefaultCheck instance that will validate and convert the user
 * provided value to a boolean from a string or boolean value
 * @param defaultValue - The default value to apply it not provided or it's not valid
 * @param fallBackName - The fallback configuration name if the current value is not available
 * @returns a new IConfigDefaultCheck structure
 */
function cfgDfBoolean(defaultValue, fallBackName) {
    return {
        fb: fallBackName,
        set: _stringToBoolOrDefault,
        v: !!defaultValue
    };
}
/**
 * Helper which returns an IConfigDefaultCheck instance that will validate that the user
 * provided value is a function.
 * @param defaultValue - The default value to apply it not provided or it's not valid
 * @returns a new IConfigDefaultCheck structure
 */
function cfgDfFunc(defaultValue) {
    return {
        isVal: _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isFunction,
        v: defaultValue || null
    };
}
/**
 * Helper which returns an IConfigDefaultCheck instance that will validate that the user
 * provided value is a function.
 * @param defaultValue - The default string value to apply it not provided or it's not valid, defaults to an empty string
 * @returns a new IConfigDefaultCheck structure
 */
function cfgDfString(defaultValue) {
    return {
        isVal: _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isString,
        v: (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.asString)(defaultValue || _JavaScriptSDK_InternalConstants__WEBPACK_IMPORTED_MODULE_2__.STR_EMPTY)
    };
}
/**
 * Helper which returns an IConfigDefaultCheck instance identifying that value associated with this property
 * should not have it's properties converted into a dynamic config properties.
 * @param defaultValue - The default value to apply it not provided or it's not valid
 * @returns a new IConfigDefaultCheck structure
 */
function cfgDfBlockPropValue(defaultValue) {
    var _a;
    return _a = {},
        _a[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_BLK_VAL /* @min:blkVal */] = true,
        _a.v = defaultValue,
        _a;
}
//# sourceMappingURL=ConfigDefaultHelpers.js.map

/***/ }),
/* 60 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "doUnloadAll": () => (/* binding */ doUnloadAll),
/* harmony export */   "runTargetUnload": () => (/* binding */ runTargetUnload)
/* harmony export */ });
/* harmony import */ var _nevware21_ts_async__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(56);
/* harmony import */ var _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(30);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38);
/*
 * Application Insights JavaScript SDK - Core, 3.3.0
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */





/**
 * Run the unload function of the target object if it exists
 * @param target - The target object that contains the unload function
 * @param isAsync - The caller identifies whether it is expecting the operation to complete synchronously or asynchronously. Even
 * if the caller is not waiting the operation may still be performed asynchronously depending on the component and the reverse is
 * also true.
 * @returns The result of the target function
 */
function runTargetUnload(target, isAsync) {
    if (target && target[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_UNLOAD /* @min:%2eunload */]) {
        return target[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_UNLOAD /* @min:%2eunload */](isAsync);
    }
}
/**
 * Call the unload function on all targets handling any returned [IPromise](https://nevware21.github.io/ts-async/typedoc/interfaces/IPromise.html)
 * / Promise before calling the next targets unload
 * @param targets - An array of the targets to unload
 * @param isAsync - The caller identifies whether it is expecting the operations to complete synchronously or asynchronously.  Even
 * if the caller is not waiting the operation may still be performed asynchronously depending on the component and the reverse is
 * also true.
 * @param done - Optional callback function to call once all of the unload functions have been called.
 */
function doUnloadAll(targets, isAsync, done) {
    var result;
    if (!done) {
        result = (0,_nevware21_ts_async__WEBPACK_IMPORTED_MODULE_1__.createPromise)(function (resolved) {
            done = resolved;
        });
    }
    if (targets && (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_2__.getLength)(targets) > 0) {
        (0,_nevware21_ts_async__WEBPACK_IMPORTED_MODULE_1__.doAwaitResponse)(runTargetUnload(targets[0], isAsync), function () {
            doUnloadAll((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_2__.arrSlice)(targets, 1), isAsync, done);
        });
    }
    else {
        done();
    }
    return result;
}
//# sourceMappingURL=AsyncUtils.js.map

/***/ }),
/* 61 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ProcessTelemetryContext": () => (/* binding */ ProcessTelemetryContext),
/* harmony export */   "createProcessTelemetryContext": () => (/* binding */ createProcessTelemetryContext),
/* harmony export */   "createProcessTelemetryUnloadContext": () => (/* binding */ createProcessTelemetryUnloadContext),
/* harmony export */   "createProcessTelemetryUpdateContext": () => (/* binding */ createProcessTelemetryUpdateContext),
/* harmony export */   "createTelemetryPluginProxy": () => (/* binding */ createTelemetryPluginProxy),
/* harmony export */   "createTelemetryProxyChain": () => (/* binding */ createTelemetryProxyChain)
/* harmony export */ });
/* harmony import */ var _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(30);
/* harmony import */ var _Config_ConfigDefaults__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(47);
/* harmony import */ var _Config_DynamicConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(40);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38);
/* harmony import */ var _DiagnosticLogger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(50);
/* harmony import */ var _HelperFuncs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(45);
/* harmony import */ var _InternalConstants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(39);
/* harmony import */ var _PerfManager__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(37);
/* harmony import */ var _TelemetryHelpers__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(62);
/*
 * Application Insights JavaScript SDK - Core, 3.3.0
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */












var strTelemetryPluginChain = "TelemetryPluginChain";
var strHasRunFlags = "_hasRun";
var strGetTelCtx = "_getTelCtx";
var _chainId = 0;
function _getNextProxyStart(proxy, core, startAt) {
    while (proxy) {
        if (proxy[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_GET_PLUGIN /* @min:%2egetPlugin */]() === startAt) {
            return proxy;
        }
        proxy = proxy[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_GET_NEXT /* @min:%2egetNext */]();
    }
    // This wasn't found in the existing chain so create an isolated one with just this plugin
    return createTelemetryProxyChain([startAt], core.config || {}, core);
}
/**
 * @ignore
 * @param telemetryChain
 * @param dynamicHandler
 * @param core
 * @param startAt - Identifies the next plugin to execute, if null there is no "next" plugin and if undefined it should assume the start of the chain
 * @returns
 */
function _createInternalContext(telemetryChain, dynamicHandler, core, startAt) {
    // We have a special case where we want to start execution from this specific plugin
    // or we simply reuse the existing telemetry plugin chain (normal execution case)
    var _nextProxy = null; // By Default set as no next plugin
    var _onComplete = [];
    if (!dynamicHandler) {
        dynamicHandler = (0,_Config_DynamicConfig__WEBPACK_IMPORTED_MODULE_1__.createDynamicConfig)({}, null, core[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_LOGGER /* @min:%2elogger */]);
    }
    if (startAt !== null) {
        // There is no next element (null) vs not defined (undefined) so use the full chain
        _nextProxy = startAt ? _getNextProxyStart(telemetryChain, core, startAt) : telemetryChain;
    }
    var context = {
        _next: _moveNext,
        ctx: {
            core: function () {
                return core;
            },
            diagLog: function () {
                return (0,_DiagnosticLogger__WEBPACK_IMPORTED_MODULE_2__.safeGetLogger)(core, dynamicHandler.cfg);
            },
            getCfg: function () {
                return dynamicHandler.cfg;
            },
            getExtCfg: _resolveExtCfg,
            getConfig: _getConfig,
            hasNext: function () {
                return !!_nextProxy;
            },
            getNext: function () {
                return _nextProxy;
            },
            setNext: function (nextPlugin) {
                _nextProxy = nextPlugin;
            },
            iterate: _iterateChain,
            onComplete: _addOnComplete
        }
    };
    function _addOnComplete(onComplete, that) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        if (onComplete) {
            _onComplete[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_PUSH /* @min:%2epush */]({
                func: onComplete,
                self: !(0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.isUndefined)(that) ? that : context.ctx,
                args: args
            });
        }
    }
    function _moveNext() {
        var nextProxy = _nextProxy;
        // Automatically move to the next plugin
        _nextProxy = nextProxy ? nextProxy[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_GET_NEXT /* @min:%2egetNext */]() : null;
        if (!nextProxy) {
            var onComplete = _onComplete;
            if (onComplete && onComplete[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_LENGTH /* @min:%2elength */] > 0) {
                (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.arrForEach)(onComplete, function (completeDetails) {
                    try {
                        completeDetails.func.call(completeDetails.self, completeDetails.args);
                    }
                    catch (e) {
                        (0,_DiagnosticLogger__WEBPACK_IMPORTED_MODULE_2__._throwInternal)(core[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_LOGGER /* @min:%2elogger */], 2 /* eLoggingSeverity.WARNING */, 73 /* _eInternalMessageId.PluginException */, "Unexpected Exception during onComplete - " + (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.dumpObj)(e));
                    }
                });
                _onComplete = [];
            }
        }
        return nextProxy;
    }
    function _getExtCfg(identifier, createIfMissing) {
        var idCfg = null;
        var cfg = dynamicHandler.cfg;
        if (cfg && identifier) {
            var extCfg = cfg[_InternalConstants__WEBPACK_IMPORTED_MODULE_4__.STR_EXTENSION_CONFIG /* @min:%2eextensionConfig */];
            if (!extCfg && createIfMissing) {
                extCfg = {};
            }
            // Always set the value so that the property always exists
            cfg[_InternalConstants__WEBPACK_IMPORTED_MODULE_4__.STR_EXTENSION_CONFIG] = extCfg; // Note: it is valid for the "value" to be undefined
            // Calling `ref()` has a side effect of causing the referenced property to become dynamic  (if not already)
            extCfg = dynamicHandler.ref(cfg, _InternalConstants__WEBPACK_IMPORTED_MODULE_4__.STR_EXTENSION_CONFIG);
            if (extCfg) {
                idCfg = extCfg[identifier];
                if (!idCfg && createIfMissing) {
                    idCfg = {};
                }
                // Always set the value so that the property always exists
                extCfg[identifier] = idCfg; // Note: it is valid for the "value" to be undefined
                // Calling `ref()` has a side effect of causing the referenced property to become dynamic  (if not already)
                idCfg = dynamicHandler.ref(extCfg, identifier);
            }
        }
        return idCfg;
    }
    function _resolveExtCfg(identifier, defaultValues) {
        var newConfig = _getExtCfg(identifier, true);
        if (defaultValues) {
            // Enumerate over the defaultValues and if not already populated attempt to
            // find a value from the root config or use the default value
            (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.objForEachKey)(defaultValues, function (field, defaultValue) {
                // for each unspecified field, set the default value
                if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.isNullOrUndefined)(newConfig[field])) {
                    var cfgValue = dynamicHandler.cfg[field];
                    if (cfgValue || !(0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.isNullOrUndefined)(cfgValue)) {
                        newConfig[field] = cfgValue;
                    }
                }
                (0,_Config_ConfigDefaults__WEBPACK_IMPORTED_MODULE_5__._applyDefaultValue)(dynamicHandler, newConfig, field, defaultValue);
            });
        }
        return dynamicHandler[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_SET_DF /* @min:%2esetDf */](newConfig, defaultValues);
    }
    function _getConfig(identifier, field, defaultValue) {
        if (defaultValue === void 0) { defaultValue = false; }
        var theValue;
        var extConfig = _getExtCfg(identifier, false);
        var rootConfig = dynamicHandler.cfg;
        if (extConfig && (extConfig[field] || !(0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.isNullOrUndefined)(extConfig[field]))) {
            theValue = extConfig[field];
        }
        else if (rootConfig[field] || !(0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.isNullOrUndefined)(rootConfig[field])) {
            theValue = rootConfig[field];
        }
        return (theValue || !(0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.isNullOrUndefined)(theValue)) ? theValue : defaultValue;
    }
    function _iterateChain(cb) {
        // Keep processing until we reach the end of the chain
        var nextPlugin;
        while (!!(nextPlugin = context._next())) {
            var plugin = nextPlugin[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_GET_PLUGIN /* @min:%2egetPlugin */]();
            if (plugin) {
                // callback with the current on
                cb(plugin);
            }
        }
    }
    return context;
}
/**
 * Creates a new Telemetry Item context with the current config, core and plugin execution chain
 * @param plugins - The plugin instances that will be executed
 * @param config - The current config
 * @param core - The current core instance
 * @param startAt - Identifies the next plugin to execute, if null there is no "next" plugin and if undefined it should assume the start of the chain
 */
function createProcessTelemetryContext(telemetryChain, cfg, core, startAt) {
    var config = (0,_Config_DynamicConfig__WEBPACK_IMPORTED_MODULE_1__.createDynamicConfig)(cfg);
    var internalContext = _createInternalContext(telemetryChain, config, core, startAt);
    var context = internalContext.ctx;
    function _processNext(env) {
        var nextPlugin = internalContext._next();
        if (nextPlugin) {
            // Run the next plugin which will call "processNext()"
            nextPlugin[_InternalConstants__WEBPACK_IMPORTED_MODULE_4__.STR_PROCESS_TELEMETRY /* @min:%2eprocessTelemetry */](env, context);
        }
        return !nextPlugin;
    }
    function _createNew(plugins, startAt) {
        if (plugins === void 0) { plugins = null; }
        if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.isArray)(plugins)) {
            plugins = createTelemetryProxyChain(plugins, config.cfg, core, startAt);
        }
        return createProcessTelemetryContext(plugins || context[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_GET_NEXT /* @min:%2egetNext */](), config.cfg, core, startAt);
    }
    context[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_PROCESS_NEXT /* @min:%2eprocessNext */] = _processNext;
    context[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_CREATE_NEW /* @min:%2ecreateNew */] = _createNew;
    return context;
}
/**
 * Creates a new Telemetry Item context with the current config, core and plugin execution chain for handling the unloading of the chain
 * @param plugins - The plugin instances that will be executed
 * @param config - The current config
 * @param core - The current core instance
 * @param startAt - Identifies the next plugin to execute, if null there is no "next" plugin and if undefined it should assume the start of the chain
 */
function createProcessTelemetryUnloadContext(telemetryChain, core, startAt) {
    var config = (0,_Config_DynamicConfig__WEBPACK_IMPORTED_MODULE_1__.createDynamicConfig)(core.config);
    var internalContext = _createInternalContext(telemetryChain, config, core, startAt);
    var context = internalContext.ctx;
    function _processNext(unloadState) {
        var nextPlugin = internalContext._next();
        nextPlugin && nextPlugin[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_UNLOAD /* @min:%2eunload */](context, unloadState);
        return !nextPlugin;
    }
    function _createNew(plugins, startAt) {
        if (plugins === void 0) { plugins = null; }
        if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.isArray)(plugins)) {
            plugins = createTelemetryProxyChain(plugins, config.cfg, core, startAt);
        }
        return createProcessTelemetryUnloadContext(plugins || context[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_GET_NEXT /* @min:%2egetNext */](), core, startAt);
    }
    context[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_PROCESS_NEXT /* @min:%2eprocessNext */] = _processNext;
    context[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_CREATE_NEW /* @min:%2ecreateNew */] = _createNew;
    return context;
}
/**
 * Creates a new Telemetry Item context with the current config, core and plugin execution chain for updating the configuration
 * @param plugins - The plugin instances that will be executed
 * @param config - The current config
 * @param core - The current core instance
 * @param startAt - Identifies the next plugin to execute, if null there is no "next" plugin and if undefined it should assume the start of the chain
 */
function createProcessTelemetryUpdateContext(telemetryChain, core, startAt) {
    var config = (0,_Config_DynamicConfig__WEBPACK_IMPORTED_MODULE_1__.createDynamicConfig)(core.config);
    var internalContext = _createInternalContext(telemetryChain, config, core, startAt);
    var context = internalContext.ctx;
    function _processNext(updateState) {
        return context.iterate(function (plugin) {
            if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.isFunction)(plugin[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_UPDATE /* @min:%2eupdate */])) {
                plugin[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_UPDATE /* @min:%2eupdate */](context, updateState);
            }
        });
    }
    function _createNew(plugins, startAt) {
        if (plugins === void 0) { plugins = null; }
        if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.isArray)(plugins)) {
            plugins = createTelemetryProxyChain(plugins, config.cfg, core, startAt);
        }
        return createProcessTelemetryUpdateContext(plugins || context[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_GET_NEXT /* @min:%2egetNext */](), core, startAt);
    }
    context[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_PROCESS_NEXT /* @min:%2eprocessNext */] = _processNext;
    context[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_CREATE_NEW /* @min:%2ecreateNew */] = _createNew;
    return context;
}
/**
 * Creates an execution chain from the array of plugins
 * @param plugins - The array of plugins that will be executed in this order
 * @param defItemCtx - The default execution context to use when no telemetry context is passed to processTelemetry(), this
 * should be for legacy plugins only. Currently, only used for passing the current core instance and to provide better error
 * reporting (hasRun) when errors occur.
 */
function createTelemetryProxyChain(plugins, config, core, startAt) {
    var firstProxy = null;
    var add = startAt ? false : true;
    if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.isArray)(plugins) && plugins[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_LENGTH /* @min:%2elength */] > 0) {
        // Create the proxies and wire up the next plugin chain
        var lastProxy_1 = null;
        (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.arrForEach)(plugins, function (thePlugin) {
            if (!add && startAt === thePlugin) {
                add = true;
            }
            if (add && thePlugin && (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.isFunction)(thePlugin[_InternalConstants__WEBPACK_IMPORTED_MODULE_4__.STR_PROCESS_TELEMETRY /* @min:%2eprocessTelemetry */])) {
                // Only add plugins that are processors
                var newProxy = createTelemetryPluginProxy(thePlugin, config, core);
                if (!firstProxy) {
                    firstProxy = newProxy;
                }
                if (lastProxy_1) {
                    // Set this new proxy as the next for the previous one
                    lastProxy_1._setNext(newProxy);
                }
                lastProxy_1 = newProxy;
            }
        });
    }
    if (startAt && !firstProxy) {
        // Special case where the "startAt" was not in the original list of plugins
        return createTelemetryProxyChain([startAt], config, core);
    }
    return firstProxy;
}
/**
 * Create the processing telemetry proxy instance, the proxy is used to abstract the current plugin to allow monitoring and
 * execution plugins while passing around the dynamic execution state (IProcessTelemetryContext), the proxy instance no longer
 * contains any execution state and can be reused between requests (this was not the case for 2.7.2 and earlier with the
 * TelemetryPluginChain class).
 * @param plugin - The plugin instance to proxy
 * @param config - The default execution context to use when no telemetry context is passed to processTelemetry(), this
 * should be for legacy plugins only. Currently, only used for passing the current core instance and to provide better error
 * reporting (hasRun) when errors occur.
 * @returns
 */
function createTelemetryPluginProxy(plugin, config, core) {
    var nextProxy = null;
    var hasProcessTelemetry = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.isFunction)(plugin[_InternalConstants__WEBPACK_IMPORTED_MODULE_4__.STR_PROCESS_TELEMETRY /* @min:%2eprocessTelemetry */]);
    var hasSetNext = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.isFunction)(plugin[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_SET_NEXT_PLUGIN /* @min:%2esetNextPlugin */]);
    var chainId;
    if (plugin) {
        chainId = plugin[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_IDENTIFIER /* @min:%2eidentifier */] + "-" + plugin[_InternalConstants__WEBPACK_IMPORTED_MODULE_4__.STR_PRIORITY /* @min:%2epriority */] + "-" + _chainId++;
    }
    else {
        chainId = "Unknown-0-" + _chainId++;
    }
    var proxyChain = {
        getPlugin: function () {
            return plugin;
        },
        getNext: function () {
            return nextProxy;
        },
        processTelemetry: _processTelemetry,
        unload: _unloadPlugin,
        update: _updatePlugin,
        _id: chainId,
        _setNext: function (nextPlugin) {
            nextProxy = nextPlugin;
        }
    };
    function _getTelCtx() {
        var itemCtx;
        // Looks like a plugin didn't pass the (optional) context, so create a new one
        if (plugin && (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.isFunction)(plugin[strGetTelCtx])) {
            // This plugin extends from the BaseTelemetryPlugin so lets use it
            itemCtx = plugin[strGetTelCtx]();
        }
        if (!itemCtx) {
            // Create a temporary one
            itemCtx = createProcessTelemetryContext(proxyChain, config, core);
        }
        return itemCtx;
    }
    function _processChain(itemCtx, processPluginFn, name, details, isAsync) {
        var hasRun = false;
        var identifier = plugin ? plugin[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_IDENTIFIER /* @min:%2eidentifier */] : strTelemetryPluginChain;
        var hasRunContext = itemCtx[strHasRunFlags];
        if (!hasRunContext) {
            // Assign and populate
            hasRunContext = itemCtx[strHasRunFlags] = {};
        }
        // Ensure that we keep the context in sync
        itemCtx.setNext(nextProxy);
        if (plugin) {
            (0,_PerfManager__WEBPACK_IMPORTED_MODULE_6__.doPerf)(itemCtx[_InternalConstants__WEBPACK_IMPORTED_MODULE_4__.STR_CORE /* @min:%2ecore */](), function () { return identifier + ":" + name; }, function () {
                // Mark this component as having run
                hasRunContext[chainId] = true;
                try {
                    // Set a flag on the next plugin so we know if it was attempted to be executed
                    var nextId = nextProxy ? nextProxy._id : _InternalConstants__WEBPACK_IMPORTED_MODULE_4__.STR_EMPTY;
                    if (nextId) {
                        hasRunContext[nextId] = false;
                    }
                    hasRun = processPluginFn(itemCtx);
                }
                catch (error) {
                    var hasNextRun = nextProxy ? hasRunContext[nextProxy._id] : true;
                    if (hasNextRun) {
                        // The next plugin after us has already run so set this one as complete
                        hasRun = true;
                    }
                    if (!nextProxy || !hasNextRun) {
                        // Either we have no next plugin or the current one did not attempt to call the next plugin
                        // Which means the current one is the root of the failure so log/report this failure
                        (0,_DiagnosticLogger__WEBPACK_IMPORTED_MODULE_2__._throwInternal)(itemCtx[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_DIAG_LOG /* @min:%2ediagLog */](), 1 /* eLoggingSeverity.CRITICAL */, 73 /* _eInternalMessageId.PluginException */, "Plugin [" + identifier + "] failed during " + name + " - " + (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.dumpObj)(error) + ", run flags: " + (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.dumpObj)(hasRunContext));
                    }
                }
            }, details, isAsync);
        }
        return hasRun;
    }
    function _processTelemetry(env, itemCtx) {
        itemCtx = itemCtx || _getTelCtx();
        function _callProcessTelemetry(itemCtx) {
            if (!plugin || !hasProcessTelemetry) {
                return false;
            }
            var pluginState = (0,_TelemetryHelpers__WEBPACK_IMPORTED_MODULE_7__._getPluginState)(plugin);
            if (pluginState[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_TEARDOWN /* @min:%2eteardown */] || pluginState[_InternalConstants__WEBPACK_IMPORTED_MODULE_4__.STR_DISABLED]) {
                return false;
            }
            // Ensure that we keep the context in sync (for processNext()), just in case a plugin
            // doesn't calls processTelemetry() instead of itemContext.processNext() or some
            // other form of error occurred
            if (hasSetNext) {
                // Backward compatibility setting the next plugin on the instance
                plugin[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_SET_NEXT_PLUGIN /* @min:%2esetNextPlugin */](nextProxy);
            }
            plugin[_InternalConstants__WEBPACK_IMPORTED_MODULE_4__.STR_PROCESS_TELEMETRY /* @min:%2eprocessTelemetry */](env, itemCtx);
            // Process Telemetry is expected to call itemCtx.processNext() or nextPlugin.processTelemetry()
            return true;
        }
        if (!_processChain(itemCtx, _callProcessTelemetry, "processTelemetry", function () { return ({ item: env }); }, !(env.sync))) {
            // The underlying plugin is either not defined, not enabled or does not have a processTelemetry implementation
            // so we still want the next plugin to be executed.
            itemCtx[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_PROCESS_NEXT /* @min:%2eprocessNext */](env);
        }
    }
    function _unloadPlugin(unloadCtx, unloadState) {
        function _callTeardown() {
            // Setting default of hasRun as false so the proxyProcessFn() is called as teardown() doesn't have to exist or call unloadNext().
            var hasRun = false;
            if (plugin) {
                var pluginState = (0,_TelemetryHelpers__WEBPACK_IMPORTED_MODULE_7__._getPluginState)(plugin);
                var pluginCore = plugin[_InternalConstants__WEBPACK_IMPORTED_MODULE_4__.STR_CORE] || pluginState[_InternalConstants__WEBPACK_IMPORTED_MODULE_4__.STR_CORE /* @min:%2ecore */];
                // Only teardown the plugin if it was initialized by the current core (i.e. It's not a shared plugin)
                if (plugin && (!pluginCore || pluginCore === unloadCtx.core()) && !pluginState[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_TEARDOWN /* @min:%2eteardown */]) {
                    // Handle plugins that don't extend from the BaseTelemetryPlugin
                    pluginState[_InternalConstants__WEBPACK_IMPORTED_MODULE_4__.STR_CORE /* @min:%2ecore */] = null;
                    pluginState[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_TEARDOWN /* @min:%2eteardown */] = true;
                    pluginState[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_IS_INITIALIZED /* @min:%2eisInitialized */] = false;
                    if (plugin[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_TEARDOWN /* @min:%2eteardown */] && plugin[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_TEARDOWN /* @min:%2eteardown */](unloadCtx, unloadState) === true) {
                        // plugin told us that it was going to (or has) call unloadCtx.processNext()
                        hasRun = true;
                    }
                }
            }
            return hasRun;
        }
        if (!_processChain(unloadCtx, _callTeardown, "unload", function () { }, unloadState[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_IS_ASYNC /* @min:%2eisAsync */])) {
            // Only called if we hasRun was not true
            unloadCtx[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_PROCESS_NEXT /* @min:%2eprocessNext */](unloadState);
        }
    }
    function _updatePlugin(updateCtx, updateState) {
        function _callUpdate() {
            // Setting default of hasRun as false so the proxyProcessFn() is called as teardown() doesn't have to exist or call unloadNext().
            var hasRun = false;
            if (plugin) {
                var pluginState = (0,_TelemetryHelpers__WEBPACK_IMPORTED_MODULE_7__._getPluginState)(plugin);
                var pluginCore = plugin[_InternalConstants__WEBPACK_IMPORTED_MODULE_4__.STR_CORE] || pluginState[_InternalConstants__WEBPACK_IMPORTED_MODULE_4__.STR_CORE /* @min:%2ecore */];
                // Only update the plugin if it was initialized by the current core (i.e. It's not a shared plugin)
                if (plugin && (!pluginCore || pluginCore === updateCtx.core()) && !pluginState[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_TEARDOWN /* @min:%2eteardown */]) {
                    if (plugin[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_UPDATE /* @min:%2eupdate */] && plugin[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_UPDATE /* @min:%2eupdate */](updateCtx, updateState) === true) {
                        // plugin told us that it was going to (or has) call unloadCtx.processNext()
                        hasRun = true;
                    }
                }
            }
            return hasRun;
        }
        if (!_processChain(updateCtx, _callUpdate, "update", function () { }, false)) {
            // Only called if we hasRun was not true
            updateCtx[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_PROCESS_NEXT /* @min:%2eprocessNext */](updateState);
        }
    }
    return (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.objFreeze)(proxyChain);
}
/**
 * This class will be removed!
 * @deprecated use createProcessTelemetryContext() instead
 */
var ProcessTelemetryContext = /** @class */ (function () {
    /**
     * Creates a new Telemetry Item context with the current config, core and plugin execution chain
     * @param plugins - The plugin instances that will be executed
     * @param config - The current config
     * @param core - The current core instance
     */
    function ProcessTelemetryContext(pluginChain, config, core, startAt) {
        var _self = this;
        var context = createProcessTelemetryContext(pluginChain, config, core, startAt);
        // Proxy all functions of the context to this object
        (0,_HelperFuncs__WEBPACK_IMPORTED_MODULE_8__.proxyFunctions)(_self, context, (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.objKeys)(context));
    }
    return ProcessTelemetryContext;
}());

//# sourceMappingURL=ProcessTelemetryContext.js.map

/***/ }),
/* 62 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "_getPluginState": () => (/* binding */ _getPluginState),
/* harmony export */   "createDistributedTraceContext": () => (/* binding */ createDistributedTraceContext),
/* harmony export */   "initializePlugins": () => (/* binding */ initializePlugins),
/* harmony export */   "sortPlugins": () => (/* binding */ sortPlugins),
/* harmony export */   "unloadComponents": () => (/* binding */ unloadComponents)
/* harmony export */ });
/* harmony import */ var _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(30);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(38);
/* harmony import */ var _DataCacheHelper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(42);
/* harmony import */ var _InternalConstants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(39);
/* harmony import */ var _W3cTraceParent__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(63);
/*
 * Application Insights JavaScript SDK - Core, 3.3.0
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */








var pluginStateData = (0,_DataCacheHelper__WEBPACK_IMPORTED_MODULE_0__.createElmNodeData)("plugin");
function _getPluginState(plugin) {
    return pluginStateData.get(plugin, "state", {}, true);
}
/**
 * Initialize the queue of plugins
 * @param plugins - The array of plugins to initialize and setting of the next plugin
 * @param config - The current config for the instance
 * @param core - THe current core instance
 * @param extensions - The extensions
 */
function initializePlugins(processContext, extensions) {
    // Set the next plugin and identified the uninitialized plugins
    var initPlugins = [];
    var lastPlugin = null;
    var proxy = processContext[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_GET_NEXT /* @min:%2egetNext */]();
    var pluginState;
    while (proxy) {
        var thePlugin = proxy[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_GET_PLUGIN /* @min:%2egetPlugin */]();
        if (thePlugin) {
            if (lastPlugin && lastPlugin[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_SET_NEXT_PLUGIN /* @min:%2esetNextPlugin */] && thePlugin[_InternalConstants__WEBPACK_IMPORTED_MODULE_2__.STR_PROCESS_TELEMETRY /* @min:%2eprocessTelemetry */]) {
                // Set this plugin as the next for the previous one
                lastPlugin[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_SET_NEXT_PLUGIN /* @min:%2esetNextPlugin */](thePlugin);
            }
            pluginState = _getPluginState(thePlugin);
            var isInitialized = !!pluginState[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_IS_INITIALIZED /* @min:%2eisInitialized */];
            if (thePlugin[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_IS_INITIALIZED /* @min:%2eisInitialized */]) {
                isInitialized = thePlugin[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_IS_INITIALIZED /* @min:%2eisInitialized */]();
            }
            if (!isInitialized) {
                initPlugins[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_PUSH /* @min:%2epush */](thePlugin);
            }
            lastPlugin = thePlugin;
            proxy = proxy[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_GET_NEXT /* @min:%2egetNext */]();
        }
    }
    // Now initialize the plugins
    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.arrForEach)(initPlugins, function (thePlugin) {
        var core = processContext[_InternalConstants__WEBPACK_IMPORTED_MODULE_2__.STR_CORE /* @min:%2ecore */]();
        thePlugin[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_INITIALIZE /* @min:%2einitialize */](processContext.getCfg(), core, extensions, processContext[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_GET_NEXT /* @min:%2egetNext */]());
        pluginState = _getPluginState(thePlugin);
        // Only add the core to the state if the plugin didn't set it (doesn't extend from BaseTelemetryPlugin)
        if (!thePlugin[_InternalConstants__WEBPACK_IMPORTED_MODULE_2__.STR_CORE] && !pluginState[_InternalConstants__WEBPACK_IMPORTED_MODULE_2__.STR_CORE]) {
            pluginState[_InternalConstants__WEBPACK_IMPORTED_MODULE_2__.STR_CORE] = core;
        }
        pluginState[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_IS_INITIALIZED /* @min:%2eisInitialized */] = true;
        delete pluginState[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_TEARDOWN /* @min:%2eteardown */];
    });
}
function sortPlugins(plugins) {
    // Sort by priority
    return plugins.sort(function (extA, extB) {
        var result = 0;
        if (extB) {
            var bHasProcess = extB[_InternalConstants__WEBPACK_IMPORTED_MODULE_2__.STR_PROCESS_TELEMETRY];
            if (extA[_InternalConstants__WEBPACK_IMPORTED_MODULE_2__.STR_PROCESS_TELEMETRY]) {
                result = bHasProcess ? extA[_InternalConstants__WEBPACK_IMPORTED_MODULE_2__.STR_PRIORITY] - extB[_InternalConstants__WEBPACK_IMPORTED_MODULE_2__.STR_PRIORITY] : 1;
            }
            else if (bHasProcess) {
                result = -1;
            }
        }
        else {
            result = extA ? 1 : -1;
        }
        return result;
    });
    // sort complete
}
/**
 * Teardown / Unload helper to perform teardown/unloading operations for the provided components synchronously or asynchronously, this will call any
 * _doTeardown() or _doUnload() functions on the provided components to allow them to finish removal.
 * @param components - The components you want to unload
 * @param unloadCtx - This is the context that should be used during unloading.
 * @param unloadState - The details / state of the unload process, it holds details like whether it should be unloaded synchronously or asynchronously and the reason for the unload.
 * @param asyncCallback - An optional callback that the plugin must call if it returns true to inform the caller that it has completed any async unload/teardown operations.
 * @returns boolean - true if the plugin has or will call asyncCallback, this allows the plugin to perform any asynchronous operations.
 */
function unloadComponents(components, unloadCtx, unloadState, asyncCallback) {
    var idx = 0;
    function _doUnload() {
        while (idx < components[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LENGTH /* @min:%2elength */]) {
            var component = components[idx++];
            if (component) {
                var func = component._doUnload || component[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN__DO_TEARDOWN /* @min:%2e_doTeardown */];
                if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.isFunction)(func)) {
                    if (func.call(component, unloadCtx, unloadState, _doUnload) === true) {
                        return true;
                    }
                }
            }
        }
    }
    return _doUnload();
}
/**
 * Creates a IDistributedTraceContext which optionally also "sets" the value on a parent
 * @param parentCtx - An optional parent distributed trace instance
 * @returns A new IDistributedTraceContext instance that uses an internal temporary object
 */
function createDistributedTraceContext(parentCtx) {
    var trace = {};
    return {
        getName: function () {
            return trace[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_NAME /* @min:%2ename */];
        },
        setName: function (newValue) {
            parentCtx && parentCtx.setName(newValue);
            trace[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_NAME /* @min:%2ename */] = newValue;
        },
        getTraceId: function () {
            return trace[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_TRACE_ID /* @min:%2etraceId */];
        },
        setTraceId: function (newValue) {
            parentCtx && parentCtx.setTraceId(newValue);
            if ((0,_W3cTraceParent__WEBPACK_IMPORTED_MODULE_4__.isValidTraceId)(newValue)) {
                trace[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_TRACE_ID /* @min:%2etraceId */] = newValue;
            }
        },
        getSpanId: function () {
            return trace[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_SPAN_ID /* @min:%2espanId */];
        },
        setSpanId: function (newValue) {
            parentCtx && parentCtx.setSpanId(newValue);
            if ((0,_W3cTraceParent__WEBPACK_IMPORTED_MODULE_4__.isValidSpanId)(newValue)) {
                trace[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_SPAN_ID /* @min:%2espanId */] = newValue;
            }
        },
        getTraceFlags: function () {
            return trace[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_TRACE_FLAGS /* @min:%2etraceFlags */];
        },
        setTraceFlags: function (newTraceFlags) {
            parentCtx && parentCtx.setTraceFlags(newTraceFlags);
            trace[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_TRACE_FLAGS /* @min:%2etraceFlags */] = newTraceFlags;
        }
    };
}
//# sourceMappingURL=TelemetryHelpers.js.map

/***/ }),
/* 63 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createTraceParent": () => (/* binding */ createTraceParent),
/* harmony export */   "findW3cTraceParent": () => (/* binding */ findW3cTraceParent),
/* harmony export */   "formatTraceParent": () => (/* binding */ formatTraceParent),
/* harmony export */   "isSampledFlag": () => (/* binding */ isSampledFlag),
/* harmony export */   "isValidSpanId": () => (/* binding */ isValidSpanId),
/* harmony export */   "isValidTraceId": () => (/* binding */ isValidTraceId),
/* harmony export */   "isValidTraceParent": () => (/* binding */ isValidTraceParent),
/* harmony export */   "parseTraceParent": () => (/* binding */ parseTraceParent)
/* harmony export */ });
/* harmony import */ var _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(30);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38);
/* harmony import */ var _CoreUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(53);
/* harmony import */ var _EnvUtils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(44);
/* harmony import */ var _InternalConstants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(39);
/*
 * Application Insights JavaScript SDK - Core, 3.3.0
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */





// using {0,16} for leading and trailing whitespace just to constrain the possible runtime of a random string
var TRACE_PARENT_REGEX = /^([\da-f]{2})-([\da-f]{32})-([\da-f]{16})-([\da-f]{2})(-[^\s]{1,64})?$/i;
var DEFAULT_VERSION = "00";
var INVALID_VERSION = "ff";
var INVALID_TRACE_ID = "00000000000000000000000000000000";
var INVALID_SPAN_ID = "0000000000000000";
var SAMPLED_FLAG = 0x01;
function _isValid(value, len, invalidValue) {
    if (value && value[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_LENGTH /* @min:%2elength */] === len && value !== invalidValue) {
        return !!value.match(/^[\da-f]*$/i);
    }
    return false;
}
function _formatValue(value, len, defValue) {
    if (_isValid(value, len)) {
        return value;
    }
    return defValue;
}
function _formatFlags(value) {
    if (isNaN(value) || value < 0 || value > 255) {
        value = 0x01;
    }
    var result = value.toString(16);
    while (result[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_LENGTH /* @min:%2elength */] < 2) {
        result = "0" + result;
    }
    return result;
}
/**
 * Create a new ITraceParent instance using the provided values.
 * @param traceId - The traceId to use, when invalid a new random W3C id will be generated.
 * @param spanId - The parent/span id to use, a new random value will be generated if it is invalid.
 * @param flags - The traceFlags to use, defaults to zero (0) if not supplied or invalid
 * @param version - The version to used, defaults to version "01" if not supplied or invalid.
 * @returns
 */
function createTraceParent(traceId, spanId, flags, version) {
    var _a;
    return _a = {},
        _a[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_VERSION /* @min:version */] = _isValid(version, 2, INVALID_VERSION) ? version : DEFAULT_VERSION,
        _a[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_TRACE_ID /* @min:traceId */] = isValidTraceId(traceId) ? traceId : (0,_CoreUtils__WEBPACK_IMPORTED_MODULE_1__.generateW3CId)(),
        _a[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_SPAN_ID /* @min:spanId */] = isValidSpanId(spanId) ? spanId : (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_2__.strLeft)((0,_CoreUtils__WEBPACK_IMPORTED_MODULE_1__.generateW3CId)(), 16),
        _a.traceFlags = flags >= 0 && flags <= 0xFF ? flags : 1,
        _a;
}
/**
 * Attempt to parse the provided string as a W3C TraceParent header value (https://www.w3.org/TR/trace-context/#traceparent-header)
 *
 * @param value - The value to be parsed
 * @param selectIdx - If the found value is comma separated which is the preferred entry to select, defaults to the first
 * @returns
 */
function parseTraceParent(value, selectIdx) {
    var _a;
    if (!value) {
        // Don't pass a null/undefined or empty string
        return null;
    }
    if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_2__.isArray)(value)) {
        // The value may have been encoded on the page into an array so handle this automatically
        value = value[0] || "";
    }
    if (!value || !(0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_2__.isString)(value) || value[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_LENGTH /* @min:%2elength */] > 8192) {
        // limit potential processing based on total length
        return null;
    }
    if (value.indexOf(",") !== -1) {
        var values = value[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_SPLIT /* @min:%2esplit */](",");
        value = values[selectIdx > 0 && values[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_LENGTH /* @min:%2elength */] > selectIdx ? selectIdx : 0];
    }
    // See https://www.w3.org/TR/trace-context/#versioning-of-traceparent
    var match = TRACE_PARENT_REGEX.exec((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_2__.strTrim)(value));
    if (!match || // No match
        match[1] === INVALID_VERSION || // version ff is forbidden
        match[2] === INVALID_TRACE_ID || // All zeros is considered to be invalid
        match[3] === INVALID_SPAN_ID) { // All zeros is considered to be invalid
        return null;
    }
    return _a = {
            version: (match[1] || _InternalConstants__WEBPACK_IMPORTED_MODULE_3__.STR_EMPTY)[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_TO_LOWER_CASE /* @min:%2etoLowerCase */](),
            traceId: (match[2] || _InternalConstants__WEBPACK_IMPORTED_MODULE_3__.STR_EMPTY)[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_TO_LOWER_CASE /* @min:%2etoLowerCase */](),
            spanId: (match[3] || _InternalConstants__WEBPACK_IMPORTED_MODULE_3__.STR_EMPTY)[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_TO_LOWER_CASE /* @min:%2etoLowerCase */]()
        },
        _a[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_TRACE_FLAGS /* @min:traceFlags */] = parseInt(match[4], 16),
        _a;
}
/**
 * Is the provided W3c Trace Id a valid string representation, it must be a 32-character string
 * of lowercase hexadecimal characters for example, 4bf92f3577b34da6a3ce929d0e0e4736.
 * If all characters as zero (00000000000000000000000000000000) it will be considered an invalid value.
 * @param value - The W3c trace Id to be validated
 * @returns true if valid otherwise false
 */
function isValidTraceId(value) {
    return _isValid(value, 32, INVALID_TRACE_ID);
}
/**
 * Is the provided W3c span id (aka. parent id) a valid string representation, it must be a 16-character
 * string of lowercase hexadecimal characters, for example, 00f067aa0ba902b7.
 * If all characters are zero (0000000000000000) this is considered an invalid value.
 * @param value - The W3c span id to be validated
 * @returns true if valid otherwise false
 */
function isValidSpanId(value) {
    return _isValid(value, 16, INVALID_SPAN_ID);
}
/**
 * Validates that the provided ITraceParent instance conforms to the currently supported specifications
 * @param value
 * @returns
 */
function isValidTraceParent(value) {
    if (!value ||
        !_isValid(value[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_VERSION /* @min:%2eversion */], 2, INVALID_VERSION) ||
        !_isValid(value[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_TRACE_ID /* @min:%2etraceId */], 32, INVALID_TRACE_ID) ||
        !_isValid(value[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_SPAN_ID /* @min:%2espanId */], 16, INVALID_SPAN_ID) ||
        !_isValid(_formatFlags(value[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_TRACE_FLAGS /* @min:%2etraceFlags */]), 2)) {
        // Each known field must contain a valid value
        return false;
    }
    return true;
}
/**
 * Is the parsed traceParent indicating that the trace is currently sampled.
 * @param value - The parsed traceParent value
 * @returns
 */
function isSampledFlag(value) {
    if (isValidTraceParent(value)) {
        return (value[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_TRACE_FLAGS /* @min:%2etraceFlags */] & SAMPLED_FLAG) === SAMPLED_FLAG;
    }
    return false;
}
/**
 * Format the ITraceParent value as a string using the supported and know version formats.
 * So even if the passed traceParent is a later version the string value returned from this
 * function will convert it to only the known version formats.
 * This currently only supports version "00" and invalid "ff"
 * @param value - The parsed traceParent value
 * @returns
 */
function formatTraceParent(value) {
    if (value) {
        // Special Note: This only supports formatting as version 00, future versions should encode any known supported version
        // So parsing a future version will populate the correct version value but reformatting will reduce it to version 00.
        var flags = _formatFlags(value[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_TRACE_FLAGS /* @min:%2etraceFlags */]);
        if (!_isValid(flags, 2)) {
            flags = "01";
        }
        var version = value[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_VERSION /* @min:%2eversion */] || DEFAULT_VERSION;
        if (version !== "00" && version !== "ff") {
            // Reduce version to "00"
            version = DEFAULT_VERSION;
        }
        // Format as version 00
        return "".concat(version.toLowerCase(), "-").concat(_formatValue(value.traceId, 32, INVALID_TRACE_ID).toLowerCase(), "-").concat(_formatValue(value.spanId, 16, INVALID_SPAN_ID).toLowerCase(), "-").concat(flags.toLowerCase());
    }
    return "";
}
/**
 * Helper function to fetch the passed traceparent from the page, looking for it as a meta-tag or a Server-Timing header.
 * @param selectIdx - If the found value is comma separated which is the preferred entry to select, defaults to the first
 * @returns
 */
function findW3cTraceParent(selectIdx) {
    var name = "traceparent";
    var traceParent = parseTraceParent((0,_EnvUtils__WEBPACK_IMPORTED_MODULE_4__.findMetaTag)(name), selectIdx);
    if (!traceParent) {
        traceParent = parseTraceParent((0,_EnvUtils__WEBPACK_IMPORTED_MODULE_4__.findNamedServerTiming)(name), selectIdx);
    }
    return traceParent;
}
//# sourceMappingURL=W3cTraceParent.js.map

/***/ }),
/* 64 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TelemetryInitializerPlugin": () => (/* binding */ TelemetryInitializerPlugin)
/* harmony export */ });
/* harmony import */ var _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(33);
/* harmony import */ var _microsoft_dynamicproto_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(35);
/* harmony import */ var _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(30);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(38);
/* harmony import */ var _BaseTelemetryPlugin__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(65);
/* harmony import */ var _DiagnosticLogger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(50);
/* harmony import */ var _HelperFuncs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(45);
/* harmony import */ var _InternalConstants__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(39);
/*
 * Application Insights JavaScript SDK - Core, 3.3.0
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */
// 
// 








function _addInitializer(_initializers, id, telemetryInitializer) {
    var theInitializer = {
        id: id,
        fn: telemetryInitializer
    };
    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrAppend)(_initializers, theInitializer);
    var handler = {
        remove: function () {
            (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrForEach)(_initializers, function (initializer, idx) {
                if (initializer.id === theInitializer.id) {
                    _initializers[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_SPLICE /* @min:%2esplice */](idx, 1);
                    return -1;
                }
            });
        }
    };
    return handler;
}
function _runInitializers(_initializers, item, logger) {
    var doNotSendItem = false;
    var telemetryInitializersCount = _initializers[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LENGTH /* @min:%2elength */];
    for (var i = 0; i < telemetryInitializersCount; ++i) {
        var telemetryInitializer = _initializers[i];
        if (telemetryInitializer) {
            try {
                if (telemetryInitializer.fn[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_APPLY /* @min:%2eapply */](null, [item]) === false) {
                    doNotSendItem = true;
                    break;
                }
            }
            catch (e) {
                // log error but dont stop executing rest of the telemetry initializers
                // doNotSendItem = true;
                (0,_DiagnosticLogger__WEBPACK_IMPORTED_MODULE_2__._throwInternal)(logger, 2 /* eLoggingSeverity.WARNING */, 64 /* _eInternalMessageId.TelemetryInitializerFailed */, "Telemetry initializer failed: " + (0,_HelperFuncs__WEBPACK_IMPORTED_MODULE_3__.getExceptionName)(e), { exception: (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.dumpObj)(e) }, true);
            }
        }
    }
    return !doNotSendItem;
}
var TelemetryInitializerPlugin = /** @class */ (function (_super) {
    (0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_4__.__extendsFn)(TelemetryInitializerPlugin, _super);
    function TelemetryInitializerPlugin() {
        var _this = _super.call(this) || this;
        _this.identifier = "TelemetryInitializerPlugin";
        _this.priority = 199;
        // NOTE!: DON'T set default values here, instead set them in the _initDefaults() function as it is also called during teardown()
        var _id;
        var _initializers;
        _initDefaults();
        (0,_microsoft_dynamicproto_js__WEBPACK_IMPORTED_MODULE_5__["default"])(TelemetryInitializerPlugin, _this, function (_self, _base) {
            _self.addTelemetryInitializer = function (telemetryInitializer) {
                return _addInitializer(_initializers, _id++, telemetryInitializer);
            };
            _self[_InternalConstants__WEBPACK_IMPORTED_MODULE_6__.STR_PROCESS_TELEMETRY /* @min:%2eprocessTelemetry */] = function (item, itemCtx) {
                if (_runInitializers(_initializers, item, itemCtx ? itemCtx[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_DIAG_LOG /* @min:%2ediagLog */]() : _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_DIAG_LOG /* @min:%2ediagLog */]())) {
                    _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_PROCESS_NEXT /* @min:%2eprocessNext */](item, itemCtx);
                }
            };
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN__DO_TEARDOWN /* @min:%2e_doTeardown */] = function () {
                _initDefaults();
            };
        });
        function _initDefaults() {
            _id = 0;
            _initializers = [];
        }
        return _this;
    }
// Removed Stub for TelemetryInitializerPlugin.prototype.addTelemetryInitializer.
// Removed Stub for TelemetryInitializerPlugin.prototype.processTelemetry.
    // This is a workaround for an IE bug when using dynamicProto() with classes that don't have any
    // non-dynamic functions or static properties/functions when using uglify-js to minify the resulting code.
    TelemetryInitializerPlugin.__ieDyn=1;

    return TelemetryInitializerPlugin;
}(_BaseTelemetryPlugin__WEBPACK_IMPORTED_MODULE_7__.BaseTelemetryPlugin));

//# sourceMappingURL=TelemetryInitializerPlugin.js.map

/***/ }),
/* 65 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BaseTelemetryPlugin": () => (/* binding */ BaseTelemetryPlugin)
/* harmony export */ });
/* harmony import */ var _microsoft_dynamicproto_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(35);
/* harmony import */ var _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(30);
/* harmony import */ var _Config_DynamicConfig__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(40);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(38);
/* harmony import */ var _DiagnosticLogger__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(50);
/* harmony import */ var _HelperFuncs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(45);
/* harmony import */ var _InternalConstants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(39);
/* harmony import */ var _ProcessTelemetryContext__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(61);
/* harmony import */ var _UnloadHandlerContainer__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(67);
/* harmony import */ var _UnloadHookContainer__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(66);
/*
 * Application Insights JavaScript SDK - Core, 3.3.0
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */



var _a;










var strGetPlugin = "getPlugin";
var defaultValues = (_a = {},
    _a[_InternalConstants__WEBPACK_IMPORTED_MODULE_0__.STR_EXTENSION_CONFIG] = { isVal: _HelperFuncs__WEBPACK_IMPORTED_MODULE_1__.isNotNullOrUndefined, v: {} },
    _a);
/**
 * BaseTelemetryPlugin provides a basic implementation of the ITelemetryPlugin interface so that plugins
 * can avoid implementation the same set of boiler plate code as well as provide a base
 * implementation so that new default implementations can be added without breaking all plugins.
 */
var BaseTelemetryPlugin = /** @class */ (function () {
    function BaseTelemetryPlugin() {
        var _self = this; // Setting _self here as it's used outside of the dynamicProto as well
        // NOTE!: DON'T set default values here, instead set them in the _initDefaults() function as it is also called during teardown()
        var _isinitialized;
        var _rootCtx; // Used as the root context, holding the current config and initialized core
        var _nextPlugin; // Used for backward compatibility where plugins don't call the main pipeline
        var _unloadHandlerContainer;
        var _hookContainer;
        _initDefaults();
        (0,_microsoft_dynamicproto_js__WEBPACK_IMPORTED_MODULE_2__["default"])(BaseTelemetryPlugin, _self, function (_self) {
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_INITIALIZE /* @min:%2einitialize */] = function (config, core, extensions, pluginChain) {
                _setDefaults(config, core, pluginChain);
                _isinitialized = true;
            };
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_TEARDOWN /* @min:%2eteardown */] = function (unloadCtx, unloadState) {
                var _a;
                // If this plugin has already been torn down (not operational) or is not initialized (core is not set)
                // or the core being used for unload was not the same core used for initialization.
                var core = _self[_InternalConstants__WEBPACK_IMPORTED_MODULE_0__.STR_CORE /* @min:%2ecore */];
                if (!core || (unloadCtx && core !== unloadCtx[_InternalConstants__WEBPACK_IMPORTED_MODULE_0__.STR_CORE /* @min:%2ecore */]())) {
                    // Do Nothing as either the plugin is not initialized or was not initialized by the current core
                    return;
                }
                var result;
                var unloadDone = false;
                var theUnloadCtx = unloadCtx || (0,_ProcessTelemetryContext__WEBPACK_IMPORTED_MODULE_4__.createProcessTelemetryUnloadContext)(null, core, _nextPlugin && _nextPlugin[strGetPlugin] ? _nextPlugin[strGetPlugin]() : _nextPlugin);
                var theUnloadState = unloadState || (_a = {
                        reason: 0 /* TelemetryUnloadReason.ManualTeardown */
                    },
                    _a[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_IS_ASYNC /* @min:isAsync */] = false,
                    _a);
                function _unloadCallback() {
                    if (!unloadDone) {
                        unloadDone = true;
                        _unloadHandlerContainer.run(theUnloadCtx, unloadState);
                        _hookContainer.run(theUnloadCtx[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_DIAG_LOG /* @min:%2ediagLog */]());
                        if (result === true) {
                            theUnloadCtx[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_PROCESS_NEXT /* @min:%2eprocessNext */](theUnloadState);
                        }
                        _initDefaults();
                    }
                }
                if (!_self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN__DO_TEARDOWN /* @min:%2e_doTeardown */] || _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN__DO_TEARDOWN /* @min:%2e_doTeardown */](theUnloadCtx, theUnloadState, _unloadCallback) !== true) {
                    _unloadCallback();
                }
                else {
                    // Tell the caller that we will be calling processNext()
                    result = true;
                }
                return result;
            };
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_UPDATE /* @min:%2eupdate */] = function (updateCtx, updateState) {
                // If this plugin has already been torn down (not operational) or is not initialized (core is not set)
                // or the core being used for unload was not the same core used for initialization.
                var core = _self[_InternalConstants__WEBPACK_IMPORTED_MODULE_0__.STR_CORE /* @min:%2ecore */];
                if (!core || (updateCtx && core !== updateCtx[_InternalConstants__WEBPACK_IMPORTED_MODULE_0__.STR_CORE /* @min:%2ecore */]())) {
                    // Do Nothing
                    return;
                }
                var result;
                var updateDone = false;
                var theUpdateCtx = updateCtx || (0,_ProcessTelemetryContext__WEBPACK_IMPORTED_MODULE_4__.createProcessTelemetryUpdateContext)(null, core, _nextPlugin && _nextPlugin[strGetPlugin] ? _nextPlugin[strGetPlugin]() : _nextPlugin);
                var theUpdateState = updateState || {
                    reason: 0 /* TelemetryUpdateReason.Unknown */
                };
                function _updateCallback() {
                    if (!updateDone) {
                        updateDone = true;
                        _setDefaults(theUpdateCtx.getCfg(), theUpdateCtx.core(), theUpdateCtx[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_GET_NEXT /* @min:%2egetNext */]());
                    }
                }
                if (!_self._doUpdate || _self._doUpdate(theUpdateCtx, theUpdateState, _updateCallback) !== true) {
                    _updateCallback();
                }
                else {
                    result = true;
                }
                return result;
            };
            (0,_HelperFuncs__WEBPACK_IMPORTED_MODULE_1__.proxyFunctionAs)(_self, "_addUnloadCb", function () { return _unloadHandlerContainer; }, "add");
            (0,_HelperFuncs__WEBPACK_IMPORTED_MODULE_1__.proxyFunctionAs)(_self, "_addHook", function () { return _hookContainer; }, "add");
            (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_5__.objDefine)(_self, "_unloadHooks", { g: function () { return _hookContainer; } });
        });
        // These are added after the dynamicProto so that are not moved to the prototype
        _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_DIAG_LOG /* @min:%2ediagLog */] = function (itemCtx) {
            return _getTelCtx(itemCtx)[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_DIAG_LOG /* @min:%2ediagLog */]();
        };
        _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_IS_INITIALIZED /* @min:%2eisInitialized */] = function () {
            return _isinitialized;
        };
        _self.setInitialized = function (isInitialized) {
            _isinitialized = isInitialized;
        };
        // _self.getNextPlugin = () => DO NOT IMPLEMENT
        // Sub-classes of this base class *should* not be relying on this value and instead
        // should use processNext() function. If you require access to the plugin use the
        // IProcessTelemetryContext.getNext().getPlugin() while in the pipeline, Note getNext() may return null.
        _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_SET_NEXT_PLUGIN /* @min:%2esetNextPlugin */] = function (next) {
            _nextPlugin = next;
        };
        _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_PROCESS_NEXT /* @min:%2eprocessNext */] = function (env, itemCtx) {
            if (itemCtx) {
                // Normal core execution sequence
                itemCtx[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_PROCESS_NEXT /* @min:%2eprocessNext */](env);
            }
            else if (_nextPlugin && (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_5__.isFunction)(_nextPlugin[_InternalConstants__WEBPACK_IMPORTED_MODULE_0__.STR_PROCESS_TELEMETRY /* @min:%2eprocessTelemetry */])) {
                // Looks like backward compatibility or out of band processing. And as it looks
                // like a ITelemetryPlugin or ITelemetryPluginChain, just call processTelemetry
                _nextPlugin[_InternalConstants__WEBPACK_IMPORTED_MODULE_0__.STR_PROCESS_TELEMETRY /* @min:%2eprocessTelemetry */](env, null);
            }
        };
        _self._getTelCtx = _getTelCtx;
        function _getTelCtx(currentCtx) {
            if (currentCtx === void 0) { currentCtx = null; }
            var itemCtx = currentCtx;
            if (!itemCtx) {
                var rootCtx = _rootCtx || (0,_ProcessTelemetryContext__WEBPACK_IMPORTED_MODULE_4__.createProcessTelemetryContext)(null, {}, _self[_InternalConstants__WEBPACK_IMPORTED_MODULE_0__.STR_CORE /* @min:%2ecore */]);
                // tslint:disable-next-line: prefer-conditional-expression
                if (_nextPlugin && _nextPlugin[strGetPlugin]) {
                    // Looks like a chain object
                    itemCtx = rootCtx[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_CREATE_NEW /* @min:%2ecreateNew */](null, _nextPlugin[strGetPlugin]);
                }
                else {
                    itemCtx = rootCtx[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_CREATE_NEW /* @min:%2ecreateNew */](null, _nextPlugin);
                }
            }
            return itemCtx;
        }
        function _setDefaults(config, core, pluginChain) {
            // Make sure the extensionConfig exists and the config is dynamic
            (0,_Config_DynamicConfig__WEBPACK_IMPORTED_MODULE_6__.createDynamicConfig)(config, defaultValues, (0,_DiagnosticLogger__WEBPACK_IMPORTED_MODULE_7__.safeGetLogger)(core));
            if (!pluginChain && core) {
                // Get the first plugin from the core
                pluginChain = core[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_GET_PROCESS_TEL_CONT2 /* @min:%2egetProcessTelContext */]()[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_GET_NEXT /* @min:%2egetNext */]();
            }
            var nextPlugin = _nextPlugin;
            if (_nextPlugin && _nextPlugin[strGetPlugin]) {
                // If it looks like a proxy/chain then get the plugin
                nextPlugin = _nextPlugin[strGetPlugin]();
            }
            // Support legacy plugins where core was defined as a property
            _self[_InternalConstants__WEBPACK_IMPORTED_MODULE_0__.STR_CORE /* @min:%2ecore */] = core;
            _rootCtx = (0,_ProcessTelemetryContext__WEBPACK_IMPORTED_MODULE_4__.createProcessTelemetryContext)(pluginChain, config, core, nextPlugin);
        }
        function _initDefaults() {
            _isinitialized = false;
            _self[_InternalConstants__WEBPACK_IMPORTED_MODULE_0__.STR_CORE /* @min:%2ecore */] = null;
            _rootCtx = null;
            _nextPlugin = null;
            _hookContainer = (0,_UnloadHookContainer__WEBPACK_IMPORTED_MODULE_8__.createUnloadHookContainer)();
            _unloadHandlerContainer = (0,_UnloadHandlerContainer__WEBPACK_IMPORTED_MODULE_9__.createUnloadHandlerContainer)();
        }
    }
// Removed Stub for BaseTelemetryPlugin.prototype.initialize.
// Removed Stub for BaseTelemetryPlugin.prototype.teardown.
// Removed Stub for BaseTelemetryPlugin.prototype.update.
// Removed Stub for BaseTelemetryPlugin.prototype._addUnloadCb.
// Removed Stub for BaseTelemetryPlugin.prototype._addHook.
    // This is a workaround for an IE bug when using dynamicProto() with classes that don't have any
    // non-dynamic functions or static properties/functions when using uglify-js to minify the resulting code.
    BaseTelemetryPlugin.__ieDyn=1;

    return BaseTelemetryPlugin;
}());

//# sourceMappingURL=BaseTelemetryPlugin.js.map

/***/ }),
/* 66 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "_testHookMaxUnloadHooksCb": () => (/* binding */ _testHookMaxUnloadHooksCb),
/* harmony export */   "createUnloadHookContainer": () => (/* binding */ createUnloadHookContainer)
/* harmony export */ });
/* harmony import */ var _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(30);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(38);
/* harmony import */ var _DiagnosticLogger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(50);
/*
 * Application Insights JavaScript SDK - Core, 3.3.0
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */





var _maxHooks;
var _hookAddMonitor;
/**
 * Test hook for setting the maximum number of unload hooks and calling a monitor function when the hooks are added or removed
 * This allows for automatic test failure when the maximum number of unload hooks is exceeded
 * @param maxHooks - The maximum number of unload hooks
 * @param addMonitor - The monitor function to call when hooks are added or removed
 */
function _testHookMaxUnloadHooksCb(maxHooks, addMonitor) {
    _maxHooks = maxHooks;
    _hookAddMonitor = addMonitor;
}
/**
 * Create a IUnloadHookContainer which can be used to remember unload hook functions to be executed during the component unloading
 * process.
 * @returns A new IUnloadHookContainer instance
 */
function createUnloadHookContainer() {
    var _hooks = [];
    function _doUnload(logger) {
        var oldHooks = _hooks;
        _hooks = [];
        // Remove all registered unload hooks
        (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrForEach)(oldHooks, function (fn) {
            // allow either rm or remove callback function
            try {
                (fn.rm || fn.remove).call(fn);
            }
            catch (e) {
                (0,_DiagnosticLogger__WEBPACK_IMPORTED_MODULE_1__._throwInternal)(logger, 2 /* eLoggingSeverity.WARNING */, 73 /* _eInternalMessageId.PluginException */, "Unloading:" + (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.dumpObj)(e));
            }
        });
        if (_maxHooks && oldHooks[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_LENGTH /* @min:%2elength */] > _maxHooks) {
            _hookAddMonitor ? _hookAddMonitor("doUnload", oldHooks) : (0,_DiagnosticLogger__WEBPACK_IMPORTED_MODULE_1__._throwInternal)(null, 1 /* eLoggingSeverity.CRITICAL */, 48 /* _eInternalMessageId.MaxUnloadHookExceeded */, "Max unload hooks exceeded. An excessive number of unload hooks has been detected.");
        }
    }
    function _addHook(hooks) {
        if (hooks) {
            (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrAppend)(_hooks, hooks);
            if (_maxHooks && _hooks[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_LENGTH /* @min:%2elength */] > _maxHooks) {
                _hookAddMonitor ? _hookAddMonitor("Add", _hooks) : (0,_DiagnosticLogger__WEBPACK_IMPORTED_MODULE_1__._throwInternal)(null, 1 /* eLoggingSeverity.CRITICAL */, 48 /* _eInternalMessageId.MaxUnloadHookExceeded */, "Max unload hooks exceeded. An excessive number of unload hooks has been detected.");
            }
        }
    }
    return {
        run: _doUnload,
        add: _addHook
    };
}
//# sourceMappingURL=UnloadHookContainer.js.map

/***/ }),
/* 67 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createUnloadHandlerContainer": () => (/* binding */ createUnloadHandlerContainer)
/* harmony export */ });
/* harmony import */ var _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(30);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38);
/* harmony import */ var _DiagnosticLogger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(50);
/*
 * Application Insights JavaScript SDK - Core, 3.3.0
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */





function createUnloadHandlerContainer() {
    var handlers = [];
    function _addHandler(handler) {
        if (handler) {
            handlers[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_PUSH /* @min:%2epush */](handler);
        }
    }
    function _runHandlers(unloadCtx, unloadState) {
        (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.arrForEach)(handlers, function (handler) {
            try {
                handler(unloadCtx, unloadState);
            }
            catch (e) {
                (0,_DiagnosticLogger__WEBPACK_IMPORTED_MODULE_2__._throwInternal)(unloadCtx[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_DIAG_LOG /* @min:%2ediagLog */](), 2 /* eLoggingSeverity.WARNING */, 73 /* _eInternalMessageId.PluginException */, "Unexpected error calling unload handler - " + (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.dumpObj)(e));
            }
        });
        handlers = [];
    }
    return {
        add: _addHandler,
        run: _runHandlers
    };
}
//# sourceMappingURL=UnloadHandlerContainer.js.map

/***/ }),
/* 68 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ChannelControllerPriority": () => (/* binding */ ChannelControllerPriority),
/* harmony export */   "DisabledPropertyName": () => (/* binding */ DisabledPropertyName)
/* harmony export */ });
/*
 * Application Insights JavaScript SDK - Core, 3.3.0
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */


var ChannelControllerPriority = 500;
var DisabledPropertyName = "Microsoft_ApplicationInsights_BypassAjaxInstrumentation";
// export const SampleRate = "sampleRate";
// export const ProcessLegacy = "ProcessLegacy";
// export const HttpMethod = "http.method";
// export const DEFAULT_BREEZE_ENDPOINT = "https://dc.services.visualstudio.com";
// export const DEFAULT_BREEZE_PATH = "/v2/track";
// export const strNotSpecified = "not_specified";
// export const strIkey = "iKey";
//# sourceMappingURL=Constants.js.map

/***/ }),
/* 69 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ValueSanitizer": () => (/* binding */ ValueSanitizer)
/* harmony export */ });
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(30);
/* harmony import */ var _InternalConstants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(32);
/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(52);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(36);
/*
 * 1DS JS SDK Core, 4.3.0
 * Copyright (c) Microsoft and contributors. All rights reserved.
 * (Microsoft Internal Only)
 */





var ValueSanitizer = /** @class */ (function () {
    function ValueSanitizer(fieldSanitizerProvider) {
        var _self = this;
        // To aid with performance this is a lookup map to check if the field value sanitizer supports this field
        var _sanitizerMap = {};
        var _sanitizers = [];
        var _fieldSanitizers = [];
        if (fieldSanitizerProvider) {
            _fieldSanitizers.push(fieldSanitizerProvider);
        }
        function _getFieldSanitizer(path, name) {
            var result;
            var fieldLookup = _sanitizerMap[path];
            if (fieldLookup) {
                result = fieldLookup[name];
            }
            if (!result && result !== null) {
                // Null is a valid result indicating that the value sanitizer does not support this field
                if ((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.isString)(path) && (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.isString)(name)) {
                    if (_fieldSanitizers[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LENGTH /* @min:%2elength */] > 0) {
                        for (var lp = 0; lp < _fieldSanitizers[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LENGTH /* @min:%2elength */]; lp++) {
                            if (_fieldSanitizers[lp][_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_HANDLE_FIELD /* @min:%2ehandleField */](path, name)) {
                                result = {
                                    canHandle: true,
                                    fieldHandler: _fieldSanitizers[lp]
                                };
                                break;
                            }
                        }
                    }
                    else if (_sanitizers[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LENGTH /* @min:%2elength */] === 0) {
                        // Special use-case where there is no sanitizer to pass on to, so just resolving the field
                        // and returning the resulting value (same as sanitizeProperty())
                        result = {
                            canHandle: true
                        };
                    }
                }
                // We still don't have a handler so lets lookup the providers
                if (!result && result !== null) {
                    // Setting the result to null -- which means we and any contained sanitizers can't handle this field
                    result = null;
                    for (var lp = 0; lp < _sanitizers[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LENGTH /* @min:%2elength */]; lp++) {
                        if (_sanitizers[lp][_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_HANDLE_FIELD /* @min:%2ehandleField */](path, name)) {
                            result = {
                                canHandle: true,
                                handler: _sanitizers[lp],
                                fieldHandler: null
                            };
                            break;
                        }
                    }
                }
                if (!fieldLookup) {
                    fieldLookup = _sanitizerMap[path] = {};
                }
                fieldLookup[name] = result;
            }
            return result;
        }
        _self.clearCache = function () {
            _sanitizerMap = {};
        };
        _self.addSanitizer = function (newSanitizer) {
            if (newSanitizer) {
                if (!(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.arrIncludes)(_sanitizers, newSanitizer)) {
                    _sanitizers.push(newSanitizer);
                }
                // Invalidate any previously mapped fields
                _sanitizerMap = {};
            }
        };
        _self.addFieldSanitizer = function (fieldSanitizer) {
            if (fieldSanitizer) {
                if (!(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.arrIncludes)(_fieldSanitizers, fieldSanitizer)) {
                    _fieldSanitizers.push(fieldSanitizer);
                }
                // Invalidate any previously mapped fields
                _sanitizerMap = {};
            }
        };
        _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_RM_SANITIZER /* @min:%2ermSanitizer */] = function (theSanitizer) {
            if (theSanitizer) {
                var idx = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.arrIndexOf)(_sanitizers, theSanitizer);
                if (idx !== -1) {
                    _sanitizers.splice(idx, 1);
                    // Invalidate any previously mapped fields
                    _sanitizerMap = {};
                }
                // Try and remove the sanitizer from any chained sanitizer as well
                (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.arrForEach)(_sanitizers, function (sanitizer) {
                    sanitizer && sanitizer[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_RM_SANITIZER /* @min:%2ermSanitizer */] && sanitizer[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_RM_SANITIZER /* @min:%2ermSanitizer */](theSanitizer);
                });
            }
        };
        _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_RM_FIELD_SANITIZER /* @min:%2ermFieldSanitizer */] = function (theFieldSanitizer) {
            if (theFieldSanitizer) {
                var idx = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.arrIndexOf)(_fieldSanitizers, theFieldSanitizer);
                if (idx !== -1) {
                    _fieldSanitizers.splice(idx, 1);
                    // Invalidate any previously mapped fields
                    _sanitizerMap = {};
                }
                // Try and remove the field sanitizer from any chained sanitizer as well
                (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.arrForEach)(_sanitizers, function (sanitizer) {
                    sanitizer && sanitizer[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_RM_FIELD_SANITIZER /* @min:%2ermFieldSanitizer */] && sanitizer[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_RM_FIELD_SANITIZER /* @min:%2ermFieldSanitizer */](theFieldSanitizer);
                });
            }
        };
        _self.isEmpty = function () {
            return ((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.getLength)(_sanitizers) + (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.getLength)(_fieldSanitizers)) === 0;
        };
        _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_HANDLE_FIELD /* @min:%2ehandleField */] = function (path, name) {
            var mapValue = _getFieldSanitizer(path, name);
            return mapValue ? mapValue[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_CAN_HANDLE /* @min:%2ecanHandle */] : false;
        };
        _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_VALUE /* @min:%2evalue */] = function (path, name, value, stringifyObjects) {
            var mapValue = _getFieldSanitizer(path, name);
            if (mapValue && mapValue[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_CAN_HANDLE /* @min:%2ecanHandle */]) {
                if (!mapValue || !mapValue[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_CAN_HANDLE /* @min:%2ecanHandle */]) {
                    return null;
                }
                if (mapValue.handler) {
                    // This value sanitizer can't handle this field so pass it only the next one
                    return mapValue.handler[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_VALUE /* @min:%2evalue */](path, name, value, stringifyObjects);
                }
                // Check that property is valid
                if (!(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.isString)(name) || (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(value) || value === _InternalConstants__WEBPACK_IMPORTED_MODULE_2__.STR_EMPTY) {
                    return null;
                }
                var property = null;
                var fieldType = (0,_Utils__WEBPACK_IMPORTED_MODULE_3__.getFieldValueType)(value);
                if ((fieldType & 8192 /* FieldValueSanitizerType.EventProperty */) === 8192 /* FieldValueSanitizerType.EventProperty */) {
                    var subType = fieldType & ~8192 /* FieldValueSanitizerType.EventProperty */;
                    property = value;
                    if (!(0,_Utils__WEBPACK_IMPORTED_MODULE_3__.isValueAssigned)(property[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_VALUE /* @min:%2evalue */]) ||
                        (subType !== 1 /* FieldValueSanitizerType.String */ &&
                            subType !== 2 /* FieldValueSanitizerType.Number */ &&
                            subType !== 3 /* FieldValueSanitizerType.Boolean */ &&
                            (subType & 4096 /* FieldValueSanitizerType.Array */) !== 4096 /* FieldValueSanitizerType.Array */)) {
                        // Not a supported IEventProperty type to be able to sanitize
                        return null;
                    }
                }
                else if (fieldType === 1 /* FieldValueSanitizerType.String */ ||
                    fieldType === 2 /* FieldValueSanitizerType.Number */ ||
                    fieldType === 3 /* FieldValueSanitizerType.Boolean */ ||
                    (fieldType & 4096 /* FieldValueSanitizerType.Array */) === 4096 /* FieldValueSanitizerType.Array */) {
                    // If the property isn't IEventProperty (and is either string, number, boolean or array), convert it into one.
                    property = _convertToProperty(path, name, value);
                }
                else if (fieldType === 4 /* FieldValueSanitizerType.Object */) {
                    property = _convertToProperty(path, name, !!stringifyObjects ? JSON.stringify(value) : value);
                }
                if (property) {
                    return _handleProperty(mapValue, path, name, fieldType, property, stringifyObjects);
                }
            }
            return null;
        };
        _self.property = function (path, name, property, stringifyObjects) {
            var mapValue = _getFieldSanitizer(path, name);
            if (!mapValue || !mapValue[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_CAN_HANDLE /* @min:%2ecanHandle */]) {
                return null;
            }
            // Check that property is valid
            if (!(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.isString)(name) || (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(property) || !(0,_Utils__WEBPACK_IMPORTED_MODULE_3__.isValueAssigned)(property[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_VALUE /* @min:%2evalue */])) {
                return null;
            }
            var fieldType = (0,_Utils__WEBPACK_IMPORTED_MODULE_3__.getFieldValueType)(property[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_VALUE /* @min:%2evalue */]);
            if (fieldType === 0 /* FieldValueSanitizerType.NotSet */) {
                // Not a supported field that we can sanitize or serialize
                return null;
            }
            return _handleProperty(mapValue, path, name, fieldType, property, stringifyObjects);
        };
        function _handleProperty(mapValue, path, name, fieldType, property, stringifyObjects) {
            if (mapValue.handler) {
                // This value sanitizer can't handle this field so pass it only the next one
                return mapValue.handler.property(path, name, property, stringifyObjects);
            }
            // If either pii or cc is set convert value to string (since only string pii/cc is allowed).
            // If the value is a complex type like an array that can't be converted to string we will drop
            // the property.
            if (!(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(property[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_KIND /* @min:%2ekind */])) {
                if ((fieldType & 4096 /* FieldValueSanitizerType.Array */) === 4096 /* FieldValueSanitizerType.Array */ || !(0,_Utils__WEBPACK_IMPORTED_MODULE_3__.isValueKind)(property[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_KIND /* @min:%2ekind */])) {
                    return null;
                }
                // Convert the value to a string and assign back to the original value
                property[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_VALUE /* @min:%2evalue */] = property[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_VALUE /* @min:%2evalue */].toString();
            }
            return _callFieldSanitizer(mapValue.fieldHandler, path, name, fieldType, property);
        }
        function _convertToProperty(path, name, value) {
            if ((0,_Utils__WEBPACK_IMPORTED_MODULE_3__.isValueAssigned)(value)) {
                return { value: value };
            }
            return null;
        }
        function _callFieldSanitizer(fieldProvider, path, name, theType, property) {
            if (property && fieldProvider) {
                var sanitizer = fieldProvider.getSanitizer(path, name, theType, property[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_KIND /* @min:%2ekind */], property.propertyType);
                if (sanitizer) {
                    // This is where we the field will call the handler to "scrub" the value. This the primary hook for the ClientHashing Plugin to
                    // be able to apply the hashFunc() / Sha256 conversion of the properties value
                    if (theType === 4 /* FieldValueSanitizerType.Object */) {
                        // Special case of an embedded object (ext.metadata, data.properties)
                        var newValue_1 = {};
                        var propValue = property[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_VALUE /* @min:%2evalue */];
                        (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.objForEachKey)(propValue, function (propKey, theValue) {
                            var newPath = path + "." + name;
                            if ((0,_Utils__WEBPACK_IMPORTED_MODULE_3__.isValueAssigned)(theValue)) {
                                var newProp = _convertToProperty(newPath, propKey, theValue);
                                newProp = _callFieldSanitizer(fieldProvider, newPath, propKey, (0,_Utils__WEBPACK_IMPORTED_MODULE_3__.getFieldValueType)(theValue), newProp);
                                if (newProp) {
                                    newValue_1[propKey] = newProp[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_VALUE /* @min:%2evalue */];
                                }
                            }
                        });
                        property[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_VALUE /* @min:%2evalue */] = newValue_1;
                    }
                    else {
                        var details = {
                            path: path,
                            name: name,
                            type: theType,
                            prop: property,
                            sanitizer: _self
                        };
                        property = sanitizer.call(_self, details);
                    }
                }
            }
            return property;
        }
    }
    ValueSanitizer.getFieldType = _Utils__WEBPACK_IMPORTED_MODULE_3__.getFieldValueType;
    return ValueSanitizer;
}());

//# sourceMappingURL=ValueSanitizer.js.map

/***/ }),
/* 70 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MinChannelPriorty": () => (/* binding */ MinChannelPriorty)
/* harmony export */ });
/*
 * Application Insights JavaScript SDK - Core, 3.3.0
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */

var MinChannelPriorty = 100;
//# sourceMappingURL=IChannelControls.js.map

/***/ }),
/* 71 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BatchDiscardedReason": () => (/* binding */ BatchDiscardedReason),
/* harmony export */   "EventsDiscardedReason": () => (/* binding */ EventsDiscardedReason)
/* harmony export */ });
/* harmony import */ var _JavaScriptSDK_Enums_EnumHelperFuncs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(29);
/*
 * Application Insights JavaScript SDK - Core, 3.3.0
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */



/**
 * The EventsDiscardedReason enumeration contains a set of values that specify the reason for discarding an event.
 */
var EventsDiscardedReason = (0,_JavaScriptSDK_Enums_EnumHelperFuncs__WEBPACK_IMPORTED_MODULE_0__.createEnumStyle)({
    /**
     * Unknown.
     */
    Unknown: 0 /* eEventsDiscardedReason.Unknown */,
    /**
     * Status set to non-retryable.
     */
    NonRetryableStatus: 1 /* eEventsDiscardedReason.NonRetryableStatus */,
    /**
     * The event is invalid.
     */
    InvalidEvent: 2 /* eEventsDiscardedReason.InvalidEvent */,
    /**
     * The size of the event is too large.
     */
    SizeLimitExceeded: 3 /* eEventsDiscardedReason.SizeLimitExceeded */,
    /**
     * The server is not accepting events from this instrumentation key.
     */
    KillSwitch: 4 /* eEventsDiscardedReason.KillSwitch */,
    /**
     * The event queue is full.
     */
    QueueFull: 5 /* eEventsDiscardedReason.QueueFull */
});
/**
 *  The eBatchDiscardedReason enumeration contains a set of values that specify the reason for discarding offline batches.
 */
var BatchDiscardedReason = (0,_JavaScriptSDK_Enums_EnumHelperFuncs__WEBPACK_IMPORTED_MODULE_0__.createEnumStyle)({
    /**
     * Unknown.
     */
    Unknown: 0 /* eBatchDiscardedReason.Unknown */,
    /**
      * Status set to non-retryable after sending
      */
    NonRetryableStatus: 1 /* eBatchDiscardedReason.NonRetryableStatus */,
    /**
     * Batches with lower number of critical events are dropped to free up storage space
     */
    CleanStorage: 2 /* eBatchDiscardedReason.CleanStorage */,
    /**
     * The batches in storage exceed max allowed time
     */
    MaxInStorageTimeExceeded: 3 /* eBatchDiscardedReason.MaxInStorageTimeExceeded */
});
//# sourceMappingURL=EventsDiscardedReason.js.map

/***/ }),
/* 72 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LoggingSeverity": () => (/* binding */ LoggingSeverity)
/* harmony export */ });
/* harmony import */ var _JavaScriptSDK_Enums_EnumHelperFuncs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(29);
/*
 * Application Insights JavaScript SDK - Core, 3.3.0
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */


//  @skip-file-minify

var LoggingSeverity = (0,_JavaScriptSDK_Enums_EnumHelperFuncs__WEBPACK_IMPORTED_MODULE_0__.createEnumStyle)({
    DISABLED: 0 /* eLoggingSeverity.DISABLED */,
    CRITICAL: 1 /* eLoggingSeverity.CRITICAL */,
    WARNING: 2 /* eLoggingSeverity.WARNING */,
    DEBUG: 3 /* eLoggingSeverity.DEBUG */
});
//# sourceMappingURL=LoggingEnums.js.map

/***/ }),
/* 73 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "__getRegisteredEvents": () => (/* binding */ __getRegisteredEvents),
/* harmony export */   "addEventHandler": () => (/* binding */ addEventHandler),
/* harmony export */   "addEventListeners": () => (/* binding */ addEventListeners),
/* harmony export */   "addPageHideEventListener": () => (/* binding */ addPageHideEventListener),
/* harmony export */   "addPageShowEventListener": () => (/* binding */ addPageShowEventListener),
/* harmony export */   "addPageUnloadEventListener": () => (/* binding */ addPageUnloadEventListener),
/* harmony export */   "attachEvent": () => (/* binding */ attachEvent),
/* harmony export */   "detachEvent": () => (/* binding */ detachEvent),
/* harmony export */   "eventOff": () => (/* binding */ eventOff),
/* harmony export */   "eventOn": () => (/* binding */ eventOn),
/* harmony export */   "mergeEvtNamespace": () => (/* binding */ mergeEvtNamespace),
/* harmony export */   "removeEventHandler": () => (/* binding */ removeEventHandler),
/* harmony export */   "removeEventListeners": () => (/* binding */ removeEventListeners),
/* harmony export */   "removePageHideEventListener": () => (/* binding */ removePageHideEventListener),
/* harmony export */   "removePageShowEventListener": () => (/* binding */ removePageShowEventListener),
/* harmony export */   "removePageUnloadEventListener": () => (/* binding */ removePageUnloadEventListener)
/* harmony export */ });
/* harmony import */ var _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(30);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(38);
/* harmony import */ var _DataCacheHelper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(42);
/* harmony import */ var _InternalConstants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(39);
/*
 * Application Insights JavaScript SDK - Core, 3.3.0
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */






// Added to help with minfication
var strOnPrefix = "on";
var strAttachEvent = "attachEvent";
var strAddEventHelper = "addEventListener";
var strDetachEvent = "detachEvent";
var strRemoveEventListener = "removeEventListener";
var strEvents = "events";
var strVisibilityChangeEvt = "visibilitychange";
var strPageHide = "pagehide";
var strPageShow = "pageshow";
var strUnload = "unload";
var strBeforeUnload = "beforeunload";
var strPageHideNamespace = (0,_DataCacheHelper__WEBPACK_IMPORTED_MODULE_0__.createUniqueNamespace)("aiEvtPageHide");
var strPageShowNamespace = (0,_DataCacheHelper__WEBPACK_IMPORTED_MODULE_0__.createUniqueNamespace)("aiEvtPageShow");
var rRemoveEmptyNs = /\.[\.]+/g;
var rRemoveTrailingEmptyNs = /[\.]+$/;
var _guid = 1;
var elmNodeData = (0,_DataCacheHelper__WEBPACK_IMPORTED_MODULE_0__.createElmNodeData)("events");
var eventNamespace = /^([^.]*)(?:\.(.+)|)/;
function _normalizeNamespace(name) {
    if (name && name[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_REPLACE /* @min:%2ereplace */]) {
        return name[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_REPLACE /* @min:%2ereplace */](/^[\s\.]+|(?=[\s\.])[\.\s]+$/g, _InternalConstants__WEBPACK_IMPORTED_MODULE_2__.STR_EMPTY);
    }
    return name;
}
function _getEvtNamespace(eventName, evtNamespace) {
    var _a;
    if (evtNamespace) {
        var theNamespace_1 = _InternalConstants__WEBPACK_IMPORTED_MODULE_2__.STR_EMPTY;
        if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.isArray)(evtNamespace)) {
            theNamespace_1 = _InternalConstants__WEBPACK_IMPORTED_MODULE_2__.STR_EMPTY;
            (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.arrForEach)(evtNamespace, function (name) {
                name = _normalizeNamespace(name);
                if (name) {
                    if (name[0] !== ".") {
                        name = "." + name;
                    }
                    theNamespace_1 += name;
                }
            });
        }
        else {
            theNamespace_1 = _normalizeNamespace(evtNamespace);
        }
        if (theNamespace_1) {
            if (theNamespace_1[0] !== ".") {
                theNamespace_1 = "." + theNamespace_1;
            }
            // We may only have the namespace and not an eventName
            eventName = (eventName || _InternalConstants__WEBPACK_IMPORTED_MODULE_2__.STR_EMPTY) + theNamespace_1;
        }
    }
    var parsedEvent = (eventNamespace.exec(eventName || _InternalConstants__WEBPACK_IMPORTED_MODULE_2__.STR_EMPTY) || []);
    return _a = {},
        _a[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_TYPE /* @min:type */] = parsedEvent[1],
        _a.ns = ((parsedEvent[2] || _InternalConstants__WEBPACK_IMPORTED_MODULE_2__.STR_EMPTY).replace(rRemoveEmptyNs, ".").replace(rRemoveTrailingEmptyNs, _InternalConstants__WEBPACK_IMPORTED_MODULE_2__.STR_EMPTY)[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_SPLIT /* @min:%2esplit */](".").sort()).join("."),
        _a;
}
/**
 * Get all of the registered events on the target object, this is primarily used for testing cleanup but may also be used by
 * applications to remove their own events
 * @param target - The EventTarget that has registered events
 * @param eventName - [Optional] The name of the event to return the registered handlers and full name (with namespaces)
 * @param evtNamespace - [Optional] Additional namespace(s) to append to the event listeners so they can be uniquely identified and removed based on this namespace,
 * if the eventName also includes a namespace the namespace(s) are merged into a single namespace
 */
function __getRegisteredEvents(target, eventName, evtNamespace) {
    var theEvents = [];
    var eventCache = elmNodeData.get(target, strEvents, {}, false);
    var evtName = _getEvtNamespace(eventName, evtNamespace);
    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.objForEachKey)(eventCache, function (evtType, registeredEvents) {
        (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.arrForEach)(registeredEvents, function (value) {
            var _a;
            if (!evtName[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_TYPE /* @min:%2etype */] || evtName[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_TYPE /* @min:%2etype */] === value.evtName[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_TYPE /* @min:%2etype */]) {
                if (!evtName.ns || evtName.ns === evtName.ns) {
                    theEvents[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_PUSH /* @min:%2epush */]((_a = {},
                        _a[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_NAME /* @min:name */] = value.evtName[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_TYPE /* @min:%2etype */] + (value.evtName.ns ? "." + value.evtName.ns : _InternalConstants__WEBPACK_IMPORTED_MODULE_2__.STR_EMPTY),
                        _a.handler = value[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_HANDLER /* @min:%2ehandler */],
                        _a));
                }
            }
        });
    });
    return theEvents;
}
// Exported for internal unit testing only
function _getRegisteredEvents(target, evtName, addDefault) {
    if (addDefault === void 0) { addDefault = true; }
    var aiEvts = elmNodeData.get(target, strEvents, {}, addDefault);
    var registeredEvents = aiEvts[evtName];
    if (!registeredEvents) {
        registeredEvents = aiEvts[evtName] = [];
    }
    return registeredEvents;
}
function _doDetach(obj, evtName, handlerRef, useCapture) {
    if (obj && evtName && evtName[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_TYPE /* @min:%2etype */]) {
        if (obj[strRemoveEventListener]) {
            obj[strRemoveEventListener](evtName[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_TYPE /* @min:%2etype */], handlerRef, useCapture);
        }
        else if (obj[strDetachEvent]) {
            obj[strDetachEvent](strOnPrefix + evtName[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_TYPE /* @min:%2etype */], handlerRef);
        }
    }
}
function _doAttach(obj, evtName, handlerRef, useCapture) {
    var result = false;
    if (obj && evtName && evtName[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_TYPE /* @min:%2etype */] && handlerRef) {
        if (obj[strAddEventHelper]) {
            // all browsers except IE before version 9
            obj[strAddEventHelper](evtName[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_TYPE /* @min:%2etype */], handlerRef, useCapture);
            result = true;
        }
        else if (obj[strAttachEvent]) {
            // IE before version 9
            obj[strAttachEvent](strOnPrefix + evtName[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_TYPE /* @min:%2etype */], handlerRef);
            result = true;
        }
    }
    return result;
}
function _doUnregister(target, events, evtName, unRegFn) {
    var idx = events[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LENGTH /* @min:%2elength */];
    while (idx--) {
        var theEvent = events[idx];
        if (theEvent) {
            if (!evtName.ns || evtName.ns === theEvent.evtName.ns) {
                if (!unRegFn || unRegFn(theEvent)) {
                    _doDetach(target, theEvent.evtName, theEvent[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_HANDLER /* @min:%2ehandler */], theEvent.capture);
                    // Remove the registered event
                    events[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_SPLICE /* @min:%2esplice */](idx, 1);
                }
            }
        }
    }
}
function _unregisterEvents(target, evtName, unRegFn) {
    if (evtName[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_TYPE /* @min:%2etype */]) {
        _doUnregister(target, _getRegisteredEvents(target, evtName[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_TYPE /* @min:%2etype */]), evtName, unRegFn);
    }
    else {
        var eventCache = elmNodeData.get(target, strEvents, {});
        (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.objForEachKey)(eventCache, function (evtType, events) {
            _doUnregister(target, events, evtName, unRegFn);
        });
        // Cleanup
        if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.objKeys)(eventCache)[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LENGTH /* @min:%2elength */] === 0) {
            elmNodeData.kill(target, strEvents);
        }
    }
}
function mergeEvtNamespace(theNamespace, namespaces) {
    var newNamespaces;
    if (namespaces) {
        if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.isArray)(namespaces)) {
            newNamespaces = [theNamespace].concat(namespaces);
        }
        else {
            newNamespaces = [theNamespace, namespaces];
        }
        // resort the namespaces so they are always in order
        newNamespaces = (_getEvtNamespace("xx", newNamespaces).ns)[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_SPLIT /* @min:%2esplit */](".");
    }
    else {
        newNamespaces = theNamespace;
    }
    return newNamespaces;
}
/**
 * Binds the specified function to an event, so that the function gets called whenever the event fires on the object
 * @param obj - Object to add the event too.
 * @param eventName - String that specifies any of the standard DHTML Events without "on" prefix, if may also include an optional (dot "." prefixed)
 * namespaces "click" "click.mynamespace" in addition to specific namespaces.
 * @param handlerRef - Pointer that specifies the function to call when event fires
 * @param evtNamespace - [Optional] Additional namespace(s) to append to the event listeners so they can be uniquely identified and removed based on this namespace,
 * if the eventName also includes a namespace the namespace(s) are merged into a single namespace
 * @param useCapture - [Optional] Defaults to false
 * @returns True if the function was bound successfully to the event, otherwise false
 */
function eventOn(target, eventName, handlerRef, evtNamespace, useCapture) {
    var _a;
    if (useCapture === void 0) { useCapture = false; }
    var result = false;
    if (target) {
        try {
            var evtName = _getEvtNamespace(eventName, evtNamespace);
            result = _doAttach(target, evtName, handlerRef, useCapture);
            if (result && elmNodeData.accept(target)) {
                var registeredEvent = (_a = {
                        guid: _guid++,
                        evtName: evtName
                    },
                    _a[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_HANDLER /* @min:handler */] = handlerRef,
                    _a.capture = useCapture,
                    _a);
                _getRegisteredEvents(target, evtName.type)[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_PUSH /* @min:%2epush */](registeredEvent);
            }
        }
        catch (e) {
            // Just Ignore any error so that we don't break any execution path
        }
    }
    return result;
}
/**
 * Removes an event handler for the specified event
 * @param Object - to remove the event from
 * @param eventName - {string} - The name of the event, with optional namespaces or just the namespaces,
 * such as "click", "click.mynamespace" or ".mynamespace"
 * @param handlerRef - {any} - The callback function that needs to be removed from the given event, when using a
 * namespace (with or without a qualifying event) this may be null to remove all previously attached event handlers
 * otherwise this will only remove events with this specific handler.
 * @param evtNamespace - [Optional] Additional namespace(s) to append to the event listeners so they can be uniquely identified and removed based on this namespace,
 * if the eventName also includes a namespace the namespace(s) are merged into a single namespace
 * @param useCapture - [Optional] Defaults to false
 */
function eventOff(target, eventName, handlerRef, evtNamespace, useCapture) {
    if (useCapture === void 0) { useCapture = false; }
    if (target) {
        try {
            var evtName_1 = _getEvtNamespace(eventName, evtNamespace);
            var found_1 = false;
            _unregisterEvents(target, evtName_1, function (regEvent) {
                if ((evtName_1.ns && !handlerRef) || regEvent[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_HANDLER /* @min:%2ehandler */] === handlerRef) {
                    found_1 = true;
                    return true;
                }
                return false;
            });
            if (!found_1) {
                // fallback to try and remove as requested
                _doDetach(target, evtName_1, handlerRef, useCapture);
            }
        }
        catch (e) {
            // Just Ignore any error so that we don't break any execution path
        }
    }
}
/**
 * Binds the specified function to an event, so that the function gets called whenever the event fires on the object
 * @param obj - Object to add the event too.
 * @param eventNameWithoutOn - String that specifies any of the standard DHTML Events without "on" prefix and optional (dot "." prefixed) namespaces "click" "click.mynamespace".
 * @param handlerRef - Pointer that specifies the function to call when event fires
 * @param useCapture - [Optional] Defaults to false
 * @returns True if the function was bound successfully to the event, otherwise false
 */
function attachEvent(obj, eventNameWithoutOn, handlerRef, useCapture) {
    if (useCapture === void 0) { useCapture = false; }
    return eventOn(obj, eventNameWithoutOn, handlerRef, null, useCapture);
}
/**
 * Removes an event handler for the specified event
 * @param Object - to remove the event from
 * @param eventNameWithoutOn - {string} - The name of the event, with optional namespaces or just the namespaces,
 * such as "click", "click.mynamespace" or ".mynamespace"
 * @param handlerRef - {any} - The callback function that needs to be removed from the given event, when using a
 * namespace (with or without a qualifying event) this may be null to remove all previously attached event handlers
 * otherwise this will only remove events with this specific handler.
 * @param useCapture - [Optional] Defaults to false
 */
function detachEvent(obj, eventNameWithoutOn, handlerRef, useCapture) {
    if (useCapture === void 0) { useCapture = false; }
    eventOff(obj, eventNameWithoutOn, handlerRef, null, useCapture);
}
/**
 * Trys to add an event handler for the specified event to the window, body and document
 * @param eventName - {string} - The name of the event
 * @param callback - {any} - The callback function that needs to be executed for the given event
 * @param evtNamespace - [Optional] Namespace(s) to append to the event listeners so they can be uniquely identified and removed based on this namespace.
 * @return {boolean} - true if the handler was successfully added
 */
function addEventHandler(eventName, callback, evtNamespace) {
    var result = false;
    var w = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.getWindow)();
    if (w) {
        result = eventOn(w, eventName, callback, evtNamespace);
        result = eventOn(w["body"], eventName, callback, evtNamespace) || result;
    }
    var doc = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.getDocument)();
    if (doc) {
        result = eventOn(doc, eventName, callback, evtNamespace) || result;
    }
    return result;
}
/**
 * Trys to remove event handler(s) for the specified event/namespace to the window, body and document
 * @param eventName - {string} - The name of the event, with optional namespaces or just the namespaces,
 * such as "click", "click.mynamespace" or ".mynamespace"
 * @param callback - {any} - - The callback function that needs to be removed from the given event, when using a
 * namespace (with or without a qualifying event) this may be null to remove all previously attached event handlers
 * otherwise this will only remove events with this specific handler.
 * @param evtNamespace - [Optional] Namespace(s) to append to the event listeners so they can be uniquely identified and removed based on this namespace.
 */
function removeEventHandler(eventName, callback, evtNamespace) {
    var w = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.getWindow)();
    if (w) {
        eventOff(w, eventName, callback, evtNamespace);
        eventOff(w["body"], eventName, callback, evtNamespace);
    }
    var doc = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.getDocument)();
    if (doc) {
        eventOff(doc, eventName, callback, evtNamespace);
    }
}
/**
 * Bind the listener to the array of events
 * @param events - An string array of event names to bind the listener to
 * @param listener - The event callback to call when the event is triggered
 * @param excludeEvents - [Optional] An array of events that should not be hooked (if possible), unless no other events can be.
 * @param evtNamespace - [Optional] Namespace(s) to append to the event listeners so they can be uniquely identified and removed based on this namespace.
 * @returns true - when at least one of the events was registered otherwise false
 */
function _addEventListeners(events, listener, excludeEvents, evtNamespace) {
    var added = false;
    if (listener && events && events[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LENGTH /* @min:%2elength */] > 0) {
        (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.arrForEach)(events, function (name) {
            if (name) {
                if (!excludeEvents || (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.arrIndexOf)(excludeEvents, name) === -1) {
                    added = addEventHandler(name, listener, evtNamespace) || added;
                }
            }
        });
    }
    return added;
}
/**
 * Bind the listener to the array of events
 * @param events - An string array of event names to bind the listener to
 * @param listener - The event callback to call when the event is triggered
 * @param excludeEvents - [Optional] An array of events that should not be hooked (if possible), unless no other events can be.
 * @param evtNamespace - [Optional] Namespace(s) to append to the event listeners so they can be uniquely identified and removed based on this namespace.
 * @returns true - when at least one of the events was registered otherwise false
 */
function addEventListeners(events, listener, excludeEvents, evtNamespace) {
    var added = false;
    if (listener && events && (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.isArray)(events)) {
        added = _addEventListeners(events, listener, excludeEvents, evtNamespace);
        if (!added && excludeEvents && excludeEvents[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LENGTH /* @min:%2elength */] > 0) {
            // Failed to add any listeners and we excluded some, so just attempt to add the excluded events
            added = _addEventListeners(events, listener, null, evtNamespace);
        }
    }
    return added;
}
/**
 * Remove the listener from the array of events
 * @param events - An string array of event names to bind the listener to
 * @param listener - The event callback to call when the event is triggered
 * @param evtNamespace - [Optional] Namespace(s) to append to the event listeners so they can be uniquely identified and removed based on this namespace.
 */
function removeEventListeners(events, listener, evtNamespace) {
    if (events && (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.isArray)(events)) {
        (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.arrForEach)(events, function (name) {
            if (name) {
                removeEventHandler(name, listener, evtNamespace);
            }
        });
    }
}
/**
 * Listen to the 'beforeunload', 'unload' and 'pagehide' events which indicates a page unload is occurring,
 * this does NOT listen to the 'visibilitychange' event as while it does indicate that the page is being hidden
 * it does not *necessarily* mean that the page is being completely unloaded, it can mean that the user is
 * just navigating to a different Tab and may come back (without unloading the page). As such you may also
 * need to listen to the 'addPageHideEventListener' and 'addPageShowEventListener' events.
 * @param listener - The event callback to call when a page unload event is triggered
 * @param excludeEvents - [Optional] An array of events that should not be hooked, unless no other events can be.
 * @param evtNamespace - [Optional] Namespace(s) to append to the event listeners so they can be uniquely identified and removed based on this namespace.
 * @returns true - when at least one of the events was registered otherwise false
 */
function addPageUnloadEventListener(listener, excludeEvents, evtNamespace) {
    // Hook the unload event for the document, window and body to ensure that the client events are flushed to the server
    // As just hooking the window does not always fire (on chrome) for page navigation's.
    return addEventListeners([strBeforeUnload, strUnload, strPageHide], listener, excludeEvents, evtNamespace);
}
/**
 * Remove any matching 'beforeunload', 'unload' and 'pagehide' events that may have been added via addEventListener,
 * addEventListeners, addPageUnloadEventListener or addPageHideEventListener.
 * @param listener - The specific event callback to to be removed
 * @param evtNamespace - [Optional] Namespace(s) uniquely identified and removed based on this namespace.
 * @returns true - when at least one of the events was registered otherwise false
 */
function removePageUnloadEventListener(listener, evtNamespace) {
    removeEventListeners([strBeforeUnload, strUnload, strPageHide], listener, evtNamespace);
}
/**
 * Listen to the pagehide and visibility changing to 'hidden' events, because the 'visibilitychange' uses
 * an internal proxy to detect the visibility state you SHOULD use a unique namespace when if you plan to call
 * removePageShowEventListener as the remove ignores the listener argument for the 'visibilitychange' event.
 * @param listener - The event callback to call when a page hide event is triggered
 * @param excludeEvents - [Optional] An array of events that should not be hooked (if possible), unless no other events can be.
 * @param evtNamespace - [Optional] A Namespace to append to the event listeners so they can be uniquely identified and removed
 * based on this namespace. This call also adds an additional unique "pageshow" namespace to the events
 * so that only the matching "removePageHideEventListener" can remove these events.
 * Suggestion: pass as true if you are also calling addPageUnloadEventListener as that also hooks pagehide
 * @returns true - when at least one of the events was registered otherwise false
 */
function addPageHideEventListener(listener, excludeEvents, evtNamespace) {
    function _handlePageVisibility(evt) {
        var doc = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.getDocument)();
        if (listener && doc && doc.visibilityState === "hidden") {
            listener(evt);
        }
    }
    // add the unique page show namespace to any provided namespace so we can only remove the ones added by "pagehide"
    var newNamespaces = mergeEvtNamespace(strPageHideNamespace, evtNamespace);
    var pageUnloadAdded = _addEventListeners([strPageHide], listener, excludeEvents, newNamespaces);
    if (!excludeEvents || (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.arrIndexOf)(excludeEvents, strVisibilityChangeEvt) === -1) {
        pageUnloadAdded = _addEventListeners([strVisibilityChangeEvt], _handlePageVisibility, excludeEvents, newNamespaces) || pageUnloadAdded;
    }
    if (!pageUnloadAdded && excludeEvents) {
        // Failed to add any listeners and we where requested to exclude some, so just call again without excluding anything
        pageUnloadAdded = addPageHideEventListener(listener, null, evtNamespace);
    }
    return pageUnloadAdded;
}
/**
 * Removes the pageHide event listeners added by addPageHideEventListener, because the 'visibilitychange' uses
 * an internal proxy to detect the visibility state you SHOULD use a unique namespace when calling addPageHideEventListener
 * as the remove ignores the listener argument for the 'visibilitychange' event.
 * @param listener - The specific listener to remove for the 'pageshow' event only (ignored for 'visibilitychange')
 * @param evtNamespace - The unique namespace used when calling addPageShowEventListener
 */
function removePageHideEventListener(listener, evtNamespace) {
    // add the unique page show namespace to any provided namespace so we only remove the ones added by "pagehide"
    var newNamespaces = mergeEvtNamespace(strPageHideNamespace, evtNamespace);
    removeEventListeners([strPageHide], listener, newNamespaces);
    removeEventListeners([strVisibilityChangeEvt], null, newNamespaces);
}
/**
 * Listen to the pageshow and visibility changing to 'visible' events, because the 'visibilitychange' uses
 * an internal proxy to detect the visibility state you SHOULD use a unique namespace when if you plan to call
 * removePageShowEventListener as the remove ignores the listener argument for the 'visibilitychange' event.
 * @param listener - The event callback to call when a page is show event is triggered
 * @param excludeEvents - [Optional] An array of events that should not be hooked (if possible), unless no other events can be.
 * @param evtNamespace - [Optional/Recommended] A Namespace to append to the event listeners so they can be uniquely
 * identified and removed based on this namespace. This call also adds an additional unique "pageshow" namespace to the events
 * so that only the matching "removePageShowEventListener" can remove these events.
 * @returns true - when at least one of the events was registered otherwise false
 */
function addPageShowEventListener(listener, excludeEvents, evtNamespace) {
    function _handlePageVisibility(evt) {
        var doc = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.getDocument)();
        if (listener && doc && doc.visibilityState === "visible") {
            listener(evt);
        }
    }
    // add the unique page show namespace to any provided namespace so we can only remove the ones added by "pageshow"
    var newNamespaces = mergeEvtNamespace(strPageShowNamespace, evtNamespace);
    var pageShowAdded = _addEventListeners([strPageShow], listener, excludeEvents, newNamespaces);
    pageShowAdded = _addEventListeners([strVisibilityChangeEvt], _handlePageVisibility, excludeEvents, newNamespaces) || pageShowAdded;
    if (!pageShowAdded && excludeEvents) {
        // Failed to add any listeners and we where requested to exclude some, so just call again without excluding anything
        pageShowAdded = addPageShowEventListener(listener, null, evtNamespace);
    }
    return pageShowAdded;
}
/**
 * Removes the pageShow event listeners added by addPageShowEventListener, because the 'visibilitychange' uses
 * an internal proxy to detect the visibility state you SHOULD use a unique namespace when calling addPageShowEventListener
 * as the remove ignores the listener argument for the 'visibilitychange' event.
 * @param listener - The specific listener to remove for the 'pageshow' event only (ignored for 'visibilitychange')
 * @param evtNamespace - The unique namespace used when calling addPageShowEventListener
 */
function removePageShowEventListener(listener, evtNamespace) {
    // add the unique page show namespace to any provided namespace so we only remove the ones added by "pageshow"
    var newNamespaces = mergeEvtNamespace(strPageShowNamespace, evtNamespace);
    removeEventListeners([strPageShow], listener, newNamespaces);
    removeEventListeners([strVisibilityChangeEvt], null, newNamespaces);
}
//# sourceMappingURL=EventHelpers.js.map

/***/ }),
/* 74 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SenderPostManager": () => (/* binding */ SenderPostManager)
/* harmony export */ });
/* harmony import */ var _microsoft_dynamicproto_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(35);
/* harmony import */ var _nevware21_ts_async__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(56);
/* harmony import */ var _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(30);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(38);
/* harmony import */ var _Constants__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(68);
/* harmony import */ var _DiagnosticLogger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(50);
/* harmony import */ var _EnvUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(44);
/* harmony import */ var _HelperFuncs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(45);
/*
 * Application Insights JavaScript SDK - Core, 3.3.0
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */










var STR_EMPTY = "";
var STR_NO_RESPONSE_BODY = "NoResponseBody";
var _noResponseQs = "&" + STR_NO_RESPONSE_BODY + "=true";
var STR_POST_METHOD = "POST";
/**
 * This Internal component
 * Manager SendPost functions
 * SendPostManger
 * @internal for internal use only
 */
var SenderPostManager = /** @class */ (function () {
    function SenderPostManager() {
        var _syncFetchPayload = 0; // Keep track of the outstanding sync fetch payload total (as sync fetch has limits)
        var _enableSendPromise;
        var _isInitialized;
        var _diagLog;
        var _isOneDs;
        var _onCompleteFuncs;
        var _disableCredentials;
        var _fallbackInst;
        var _disableXhr;
        var _disableBeacon;
        var _disableBeaconSync;
        var _disableFetchKeepAlive;
        var _addNoResponse;
        var _timeoutWrapper;
        (0,_microsoft_dynamicproto_js__WEBPACK_IMPORTED_MODULE_0__["default"])(SenderPostManager, this, function (_self, _base) {
            var _sendCredentials = true; // for 1ds
            _initDefaults();
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_INITIALIZE /* @min:%2einitialize */] = function (config, diagLog) {
                _diagLog = diagLog;
                if (_isInitialized) {
                    (0,_DiagnosticLogger__WEBPACK_IMPORTED_MODULE_2__._throwInternal)(_diagLog, 1 /* eLoggingSeverity.CRITICAL */, 28 /* _eInternalMessageId.SenderNotInitialized */, "Sender is already initialized");
                }
                _self.SetConfig(config);
                _isInitialized = true;
            };
            _self["_getDbgPlgTargets"] = function () {
                return [_isInitialized, _isOneDs, _disableCredentials, _enableSendPromise];
            };
            // This componet might get its config from sender, offline sender, 1ds post
            // so set this function to mock dynamic changes
            _self.SetConfig = function (config) {
                try {
                    _onCompleteFuncs = config.senderOnCompleteCallBack || {};
                    _disableCredentials = !!config.disableCredentials;
                    _isOneDs = !!config.isOneDs;
                    _enableSendPromise = !!config.enableSendPromise;
                    _disableXhr = !!config.disableXhr;
                    _disableBeacon = !!config.disableBeacon;
                    _disableBeaconSync = !!config.disableBeaconSync;
                    _timeoutWrapper = config.timeWrapper;
                    _addNoResponse = !!config.addNoResponse;
                    _disableFetchKeepAlive = !!config.disableFetchKeepAlive;
                    _fallbackInst = { sendPOST: _xhrSender };
                    if (!_isOneDs) {
                        _sendCredentials = false; // for appInsights, set it to false always
                    }
                    if (_disableCredentials) {
                        var location_1 = (0,_EnvUtils__WEBPACK_IMPORTED_MODULE_3__.getLocation)();
                        if (location_1 && location_1.protocol && location_1.protocol[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_TO_LOWER_CASE /* @min:%2etoLowerCase */]() === "file:") {
                            // Special case where a local html file fails with a CORS error on Chromium browsers
                            _sendCredentials = false;
                        }
                    }
                    return true;
                }
                catch (e) {
                    // eslint-disable-next-line no-empty
                }
                return false;
            };
            _self.getSyncFetchPayload = function () {
                return _syncFetchPayload;
            };
            _self.getSenderInst = function (transports, sync) {
                if (transports && transports[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LENGTH /* @min:%2elength */]) {
                    return _getSenderInterface(transports, sync);
                }
                return null;
            };
            _self.getFallbackInst = function () {
                return _fallbackInst;
            };
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN__DO_TEARDOWN /* @min:%2e_doTeardown */] = function (unloadCtx, unloadState) {
                _initDefaults();
            };
            /**
             * success handler
             */
            function _onSuccess(res, onComplete) {
                _doOnComplete(onComplete, 200, {}, res);
            }
            /**
             * error handler
             */
            function _onError(message, onComplete) {
                (0,_DiagnosticLogger__WEBPACK_IMPORTED_MODULE_2__._throwInternal)(_diagLog, 2 /* eLoggingSeverity.WARNING */, 26 /* _eInternalMessageId.OnError */, "Failed to send telemetry.", { message: message });
                _doOnComplete(onComplete, 400, {});
            }
            function _onNoPayloadUrl(onComplete) {
                _onError("No endpoint url is provided for the batch", onComplete);
            }
            function _getSenderInterface(transports, syncSupport) {
                var _a;
                var transportType = 0 /* TransportType.NotSet */;
                var sendPostFunc = null;
                var lp = 0;
                while (sendPostFunc == null && lp < transports[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LENGTH /* @min:%2elength */]) {
                    transportType = transports[lp];
                    if (!_disableXhr && transportType === 1 /* TransportType.Xhr */) {
                        if ((0,_EnvUtils__WEBPACK_IMPORTED_MODULE_3__.useXDomainRequest)()) {
                            // IE 8 and 9
                            sendPostFunc = _xdrSender;
                        }
                        else if ((0,_EnvUtils__WEBPACK_IMPORTED_MODULE_3__.isXhrSupported)()) {
                            sendPostFunc = _xhrSender;
                        }
                    }
                    else if (transportType === 2 /* TransportType.Fetch */ && (0,_EnvUtils__WEBPACK_IMPORTED_MODULE_3__.isFetchSupported)(syncSupport) && (!syncSupport || !_disableFetchKeepAlive)) {
                        sendPostFunc = _doFetchSender;
                    }
                    else if (transportType === 3 /* TransportType.Beacon */ && (0,_EnvUtils__WEBPACK_IMPORTED_MODULE_3__.isBeaconsSupported)() && (syncSupport ? !_disableBeaconSync : !_disableBeacon)) {
                        sendPostFunc = _beaconSender;
                    }
                    lp++;
                }
                if (sendPostFunc) {
                    return _a = {
                            _transport: transportType,
                            _isSync: syncSupport
                        },
                        _a[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_SEND_POST /* @min:sendPOST */] = sendPostFunc,
                        _a;
                }
                return null;
            }
            function _doOnComplete(oncomplete, status, headers, response) {
                try {
                    oncomplete && oncomplete(status, headers, response);
                }
                catch (e) {
                    // eslint-disable-next-line no-empty
                }
            }
            function _doBeaconSend(payload, oncomplete) {
                var nav = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_4__.getNavigator)();
                var url = payload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_URL_STRING /* @min:%2eurlString */];
                if (!url) {
                    _onNoPayloadUrl(oncomplete);
                    // return true here, because we don't want to retry it with fallback sender
                    return true;
                }
                url = payload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_URL_STRING /* @min:%2eurlString */] + (_addNoResponse ? _noResponseQs : STR_EMPTY);
                var data = payload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_DATA /* @min:%2edata */];
                // Chrome only allows CORS-safelisted values for the sendBeacon data argument
                // see: https://bugs.chromium.org/p/chromium/issues/detail?id=720283
                // Chrome only allows CORS-safelisted values for the sendBeacon data argument
                // see: https://bugs.chromium.org/p/chromium/issues/detail?id=720283
                var plainTextBatch = _isOneDs ? data : new Blob([data], { type: "text/plain;charset=UTF-8" });
                // The sendBeacon method returns true if the user agent is able to successfully queue the data for transfer. Otherwise it returns false.
                var queued = nav.sendBeacon(url, plainTextBatch);
                return queued;
            }
            /**
             * Send Beacon API request
             * @param payload - {string} - The data payload to be sent.
             * @param sync - {boolean} - not used
             * Note: Beacon API does not support custom headers and we are not able to get
             * appId from the backend for the correct correlation.
             */
            function _beaconSender(payload, oncomplete, sync) {
                var data = payload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_DATA /* @min:%2edata */];
                try {
                    if (data) {
                        // The sendBeacon method returns true if the user agent is able to successfully queue the data for transfer. Otherwise it returns false.
                        if (!_doBeaconSend(payload, oncomplete)) {
                            var onRetry = _onCompleteFuncs && _onCompleteFuncs.beaconOnRetry;
                            if (onRetry && (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_4__.isFunction)(onRetry)) {
                                onRetry(payload, oncomplete, _doBeaconSend);
                            }
                            else {
                                _fallbackInst && _fallbackInst[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_SEND_POST /* @min:%2esendPOST */](payload, oncomplete, true);
                                (0,_DiagnosticLogger__WEBPACK_IMPORTED_MODULE_2__._throwInternal)(_diagLog, 2 /* eLoggingSeverity.WARNING */, 40 /* _eInternalMessageId.TransmissionFailed */, ". " + "Failed to send telemetry with Beacon API, retried with normal sender.");
                            }
                        }
                        else {
                            // if can send
                            _onSuccess(STR_EMPTY, oncomplete);
                        }
                    }
                }
                catch (e) {
                    _isOneDs && (0,_DiagnosticLogger__WEBPACK_IMPORTED_MODULE_2__._warnToConsole)(_diagLog, "Failed to send telemetry using sendBeacon API. Ex:" + (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_4__.dumpObj)(e));
                    _doOnComplete(oncomplete, _isOneDs ? 0 : 400, {}, STR_EMPTY);
                }
                return;
            }
            /**
             * Send XMLHttpRequest
             * @param payload - {string} - The data payload to be sent.
             * @param sync - {boolean} - Indicates if the request should be sent synchronously
             */
            function _xhrSender(payload, oncomplete, sync) {
                //let  internalPayload = payload as IInternalPayloadData;
                var thePromise;
                var resolveFunc;
                var rejectFunc;
                var headers = payload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_HEADERS /* @min:%2eheaders */] || {};
                if (!sync && _enableSendPromise) {
                    thePromise = (0,_nevware21_ts_async__WEBPACK_IMPORTED_MODULE_5__.createPromise)(function (resolve, reject) {
                        resolveFunc = resolve;
                        rejectFunc = reject;
                    });
                }
                if (_isOneDs && sync && payload.disableXhrSync) {
                    sync = false;
                }
                //const xhr = new XMLHttpRequest();
                var endPointUrl = payload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_URL_STRING /* @min:%2eurlString */];
                if (!endPointUrl) {
                    _onNoPayloadUrl(oncomplete);
                    resolveFunc && resolveFunc(false);
                    return;
                }
                var xhr = (0,_HelperFuncs__WEBPACK_IMPORTED_MODULE_6__.openXhr)(STR_POST_METHOD, endPointUrl, _sendCredentials, true, sync, payload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_TIMEOUT /* @min:%2etimeout */]);
                if (!_isOneDs) {
                    // application/json should NOT add to 1ds post by default
                    xhr[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_SET_REQUEST_HEADER /* @min:%2esetRequestHeader */]("Content-type", "application/json");
                }
                (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_4__.arrForEach)((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_4__.objKeys)(headers), function (headerName) {
                    xhr[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_SET_REQUEST_HEADER /* @min:%2esetRequestHeader */](headerName, headers[headerName]);
                });
                xhr.onreadystatechange = function () {
                    if (!_isOneDs) {
                        _doOnReadyFunc(xhr);
                        if (xhr.readyState === 4) {
                            resolveFunc && resolveFunc(true);
                        }
                    }
                };
                xhr.onload = function () {
                    if (_isOneDs) {
                        _doOnReadyFunc(xhr);
                    }
                };
                function _doOnReadyFunc(xhr) {
                    var onReadyFunc = _onCompleteFuncs && _onCompleteFuncs.xhrOnComplete;
                    var onReadyFuncExist = onReadyFunc && (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_4__.isFunction)(onReadyFunc);
                    if (onReadyFuncExist) {
                        onReadyFunc(xhr, oncomplete, payload);
                    }
                    else {
                        var response = (0,_HelperFuncs__WEBPACK_IMPORTED_MODULE_6__.getResponseText)(xhr);
                        _doOnComplete(oncomplete, xhr[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_STATUS /* @min:%2estatus */], (0,_HelperFuncs__WEBPACK_IMPORTED_MODULE_6__._getAllResponseHeaders)(xhr, _isOneDs), response);
                    }
                }
                xhr.onerror = function (event) {
                    _doOnComplete(oncomplete, _isOneDs ? xhr[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_STATUS /* @min:%2estatus */] : 400, (0,_HelperFuncs__WEBPACK_IMPORTED_MODULE_6__._getAllResponseHeaders)(xhr, _isOneDs), _isOneDs ? STR_EMPTY : (0,_HelperFuncs__WEBPACK_IMPORTED_MODULE_6__.formatErrorMessageXhr)(xhr));
                    rejectFunc && rejectFunc(event);
                };
                xhr.ontimeout = function () {
                    _doOnComplete(oncomplete, _isOneDs ? xhr[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_STATUS /* @min:%2estatus */] : 500, (0,_HelperFuncs__WEBPACK_IMPORTED_MODULE_6__._getAllResponseHeaders)(xhr, _isOneDs), _isOneDs ? STR_EMPTY : (0,_HelperFuncs__WEBPACK_IMPORTED_MODULE_6__.formatErrorMessageXhr)(xhr));
                    resolveFunc && resolveFunc(false);
                };
                xhr.send(payload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_DATA /* @min:%2edata */]);
                return thePromise;
            }
            /**
             * Send fetch API request
             * @param payload - {string} - The data payload to be sent.
             * @param sync - {boolean} - For fetch this identifies whether we are "unloading" (false) or a normal request
             */
            function _doFetchSender(payload, oncomplete, sync) {
                var _a;
                var endPointUrl = payload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_URL_STRING /* @min:%2eurlString */];
                var batch = payload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_DATA /* @min:%2edata */];
                var plainTextBatch = _isOneDs ? batch : new Blob([batch], { type: "application/json" });
                var thePromise;
                var resolveFunc;
                var rejectFunc;
                var requestHeaders = new Headers();
                var batchLength = batch[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LENGTH /* @min:%2elength */];
                var ignoreResponse = false;
                var responseHandled = false;
                var headers = payload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_HEADERS /* @min:%2eheaders */] || {};
                //TODO: handle time out for 1ds
                var init = (_a = {
                        method: STR_POST_METHOD,
                        body: plainTextBatch
                    },
                    _a[_Constants__WEBPACK_IMPORTED_MODULE_7__.DisabledPropertyName] = true // Mark so we don't attempt to track this request
                ,
                    _a);
                // Only add headers if there are headers to add, due to issue with some polyfills
                if (payload.headers && (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_4__.objKeys)(payload.headers)[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LENGTH /* @min:%2elength */] > 0) {
                    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_4__.arrForEach)((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_4__.objKeys)(headers), function (headerName) {
                        requestHeaders.append(headerName, headers[headerName]);
                    });
                    init[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_HEADERS /* @min:%2eheaders */] = requestHeaders;
                }
                if (_sendCredentials && _isOneDs) {
                    // for 1ds, Don't send credentials when URL is file://
                    init.credentials = "include";
                }
                if (sync) {
                    init.keepalive = true;
                    _syncFetchPayload += batchLength;
                    if (_isOneDs) {
                        if (payload["_sendReason"] === 2 /* SendRequestReason.Unload */) {
                            // As a sync request (during unload), it is unlikely that we will get a chance to process the response so
                            // just like beacon send assume that the events have been accepted and processed
                            ignoreResponse = true;
                            if (_addNoResponse) {
                                endPointUrl += _noResponseQs;
                            }
                        }
                    }
                    else {
                        // for appinsights, set to true for all sync request
                        ignoreResponse = true;
                    }
                }
                var request = new Request(endPointUrl, init);
                try {
                    // Also try and tag the request (just in case the value in init is not copied over)
                    request[_Constants__WEBPACK_IMPORTED_MODULE_7__.DisabledPropertyName] = true;
                }
                catch (e) {
                    // If the environment has locked down the XMLHttpRequest (preventExtensions and/or freeze), this would
                    // cause the request to fail and we no telemetry would be sent
                }
                if (!sync && _enableSendPromise) {
                    thePromise = (0,_nevware21_ts_async__WEBPACK_IMPORTED_MODULE_5__.createPromise)(function (resolve, reject) {
                        resolveFunc = resolve;
                        rejectFunc = reject;
                    });
                }
                if (!endPointUrl) {
                    _onNoPayloadUrl(oncomplete);
                    resolveFunc && resolveFunc(false);
                    return;
                }
                function _handleError(res) {
                    // In case there is an error in the request. Set the status to 0 for 1ds and 400 for appInsights
                    // so that the events can be retried later.
                    _doOnComplete(oncomplete, _isOneDs ? 0 : 400, {}, _isOneDs ? STR_EMPTY : res);
                }
                function _onFetchComplete(response, payload, value) {
                    var status = response[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_STATUS /* @min:%2estatus */];
                    var onCompleteFunc = _onCompleteFuncs.fetchOnComplete;
                    if (onCompleteFunc && (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_4__.isFunction)(onCompleteFunc)) {
                        onCompleteFunc(response, oncomplete, value || STR_EMPTY, payload);
                    }
                    else {
                        _doOnComplete(oncomplete, status, {}, value || STR_EMPTY);
                    }
                }
                try {
                    (0,_nevware21_ts_async__WEBPACK_IMPORTED_MODULE_5__.doAwaitResponse)(fetch(_isOneDs ? endPointUrl : request, _isOneDs ? init : null), function (result) {
                        if (sync) {
                            _syncFetchPayload -= batchLength;
                            batchLength = 0;
                        }
                        if (!responseHandled) {
                            responseHandled = true;
                            if (!result.rejected) {
                                var response_1 = result[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_VALUE /* @min:%2evalue */];
                                try {
                                    /**
                                     * The Promise returned from fetch() wont reject on HTTP error status even if the response is an HTTP 404 or 500.
                                     * Instead, it will resolve normally (with ok status set to false), and it will only reject on network failure
                                     * or if anything prevented the request from completing.
                                     */
                                    if (!_isOneDs && !response_1.ok) {
                                        // this is for appInsights only
                                        _handleError(response_1.statusText);
                                        resolveFunc && resolveFunc(false);
                                    }
                                    else {
                                        if (_isOneDs && !response_1.body) {
                                            _onFetchComplete(response_1, null, STR_EMPTY);
                                            resolveFunc && resolveFunc(true);
                                        }
                                        else {
                                            (0,_nevware21_ts_async__WEBPACK_IMPORTED_MODULE_5__.doAwaitResponse)(response_1.text(), function (resp) {
                                                _onFetchComplete(response_1, payload, resp[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_VALUE /* @min:%2evalue */]);
                                                resolveFunc && resolveFunc(true);
                                            });
                                        }
                                    }
                                }
                                catch (e) {
                                    _handleError((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_4__.dumpObj)(e));
                                    rejectFunc && rejectFunc(e);
                                }
                            }
                            else {
                                _handleError(result.reason && result.reason[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_MESSAGE /* @min:%2emessage */]);
                                rejectFunc && rejectFunc(result.reason);
                            }
                        }
                    });
                }
                catch (e) {
                    if (!responseHandled) {
                        _handleError((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_4__.dumpObj)(e));
                        rejectFunc && rejectFunc(e);
                    }
                }
                if (ignoreResponse && !responseHandled) {
                    // Assume success during unload processing as we most likely won't get the response
                    responseHandled = true;
                    _doOnComplete(oncomplete, 200, {});
                    resolveFunc && resolveFunc(true);
                }
                if (_isOneDs && !responseHandled && payload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_TIMEOUT /* @min:%2etimeout */] > 0) {
                    // Simulate timeout
                    _timeoutWrapper && _timeoutWrapper.set(function () {
                        if (!responseHandled) {
                            // Assume a 500 response (which will cause a retry)
                            responseHandled = true;
                            _doOnComplete(oncomplete, 500, {});
                            resolveFunc && resolveFunc(true);
                        }
                    }, payload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_TIMEOUT /* @min:%2etimeout */]);
                }
                return thePromise;
            }
            /**
             * Send XDomainRequest
             * @param payload - {string} - The data payload to be sent.
             * @param sync - {boolean} - Indicates if the request should be sent synchronously
             *
             * Note: XDomainRequest does not support sync requests. This 'isAsync' parameter is added
             * to maintain consistency with the xhrSender's contract
             * Note: XDomainRequest does not support custom headers and we are not able to get
             * appId from the backend for the correct correlation.
             */
            function _xdrSender(payload, oncomplete, sync) {
                // It doesn't support custom headers, so no action is taken with current requestHeaders
                var _window = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_4__.getWindow)();
                var xdr = new XDomainRequest();
                var data = payload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_DATA /* @min:%2edata */];
                xdr.onload = function () {
                    var response = (0,_HelperFuncs__WEBPACK_IMPORTED_MODULE_6__.getResponseText)(xdr);
                    var onloadFunc = _onCompleteFuncs && _onCompleteFuncs.xdrOnComplete;
                    if (onloadFunc && (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_4__.isFunction)(onloadFunc)) {
                        onloadFunc(xdr, oncomplete, payload);
                    }
                    else {
                        _doOnComplete(oncomplete, 200, {}, response);
                    }
                };
                xdr.onerror = function () {
                    _doOnComplete(oncomplete, 400, {}, _isOneDs ? STR_EMPTY : (0,_HelperFuncs__WEBPACK_IMPORTED_MODULE_6__.formatErrorMessageXdr)(xdr));
                };
                xdr.ontimeout = function () {
                    _doOnComplete(oncomplete, 500, {});
                };
                xdr.onprogress = function () { };
                // XDomainRequest requires the same protocol as the hosting page.
                // If the protocol doesn't match, we can't send the telemetry :(.
                var hostingProtocol = _window && _window.location && _window.location[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_PROTOCOL /* @min:%2eprotocol */] || "";
                var endpoint = payload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_URL_STRING /* @min:%2eurlString */];
                if (!endpoint) {
                    _onNoPayloadUrl(oncomplete);
                    return;
                }
                if (!_isOneDs && endpoint.lastIndexOf(hostingProtocol, 0) !== 0) {
                    var msg = "Cannot send XDomain request. The endpoint URL protocol doesn't match the hosting page protocol.";
                    (0,_DiagnosticLogger__WEBPACK_IMPORTED_MODULE_2__._throwInternal)(_diagLog, 2 /* eLoggingSeverity.WARNING */, 40 /* _eInternalMessageId.TransmissionFailed */, ". " + msg);
                    _onError(msg, oncomplete);
                    return;
                }
                var endpointUrl = _isOneDs ? endpoint : endpoint[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_REPLACE /* @min:%2ereplace */](/^(https?:)/, "");
                xdr.open(STR_POST_METHOD, endpointUrl);
                if (payload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_TIMEOUT /* @min:%2etimeout */]) {
                    xdr[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_TIMEOUT /* @min:%2etimeout */] = payload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_TIMEOUT /* @min:%2etimeout */];
                }
                xdr.send(data);
                if (_isOneDs && sync) {
                    _timeoutWrapper && _timeoutWrapper.set(function () {
                        xdr.send(data);
                    }, 0);
                }
                else {
                    xdr.send(data);
                }
            }
            function _initDefaults() {
                _syncFetchPayload = 0;
                _isInitialized = false;
                _enableSendPromise = false;
                _diagLog = null;
                _isOneDs = null;
                _onCompleteFuncs = null;
                _disableCredentials = null;
                _fallbackInst = null;
                _disableXhr = false;
                _disableBeacon = false;
                _disableBeaconSync = false;
                _disableFetchKeepAlive = false;
                _addNoResponse = false;
                _timeoutWrapper = null;
            }
        });
    }
// Removed Stub for SenderPostManager.prototype.initialize.
// Removed Stub for SenderPostManager.prototype.getSyncFetchPayload.
// Removed Stub for SenderPostManager.prototype.SetConfig.
// Removed Stub for SenderPostManager.prototype.getSenderInst.
// Removed Stub for SenderPostManager.prototype.getFallbackInst.
// Removed Stub for SenderPostManager.prototype._doTeardown.
    // This is a workaround for an IE bug when using dynamicProto() with classes that don't have any
    // non-dynamic functions or static properties/functions when using uglify-js to minify the resulting code.
    SenderPostManager.__ieDyn=1;

    return SenderPostManager;
}());

//# sourceMappingURL=SenderPostManager.js.map

/***/ }),
/* 75 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "parseResponse": () => (/* binding */ parseResponse)
/* harmony export */ });
/* harmony import */ var _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(30);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(38);
/* harmony import */ var _DiagnosticLogger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(50);
/* harmony import */ var _EnvUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(44);
/*
 * Application Insights JavaScript SDK - Core, 3.3.0
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */






/**
 * Parses the response from the backend.
 * @param response - XMLHttpRequest or XDomainRequest response
 */
function parseResponse(response, diagLog) {
    try {
        if (response && response !== "") {
            var result = (0,_EnvUtils__WEBPACK_IMPORTED_MODULE_0__.getJSON)().parse(response);
            if (result && result[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_ITEMS_RECEIVED /* @min:%2eitemsReceived */] && result[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_ITEMS_RECEIVED /* @min:%2eitemsReceived */] >= result.itemsAccepted &&
                result.itemsReceived - result.itemsAccepted === result.errors[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LENGTH /* @min:%2elength */]) {
                return result;
            }
        }
    }
    catch (e) {
        (0,_DiagnosticLogger__WEBPACK_IMPORTED_MODULE_2__._throwInternal)(diagLog, 1 /* eLoggingSeverity.CRITICAL */, 43 /* _eInternalMessageId.InvalidBackendResponse */, "Cannot parse the response. " + (e[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_NAME /* @min:%2ename */] || (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.dumpObj)(e)), {
            response: response
        });
    }
    return null;
}
//# sourceMappingURL=ResponseHelpers.js.map

/***/ }),
/* 76 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BE_PROFILE": () => (/* reexport safe */ _DataModels__WEBPACK_IMPORTED_MODULE_1__.BE_PROFILE),
/* harmony export */   "NRT_PROFILE": () => (/* reexport safe */ _DataModels__WEBPACK_IMPORTED_MODULE_1__.NRT_PROFILE),
/* harmony export */   "PostChannel": () => (/* reexport safe */ _PostChannel__WEBPACK_IMPORTED_MODULE_0__.PostChannel),
/* harmony export */   "RT_PROFILE": () => (/* reexport safe */ _DataModels__WEBPACK_IMPORTED_MODULE_1__.RT_PROFILE)
/* harmony export */ });
/* harmony import */ var _DataModels__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(78);
/* harmony import */ var _PostChannel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(77);
/*
 * 1DS JS SDK POST plugin, 4.3.0
 * Copyright (c) Microsoft and contributors. All rights reserved.
 * (Microsoft Internal Only)
 */
/**
* @name Index.ts
* @author Abhilash Panwar (abpanwar)
* @copyright Microsoft 2018
* File to export public classes.
*/



//# sourceMappingURL=Index.js.map

/***/ }),
/* 77 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PostChannel": () => (/* binding */ PostChannel)
/* harmony export */ });
/* harmony import */ var _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(33);
/* harmony import */ var _microsoft_dynamicproto_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(35);
/* harmony import */ var _microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(52);
/* harmony import */ var _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(30);
/* harmony import */ var _microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(37);
/* harmony import */ var _microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(73);
/* harmony import */ var _microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(42);
/* harmony import */ var _microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(40);
/* harmony import */ var _microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(61);
/* harmony import */ var _microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(45);
/* harmony import */ var _microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(71);
/* harmony import */ var _microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(50);
/* harmony import */ var _microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(65);
/* harmony import */ var _nevware21_ts_async__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(56);
/* harmony import */ var _DataModels__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(78);
/* harmony import */ var _EventBatch__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(82);
/* harmony import */ var _HttpManager__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(83);
/* harmony import */ var _InternalConstants__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(81);
/* harmony import */ var _RetryPolicy__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(87);
/* harmony import */ var _TimeoutOverrideWrapper__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(80);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(79);
/*
 * 1DS JS SDK POST plugin, 4.3.0
 * Copyright (c) Microsoft and contributors. All rights reserved.
 * (Microsoft Internal Only)
 */

/**
* PostManager.ts
* @author Abhilash Panwar (abpanwar); Hector Hernandez (hectorh); Nev Wylie (newylie)
* @copyright Microsoft 2018-2020
*/











var FlushCheckTimer = 0.250; // This needs to be in seconds, so this is 250ms
var MaxNumberEventPerBatch = 500;
var EventsDroppedAtOneTime = 20;
var MaxSendAttempts = 6;
var MaxSyncUnloadSendAttempts = 2; // Assuming 2 based on beforeunload and unload
var MaxBackoffCount = 4;
var MaxConnections = 2;
var MaxRequestRetriesBeforeBackoff = 1;
var MaxEventsLimitInMem = 10000;
var strEventsDiscarded = "eventsDiscarded";
var EMPTY_STR = "";
var undefValue = undefined;
/**
 * The default settings for the config.
 * WE MUST include all defaults here to ensure that the config is created with all of the properties
 * defined as dynamic.
 */
var defaultPostChannelConfig = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objDeepFreeze)({
    eventsLimitInMem: { isVal: _microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_1__.isGreaterThanZero, v: MaxEventsLimitInMem },
    immediateEventLimit: { isVal: _microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_1__.isGreaterThanZero, v: 500 },
    autoFlushEventsLimit: { isVal: _microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_1__.isGreaterThanZero, v: 0 },
    disableAutoBatchFlushLimit: false,
    httpXHROverride: { isVal: isOverrideFn, v: undefValue },
    overrideInstrumentationKey: undefValue,
    overrideEndpointUrl: undefValue,
    disableTelemetry: false,
    ignoreMc1Ms0CookieProcessing: false,
    setTimeoutOverride: undefValue,
    clearTimeoutOverride: undefValue,
    payloadPreprocessor: undefValue,
    payloadListener: undefValue,
    disableEventTimings: undefValue,
    valueSanitizer: undefValue,
    stringifyObjects: undefValue,
    enableCompoundKey: undefValue,
    disableOptimizeObj: false,
    // disableCacheHeader: undefValue, // See Task #7178858 - Collector requires a change to support this
    transports: undefValue,
    unloadTransports: undefValue,
    useSendBeacon: undefValue,
    disableFetchKeepAlive: undefValue,
    avoidOptions: false,
    xhrTimeout: undefValue,
    disableXhrSync: undefValue,
    alwaysUseXhrOverride: false,
    maxEventRetryAttempts: { isVal: _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isNumber, v: MaxSendAttempts },
    maxUnloadEventRetryAttempts: { isVal: _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isNumber, v: MaxSyncUnloadSendAttempts },
    addNoResponse: undefValue,
    excludeCsMetaData: undefValue
});
function isOverrideFn(httpXHROverride) {
    return httpXHROverride && httpXHROverride.sendPOST;
}
/**
 * Class that manages adding events to inbound queues and batching of events
 * into requests.
 * @group Classes
 * @group Entrypoint
 */
var PostChannel = /** @class */ (function (_super) {
    (0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_2__.__extendsFn)(PostChannel, _super);
    function PostChannel() {
        var _this = _super.call(this) || this;
        _this.identifier = "PostChannel";
        _this.priority = 1011;
        _this.version = '4.3.0';
        var _postConfig;
        var _isTeardownCalled = false;
        var _flushCallbackQueue = [];
        var _flushCallbackTimer;
        var _paused = false;
        var _immediateQueueSize = 0;
        var _immediateQueueSizeLimit;
        var _queueSize = 0;
        var _queueSizeLimit;
        var _profiles = {};
        var _currentProfile = _DataModels__WEBPACK_IMPORTED_MODULE_3__.RT_PROFILE;
        var _scheduledTimer;
        var _immediateTimer;
        var _currentBackoffCount;
        var _timerCount;
        var _httpManager;
        var _batchQueues;
        var _autoFlushEventsLimit;
        // either MaxBatchSize * (1+ Max Connections) or _queueLimit / 6 (where 3 latency Queues [normal, realtime, cost deferred] * 2 [allow half full -- allow for retry])
        var _autoFlushBatchLimit;
        var _delayedBatchSendLatency;
        var _delayedBatchReason;
        var _optimizeObject;
        var _isPageUnloadTriggered;
        var _maxEventSendAttempts;
        var _maxUnloadEventSendAttempts;
        var _evtNamespace;
        var _timeoutWrapper;
        var _ignoreMc1Ms0CookieProcessing;
        var _disableAutoBatchFlushLimit;
        var _notificationManager;
        var _unloadHandlersAdded;
        var _overrideInstrumentationKey;
        var _disableTelemetry;
        (0,_microsoft_dynamicproto_js__WEBPACK_IMPORTED_MODULE_4__["default"])(PostChannel, _this, function (_self, _base) {
            _initDefaults();
            // Special internal method to allow the DebugPlugin to hook embedded objects
            _self["_getDbgPlgTargets"] = function () {
                return [_httpManager, _postConfig];
            };
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_INITIALIZE /* @min:%2einitialize */] = function (theConfig, core, extensions) {
                (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_6__.doPerf)(core, function () { return "PostChannel:initialize"; }, function () {
                    _base[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_INITIALIZE /* @min:%2einitialize */](theConfig, core, extensions);
                    _notificationManager = core.getNotifyMgr();
                    try {
                        _evtNamespace = (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_7__.mergeEvtNamespace)((0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_8__.createUniqueNamespace)(_self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_IDENTIFIER /* @min:%2eidentifier */]), core.evtNamespace && core.evtNamespace());
                        _self._addHook((0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_9__.onConfigChange)(theConfig, function (details) {
                            var coreConfig = details.cfg;
                            var ctx = (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_10__.createProcessTelemetryContext)(null, coreConfig, core);
                            _postConfig = ctx.getExtCfg(_self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_IDENTIFIER /* @min:%2eidentifier */], defaultPostChannelConfig);
                            _timeoutWrapper = (0,_TimeoutOverrideWrapper__WEBPACK_IMPORTED_MODULE_11__.createTimeoutWrapper)(_postConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_SET_TIMEOUT_OVERRIDE /* @min:%2esetTimeoutOverride */], _postConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_CLEAR_TIMEOUT_OVERRI3 /* @min:%2eclearTimeoutOverride */]);
                            // Only try and use the optimizeObject() if this appears to be a chromium based browser and it has not been explicitly disabled
                            _optimizeObject = !_postConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_DISABLE_OPTIMIZE_OBJ /* @min:%2edisableOptimizeObj */] && (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_1__.isChromium)();
                            _ignoreMc1Ms0CookieProcessing = _postConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_IGNORE_MC1_MS0_COOKI13 /* @min:%2eignoreMc1Ms0CookieProcessing */];
                            _hookWParam(core); // _hookWParam uses _ignoreMc1Ms0CookieProcessing
                            _queueSizeLimit = _postConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_EVENTS_LIMIT_IN_MEM /* @min:%2eeventsLimitInMem */];
                            _immediateQueueSizeLimit = _postConfig.immediateEventLimit;
                            _autoFlushEventsLimit = _postConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_AUTO_FLUSH_EVENTS_LI14 /* @min:%2eautoFlushEventsLimit */];
                            _maxEventSendAttempts = _postConfig.maxEventRetryAttempts;
                            _maxUnloadEventSendAttempts = _postConfig.maxUnloadEventRetryAttempts;
                            _disableAutoBatchFlushLimit = _postConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_DISABLE_AUTO_BATCH_F15 /* @min:%2edisableAutoBatchFlushLimit */];
                            _setAutoLimits();
                            // Override iKey if provided in Post config if provided for during initialization
                            _overrideInstrumentationKey = _postConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_OVERRIDE_INSTRUMENTA16 /* @min:%2eoverrideInstrumentationKey */];
                            // DisableTelemetry was defined in the config provided during initialization
                            _disableTelemetry = !!_postConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_DISABLE_TELEMETRY /* @min:%2edisableTelemetry */];
                            if (_unloadHandlersAdded) {
                                _removeUnloadHandlers();
                            }
                            var excludePageUnloadEvents = coreConfig.disablePageUnloadEvents || [];
                            // When running in Web browsers try to send all telemetry if page is unloaded
                            _unloadHandlersAdded = (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_7__.addPageUnloadEventListener)(_handleUnloadEvents, excludePageUnloadEvents, _evtNamespace);
                            _unloadHandlersAdded = (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_7__.addPageHideEventListener)(_handleUnloadEvents, excludePageUnloadEvents, _evtNamespace) || _unloadHandlersAdded;
                            _unloadHandlersAdded = (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_7__.addPageShowEventListener)(_handleShowEvents, coreConfig.disablePageShowEvents, _evtNamespace) || _unloadHandlersAdded;
                        }));
                        // only initialize the manager once
                        _httpManager[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_INITIALIZE /* @min:%2einitialize */](theConfig, _self.core, _self);
                    }
                    catch (e) {
                        // resetting the initialized state because of failure
                        _self.setInitialized(false);
                        throw e;
                    }
                }, function () { return ({ theConfig: theConfig, core: core, extensions: extensions }); });
            };
            _self.processTelemetry = function (ev, itemCtx) {
                (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_1__.setProcessTelemetryTimings)(ev, _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_IDENTIFIER /* @min:%2eidentifier */]);
                itemCtx = itemCtx || _self._getTelCtx(itemCtx);
                var event = ev;
                if (!_disableTelemetry && !_isTeardownCalled) {
                    // Override iKey if provided in Post config if provided for during initialization
                    if (_overrideInstrumentationKey) {
                        event[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_I_KEY /* @min:%2eiKey */] = _overrideInstrumentationKey;
                    }
                    _addEventToQueues(event, true);
                    if (_isPageUnloadTriggered) {
                        // Unload event has been received so we need to try and flush new events
                        _releaseAllQueues(2 /* EventSendType.SendBeacon */, 2 /* SendRequestReason.Unload */);
                    }
                    else {
                        _scheduleTimer();
                    }
                }
                _self.processNext(event, itemCtx);
            };
            _self.getOfflineSupport = function () {
                try {
                    var details_1 = _httpManager && _httpManager[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_GET_OFFLINE_REQUEST_9 /* @min:%2egetOfflineRequestDetails */]();
                    if (_httpManager) {
                        return {
                            getUrl: function () {
                                if (details_1) {
                                    return details_1.url;
                                }
                                return null;
                            },
                            serialize: _serialize,
                            batch: _batch,
                            shouldProcess: function (evt) {
                                return !_disableTelemetry;
                            },
                            createPayload: function (evt) {
                                return null;
                            },
                            createOneDSPayload: function (evts) {
                                if (_httpManager[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_CREATE_ONE_DSPAYLOAD /* @min:%2ecreateOneDSPayload */]) {
                                    return _httpManager[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_CREATE_ONE_DSPAYLOAD /* @min:%2ecreateOneDSPayload */](evts, _optimizeObject);
                                }
                            }
                        };
                    }
                }
                catch (e) {
                    // eslint-disable-next-line no-empty
                }
                return null;
            };
            _self._doTeardown = function (unloadCtx, unloadState) {
                _releaseAllQueues(2 /* EventSendType.SendBeacon */, 2 /* SendRequestReason.Unload */);
                _isTeardownCalled = true;
                _httpManager.teardown();
                _removeUnloadHandlers();
                // Just register to remove all events associated with this namespace
                _initDefaults();
            };
            function _removeUnloadHandlers() {
                (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_7__.removePageUnloadEventListener)(null, _evtNamespace);
                (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_7__.removePageHideEventListener)(null, _evtNamespace);
                (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_7__.removePageShowEventListener)(null, _evtNamespace);
            }
            function _hookWParam(core) {
                var existingGetWParamMethod = core[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_GET_WPARAM /* @min:%2egetWParam */];
                core[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_GET_WPARAM /* @min:%2egetWParam */] = function () {
                    var wparam = 0;
                    if (_ignoreMc1Ms0CookieProcessing) {
                        wparam = wparam | 2;
                    }
                    return wparam | existingGetWParamMethod.call(core);
                };
            }
            function _batch(arr) {
                var rlt = EMPTY_STR;
                if (arr && arr[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_LENGTH /* @min:%2elength */]) {
                    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrForEach)(arr, function (item) {
                        if (rlt) {
                            rlt += "\n";
                        }
                        rlt += item;
                    });
                }
                return rlt;
            }
            function _serialize(event) {
                var rlt = EMPTY_STR;
                try {
                    _cleanEvent(event);
                    rlt = _httpManager[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_SERIALIZE_OFFLINE_EV8 /* @min:%2eserializeOfflineEvt */](event);
                }
                catch (e) {
                    // eslint-disable-next-line no-empty
                }
                return rlt;
            }
            // Moving event handlers out from the initialize closure so that any local variables can be garbage collected
            function _handleUnloadEvents(evt) {
                var theEvt = evt || (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.getWindow)().event; // IE 8 does not pass the event
                if (theEvt.type !== "beforeunload") {
                    // Only set the unload trigger if not beforeunload event as beforeunload can be cancelled while the other events can't
                    _isPageUnloadTriggered = true;
                    _httpManager[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_SET_UNLOADING /* @min:%2esetUnloading */](_isPageUnloadTriggered);
                }
                _releaseAllQueues(2 /* EventSendType.SendBeacon */, 2 /* SendRequestReason.Unload */);
            }
            function _handleShowEvents(evt) {
                // Handle the page becoming visible again
                _isPageUnloadTriggered = false;
                _httpManager[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_SET_UNLOADING /* @min:%2esetUnloading */](_isPageUnloadTriggered);
            }
            function _cleanEvent(event) {
                if (event.ext && event.ext[_InternalConstants__WEBPACK_IMPORTED_MODULE_12__.STR_TRACE]) {
                    delete (event.ext[_InternalConstants__WEBPACK_IMPORTED_MODULE_12__.STR_TRACE]);
                }
                if (event.ext && event.ext[_InternalConstants__WEBPACK_IMPORTED_MODULE_12__.STR_USER] && event.ext[_InternalConstants__WEBPACK_IMPORTED_MODULE_12__.STR_USER]["id"]) {
                    delete (event.ext[_InternalConstants__WEBPACK_IMPORTED_MODULE_12__.STR_USER]["id"]);
                }
                // v8 performance optimization for iterating over the keys
                if (_optimizeObject) {
                    event.ext = (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_13__.optimizeObject)(event.ext);
                    if (event[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_BASE_DATA /* @min:%2ebaseData */]) {
                        event[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_BASE_DATA /* @min:%2ebaseData */] = (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_13__.optimizeObject)(event[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_BASE_DATA /* @min:%2ebaseData */]);
                    }
                    if (event[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_DATA /* @min:%2edata */]) {
                        event[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_DATA /* @min:%2edata */] = (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_13__.optimizeObject)(event[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_DATA /* @min:%2edata */]);
                    }
                }
            }
            function _addEventToQueues(event, append) {
                // If send attempt field is undefined we should set it to 0.
                if (!event[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_SEND_ATTEMPT /* @min:%2esendAttempt */]) {
                    event[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_SEND_ATTEMPT /* @min:%2esendAttempt */] = 0;
                }
                // Add default latency
                if (!event[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_LATENCY /* @min:%2elatency */]) {
                    event[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_LATENCY /* @min:%2elatency */] = 1 /* EventLatencyValue.Normal */;
                }
                _cleanEvent(event);
                if (event[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_SYNC /* @min:%2esync */]) {
                    // If the transmission is backed off then do not send synchronous events.
                    // We will convert these events to Real time latency instead.
                    if (_currentBackoffCount || _paused) {
                        event[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_LATENCY /* @min:%2elatency */] = 3 /* EventLatencyValue.RealTime */;
                        event[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_SYNC /* @min:%2esync */] = false;
                    }
                    else {
                        // Log the event synchronously
                        if (_httpManager) {
                            // v8 performance optimization for iterating over the keys
                            if (_optimizeObject) {
                                event = (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_13__.optimizeObject)(event);
                            }
                            _httpManager[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_SEND_SYNCHRONOUS_BAT10 /* @min:%2esendSynchronousBatch */](_EventBatch__WEBPACK_IMPORTED_MODULE_14__.EventBatch.create(event[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_I_KEY /* @min:%2eiKey */], [event]), event[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_SYNC /* @min:%2esync */] === true ? 1 /* EventSendType.Synchronous */ : event[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_SYNC /* @min:%2esync */], 3 /* SendRequestReason.SyncEvent */);
                            return;
                        }
                    }
                }
                var evtLatency = event[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_LATENCY /* @min:%2elatency */];
                var queueSize = _queueSize;
                var queueLimit = _queueSizeLimit;
                if (evtLatency === 4 /* EventLatencyValue.Immediate */) {
                    queueSize = _immediateQueueSize;
                    queueLimit = _immediateQueueSizeLimit;
                }
                var eventDropped = false;
                // Only add the event if the queue isn't full or it's a direct event (which don't add to the queue sizes)
                if (queueSize < queueLimit) {
                    eventDropped = !_addEventToProperQueue(event, append);
                }
                else {
                    var dropLatency = 1 /* EventLatencyValue.Normal */;
                    var dropNumber = EventsDroppedAtOneTime;
                    if (evtLatency === 4 /* EventLatencyValue.Immediate */) {
                        // Only drop other immediate events as they are not technically sharing the general queue
                        dropLatency = 4 /* EventLatencyValue.Immediate */;
                        dropNumber = 1;
                    }
                    // Drop old event from lower or equal latency
                    eventDropped = true;
                    if (_dropEventWithLatencyOrLess(event[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_I_KEY /* @min:%2eiKey */], event[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_LATENCY /* @min:%2elatency */], dropLatency, dropNumber)) {
                        eventDropped = !_addEventToProperQueue(event, append);
                    }
                }
                if (eventDropped) {
                    // Can't drop events from current queues because the all the slots are taken by queues that are being flushed.
                    _notifyEvents(strEventsDiscarded, [event], _microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_15__.EventsDiscardedReason.QueueFull);
                }
            }
            _self.setEventQueueLimits = function (eventLimit, autoFlushLimit) {
                _postConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_EVENTS_LIMIT_IN_MEM /* @min:%2eeventsLimitInMem */] = _queueSizeLimit = (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_1__.isGreaterThanZero)(eventLimit) ? eventLimit : MaxEventsLimitInMem;
                _postConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_AUTO_FLUSH_EVENTS_LI14 /* @min:%2eautoFlushEventsLimit */] = _autoFlushEventsLimit = (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_1__.isGreaterThanZero)(autoFlushLimit) ? autoFlushLimit : 0;
                _setAutoLimits();
                // We only do this check here as during normal event addition if the queue is > then events start getting dropped
                var doFlush = _queueSize > eventLimit;
                if (!doFlush && _autoFlushBatchLimit > 0) {
                    // Check the auto flush max batch size
                    for (var latency = 1 /* EventLatencyValue.Normal */; !doFlush && latency <= 3 /* EventLatencyValue.RealTime */; latency++) {
                        var batchQueue = _batchQueues[latency];
                        if (batchQueue && batchQueue[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_BATCHES /* @min:%2ebatches */]) {
                            (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrForEach)(batchQueue[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_BATCHES /* @min:%2ebatches */], function (theBatch) {
                                if (theBatch && theBatch[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_COUNT /* @min:%2ecount */]() >= _autoFlushBatchLimit) {
                                    // If any 1 batch is > than the limit then trigger an auto flush
                                    doFlush = true;
                                }
                            });
                        }
                    }
                }
                _performAutoFlush(true, doFlush);
            };
            _self.pause = function () {
                _clearScheduledTimer();
                _paused = true;
                _httpManager.pause();
            };
            _self.resume = function () {
                _paused = false;
                _httpManager.resume();
                _scheduleTimer();
            };
            _self._loadTransmitProfiles = function (profiles) {
                _resetTransmitProfiles();
                (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objForEachKey)(profiles, function (profileName, profileValue) {
                    var profLen = profileValue[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_LENGTH /* @min:%2elength */];
                    if (profLen >= 2) {
                        var directValue = (profLen > 2 ? profileValue[2] : 0);
                        profileValue[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_SPLICE /* @min:%2esplice */](0, profLen - 2);
                        // Make sure if a higher latency is set to not send then don't send lower latency
                        if (profileValue[1] < 0) {
                            profileValue[0] = -1;
                        }
                        // Make sure each latency is multiple of the latency higher then it. If not a multiple
                        // we round up so that it becomes a multiple.
                        if (profileValue[1] > 0 && profileValue[0] > 0) {
                            var timerMultiplier = profileValue[0] / profileValue[1];
                            profileValue[0] = Math.ceil(timerMultiplier) * profileValue[1];
                        }
                        // Add back the direct profile timeout
                        if (directValue >= 0 && profileValue[1] >= 0 && directValue > profileValue[1]) {
                            // Make sure if it's not disabled (< 0) then make sure it's not larger than RealTime
                            directValue = profileValue[1];
                        }
                        profileValue[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_PUSH /* @min:%2epush */](directValue);
                        _profiles[profileName] = profileValue;
                    }
                });
            };
            _self.flush = function (async, callback, sendReason) {
                if (async === void 0) { async = true; }
                var result;
                if (!_paused) {
                    sendReason = sendReason || 1 /* SendRequestReason.ManualFlush */;
                    if (async) {
                        if (!callback) {
                            result = (0,_nevware21_ts_async__WEBPACK_IMPORTED_MODULE_16__.createPromise)(function (resolve) {
                                // Set the callback to the promise resolve callback
                                callback = resolve;
                            });
                        }
                        if (_flushCallbackTimer == null) {
                            // Clear the normal schedule timer as we are going to try and flush ASAP
                            _clearScheduledTimer();
                            // Move all queued events to the HttpManager so that we don't discard new events (Auto flush scenario)
                            _queueBatches(1 /* EventLatencyValue.Normal */, 0 /* EventSendType.Batched */, sendReason);
                            _flushCallbackTimer = _createTimer(function () {
                                _flushCallbackTimer = null;
                                _flushImpl(callback, sendReason);
                            }, 0);
                        }
                        else {
                            // Even if null (no callback) this will ensure after the flushImpl finishes waiting
                            // for a completely idle connection it will attempt to re-flush any queued events on the next cycle
                            _flushCallbackQueue[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_PUSH /* @min:%2epush */](callback);
                        }
                    }
                    else {
                        // Clear the normal schedule timer as we are going to try and flush ASAP
                        var cleared = _clearScheduledTimer();
                        // Now cause all queued events to be sent synchronously
                        _sendEventsForLatencyAndAbove(1 /* EventLatencyValue.Normal */, 1 /* EventSendType.Synchronous */, sendReason);
                        callback && callback();
                        if (cleared) {
                            // restart the normal event timer if it was cleared
                            _scheduleTimer();
                        }
                    }
                }
                return result;
            };
            _self.setMsaAuthTicket = function (ticket) {
                _httpManager[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_ADD_HEADER /* @min:%2eaddHeader */](_InternalConstants__WEBPACK_IMPORTED_MODULE_12__.STR_MSA_DEVICE_TICKET, ticket);
            };
            _self.setAuthPluginHeader = function (token) {
                _httpManager[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_ADD_HEADER /* @min:%2eaddHeader */](_InternalConstants__WEBPACK_IMPORTED_MODULE_12__.STR_AUTH_WEB_TOKEN, token);
            };
            _self.removeAuthPluginHeader = function () {
                _httpManager.removeHeader(_InternalConstants__WEBPACK_IMPORTED_MODULE_12__.STR_AUTH_WEB_TOKEN);
            };
            _self.hasEvents = _hasEvents;
            _self._setTransmitProfile = function (profileName) {
                if (_currentProfile !== profileName && _profiles[profileName] !== undefined) {
                    _clearScheduledTimer();
                    _currentProfile = profileName;
                    _scheduleTimer();
                }
            };
            (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_13__.proxyFunctions)(_self, function () { return _httpManager; }, ["addResponseHandler"]);
            /**
             * Batch and send events currently in the queue for the given latency.
             * @param latency - Latency for which to send events.
             */
            function _sendEventsForLatencyAndAbove(latency, sendType, sendReason) {
                var queued = _queueBatches(latency, sendType, sendReason);
                // Always trigger the request as while the post channel may not have queued additional events, the httpManager may already have waiting events
                _httpManager[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_SEND_QUEUED_REQUESTS /* @min:%2esendQueuedRequests */](sendType, sendReason);
                return queued;
            }
            function _hasEvents() {
                return _queueSize > 0;
            }
            /**
             * Try to schedule the timer after which events will be sent. If there are
             * no events to be sent, or there is already a timer scheduled, or the
             * http manager doesn't have any idle connections this method is no-op.
             */
            function _scheduleTimer() {
                // If we had previously attempted to send requests, but the http manager didn't have any idle connections then the requests where delayed
                // so try and requeue then again now
                if (_delayedBatchSendLatency >= 0 && _queueBatches(_delayedBatchSendLatency, 0 /* EventSendType.Batched */, _delayedBatchReason)) {
                    _httpManager[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_SEND_QUEUED_REQUESTS /* @min:%2esendQueuedRequests */](0 /* EventSendType.Batched */, _delayedBatchReason);
                }
                if (_immediateQueueSize > 0 && !_immediateTimer && !_paused) {
                    // During initialization _profiles enforce that the direct [2] is less than real time [1] timer value
                    // If the immediateTimeout is disabled the immediate events will be sent with Real Time events
                    var immediateTimeOut = _profiles[_currentProfile][2];
                    if (immediateTimeOut >= 0) {
                        _immediateTimer = _createTimer(function () {
                            _immediateTimer = null;
                            // Only try to send direct events
                            _sendEventsForLatencyAndAbove(4 /* EventLatencyValue.Immediate */, 0 /* EventSendType.Batched */, 1 /* SendRequestReason.NormalSchedule */);
                            _scheduleTimer();
                        }, immediateTimeOut);
                    }
                }
                // During initialization the _profiles enforce that the normal [0] is a multiple of the real time [1] timer value
                var timeOut = _profiles[_currentProfile][1];
                if (!_scheduledTimer && !_flushCallbackTimer && timeOut >= 0 && !_paused) {
                    if (_hasEvents()) {
                        _scheduledTimer = _createTimer(function () {
                            _scheduledTimer = null;
                            _sendEventsForLatencyAndAbove(_timerCount === 0 ? 3 /* EventLatencyValue.RealTime */ : 1 /* EventLatencyValue.Normal */, 0 /* EventSendType.Batched */, 1 /* SendRequestReason.NormalSchedule */);
                            // Increment the count for next cycle
                            _timerCount++;
                            _timerCount %= 2;
                            _scheduleTimer();
                        }, timeOut);
                    }
                    else {
                        _timerCount = 0;
                    }
                }
            }
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN__BACK_OFF_TRANSMISSI12 /* @min:%2e_backOffTransmission */] = function () {
                if (_currentBackoffCount < MaxBackoffCount) {
                    _currentBackoffCount++;
                    _clearScheduledTimer();
                    _scheduleTimer();
                }
            };
            _self._clearBackOff = function () {
                if (_currentBackoffCount) {
                    _currentBackoffCount = 0;
                    _clearScheduledTimer();
                    _scheduleTimer();
                }
            };
            function _initDefaults() {
                _postConfig = null;
                _isTeardownCalled = false;
                _flushCallbackQueue = [];
                _flushCallbackTimer = null;
                _paused = false;
                _immediateQueueSize = 0;
                _immediateQueueSizeLimit = 500;
                _queueSize = 0;
                _queueSizeLimit = MaxEventsLimitInMem;
                _profiles = {};
                _currentProfile = _DataModels__WEBPACK_IMPORTED_MODULE_3__.RT_PROFILE;
                _scheduledTimer = null;
                _immediateTimer = null;
                _currentBackoffCount = 0;
                _timerCount = 0;
                _batchQueues = {};
                _autoFlushEventsLimit = 0;
                _unloadHandlersAdded = false;
                // either MaxBatchSize * (1+ Max Connections) or _queueLimit / 6 (where 3 latency Queues [normal, realtime, cost deferred] * 2 [allow half full -- allow for retry])
                _autoFlushBatchLimit = 0;
                _delayedBatchSendLatency = -1;
                _delayedBatchReason = null;
                _optimizeObject = true;
                _isPageUnloadTriggered = false;
                _maxEventSendAttempts = MaxSendAttempts;
                _maxUnloadEventSendAttempts = MaxSyncUnloadSendAttempts;
                _evtNamespace = null;
                _overrideInstrumentationKey = null;
                _disableTelemetry = false;
                _timeoutWrapper = (0,_TimeoutOverrideWrapper__WEBPACK_IMPORTED_MODULE_11__.createTimeoutWrapper)();
                _httpManager = new _HttpManager__WEBPACK_IMPORTED_MODULE_17__.HttpManager(MaxNumberEventPerBatch, MaxConnections, MaxRequestRetriesBeforeBackoff, {
                    requeue: _requeueEvents,
                    send: _sendingEvent,
                    sent: _eventsSentEvent,
                    drop: _eventsDropped,
                    rspFail: _eventsResponseFail,
                    oth: _otherEvent
                });
                _initializeProfiles();
                _clearQueues();
                _setAutoLimits();
            }
            function _createTimer(theTimerFunc, timeOut) {
                // If the transmission is backed off make the timer at least 1 sec to allow for back off.
                if (timeOut === 0 && _currentBackoffCount) {
                    timeOut = 1;
                }
                var timerMultiplier = 1000;
                if (_currentBackoffCount) {
                    timerMultiplier = (0,_RetryPolicy__WEBPACK_IMPORTED_MODULE_18__.retryPolicyGetMillisToBackoffForRetry)(_currentBackoffCount - 1);
                }
                return _timeoutWrapper.set(theTimerFunc, timeOut * timerMultiplier);
            }
            function _clearScheduledTimer() {
                if (_scheduledTimer !== null) {
                    _scheduledTimer.cancel();
                    _scheduledTimer = null;
                    _timerCount = 0;
                    return true;
                }
                return false;
            }
            // Try to send all queued events using beacons if available
            function _releaseAllQueues(sendType, sendReason) {
                _clearScheduledTimer();
                // Cancel all flush callbacks
                if (_flushCallbackTimer) {
                    _flushCallbackTimer.cancel();
                    _flushCallbackTimer = null;
                }
                if (!_paused) {
                    // Queue all the remaining requests to be sent. The requests will be sent using HTML5 Beacons if they are available.
                    _sendEventsForLatencyAndAbove(1 /* EventLatencyValue.Normal */, sendType, sendReason);
                }
            }
            /**
             * Add empty queues for all latencies in the inbound queues map. This is called
             * when Transmission Manager is being flushed. This ensures that new events added
             * after flush are stored separately till we flush the current events.
             */
            function _clearQueues() {
                _batchQueues[4 /* EventLatencyValue.Immediate */] = {
                    batches: [],
                    iKeyMap: {}
                };
                _batchQueues[3 /* EventLatencyValue.RealTime */] = {
                    batches: [],
                    iKeyMap: {}
                };
                _batchQueues[2 /* EventLatencyValue.CostDeferred */] = {
                    batches: [],
                    iKeyMap: {}
                };
                _batchQueues[1 /* EventLatencyValue.Normal */] = {
                    batches: [],
                    iKeyMap: {}
                };
            }
            function _getEventBatch(iKey, latency, create) {
                var batchQueue = _batchQueues[latency];
                if (!batchQueue) {
                    latency = 1 /* EventLatencyValue.Normal */;
                    batchQueue = _batchQueues[latency];
                }
                var eventBatch = batchQueue.iKeyMap[iKey];
                if (!eventBatch && create) {
                    eventBatch = _EventBatch__WEBPACK_IMPORTED_MODULE_14__.EventBatch.create(iKey);
                    batchQueue.batches[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_PUSH /* @min:%2epush */](eventBatch);
                    batchQueue.iKeyMap[iKey] = eventBatch;
                }
                return eventBatch;
            }
            function _performAutoFlush(isAsync, doFlush) {
                // Only perform the auto flush check if the httpManager has an idle connection and we are not in a backoff situation
                if (_httpManager[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_CAN_SEND_REQUEST /* @min:%2ecanSendRequest */]() && !_currentBackoffCount) {
                    if (_autoFlushEventsLimit > 0 && _queueSize > _autoFlushEventsLimit) {
                        // Force flushing
                        doFlush = true;
                    }
                    if (doFlush && _flushCallbackTimer == null) {
                        // Auto flush the queue, adding a callback to avoid the creation of a promise
                        _self.flush(isAsync, function () { }, 20 /* SendRequestReason.MaxQueuedEvents */);
                    }
                }
            }
            function _addEventToProperQueue(event, append) {
                // v8 performance optimization for iterating over the keys
                if (_optimizeObject) {
                    event = (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_13__.optimizeObject)(event);
                }
                var latency = event[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_LATENCY /* @min:%2elatency */];
                var eventBatch = _getEventBatch(event[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_I_KEY /* @min:%2eiKey */], latency, true);
                if (eventBatch.addEvent(event)) {
                    if (latency !== 4 /* EventLatencyValue.Immediate */) {
                        _queueSize++;
                        // Check for auto flushing based on total events in the queue, but not for requeued or retry events
                        if (append && event[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_SEND_ATTEMPT /* @min:%2esendAttempt */] === 0) {
                            // Force the flushing of the batch if the batch (specific iKey / latency combination) reaches it's auto flush limit
                            _performAutoFlush(!event.sync, _autoFlushBatchLimit > 0 && eventBatch[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_COUNT /* @min:%2ecount */]() >= _autoFlushBatchLimit);
                        }
                    }
                    else {
                        // Direct events don't need auto flushing as they are scheduled (by default) for immediate delivery
                        _immediateQueueSize++;
                    }
                    return true;
                }
                return false;
            }
            function _dropEventWithLatencyOrLess(iKey, latency, currentLatency, dropNumber) {
                while (currentLatency <= latency) {
                    var eventBatch = _getEventBatch(iKey, latency, true);
                    if (eventBatch && eventBatch[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_COUNT /* @min:%2ecount */]() > 0) {
                        // Dropped oldest events from lowest possible latency
                        var droppedEvents = eventBatch[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_SPLIT /* @min:%2esplit */](0, dropNumber);
                        var droppedCount = droppedEvents[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_COUNT /* @min:%2ecount */]();
                        if (droppedCount > 0) {
                            if (currentLatency === 4 /* EventLatencyValue.Immediate */) {
                                _immediateQueueSize -= droppedCount;
                            }
                            else {
                                _queueSize -= droppedCount;
                            }
                            _notifyBatchEvents(strEventsDiscarded, [droppedEvents], _microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_15__.EventsDiscardedReason.QueueFull);
                            return true;
                        }
                    }
                    currentLatency++;
                }
                // Unable to drop any events -- lets just make sure the queue counts are correct to avoid exhaustion
                _resetQueueCounts();
                return false;
            }
            /**
             * Internal helper to reset the queue counts, used as a backstop to avoid future queue exhaustion errors
             * that might occur because of counting issues.
             */
            function _resetQueueCounts() {
                var immediateQueue = 0;
                var normalQueue = 0;
                var _loop_1 = function (latency) {
                    var batchQueue = _batchQueues[latency];
                    if (batchQueue && batchQueue[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_BATCHES /* @min:%2ebatches */]) {
                        (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrForEach)(batchQueue[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_BATCHES /* @min:%2ebatches */], function (theBatch) {
                            if (latency === 4 /* EventLatencyValue.Immediate */) {
                                immediateQueue += theBatch[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_COUNT /* @min:%2ecount */]();
                            }
                            else {
                                normalQueue += theBatch[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_COUNT /* @min:%2ecount */]();
                            }
                        });
                    }
                };
                for (var latency = 1 /* EventLatencyValue.Normal */; latency <= 4 /* EventLatencyValue.Immediate */; latency++) {
                    _loop_1(latency);
                }
                _queueSize = normalQueue;
                _immediateQueueSize = immediateQueue;
            }
            function _queueBatches(latency, sendType, sendReason) {
                var eventsQueued = false;
                var isAsync = sendType === 0 /* EventSendType.Batched */;
                // Only queue batches (to the HttpManager) if this is a sync request or the httpManager has an idle connection
                // Thus keeping the events within the PostChannel until the HttpManager has a connection available
                // This is so we can drop "old" events if the queue is getting full because we can't successfully send events
                if (!isAsync || _httpManager[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_CAN_SEND_REQUEST /* @min:%2ecanSendRequest */]()) {
                    (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_6__.doPerf)(_self.core, function () { return "PostChannel._queueBatches"; }, function () {
                        var droppedEvents = [];
                        var latencyToProcess = 4 /* EventLatencyValue.Immediate */;
                        while (latencyToProcess >= latency) {
                            var batchQueue = _batchQueues[latencyToProcess];
                            if (batchQueue && batchQueue.batches && batchQueue.batches[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_LENGTH /* @min:%2elength */] > 0) {
                                (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrForEach)(batchQueue[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_BATCHES /* @min:%2ebatches */], function (theBatch) {
                                    // Add the batch to the http manager to send the requests
                                    if (!_httpManager.addBatch(theBatch)) {
                                        // The events from this iKey are being dropped (killed)
                                        droppedEvents = droppedEvents[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_CONCAT /* @min:%2econcat */](theBatch[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_EVENTS /* @min:%2eevents */]());
                                    }
                                    else {
                                        eventsQueued = eventsQueued || (theBatch && theBatch[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_COUNT /* @min:%2ecount */]() > 0);
                                    }
                                    if (latencyToProcess === 4 /* EventLatencyValue.Immediate */) {
                                        _immediateQueueSize -= theBatch[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_COUNT /* @min:%2ecount */]();
                                    }
                                    else {
                                        _queueSize -= theBatch[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_COUNT /* @min:%2ecount */]();
                                    }
                                });
                                // Remove all batches from this Queue
                                batchQueue[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_BATCHES /* @min:%2ebatches */] = [];
                                batchQueue.iKeyMap = {};
                            }
                            latencyToProcess--;
                        }
                        if (droppedEvents[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_LENGTH /* @min:%2elength */] > 0) {
                            _notifyEvents(strEventsDiscarded, droppedEvents, _microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_15__.EventsDiscardedReason.KillSwitch);
                        }
                        if (eventsQueued && _delayedBatchSendLatency >= latency) {
                            // We have queued events at the same level as the delayed values so clear the setting
                            _delayedBatchSendLatency = -1;
                            _delayedBatchReason = 0 /* SendRequestReason.Undefined */;
                        }
                    }, function () { return ({ latency: latency, sendType: sendType, sendReason: sendReason }); }, !isAsync);
                }
                else {
                    // remember the min latency so that we can re-trigger later
                    _delayedBatchSendLatency = _delayedBatchSendLatency >= 0 ? Math.min(_delayedBatchSendLatency, latency) : latency;
                    _delayedBatchReason = Math.max(_delayedBatchReason, sendReason);
                }
                return eventsQueued;
            }
            /**
             * This is the callback method is called as part of the manual flushing process.
             * @param callback
             * @param sendReason
             */
            function _flushImpl(callback, sendReason) {
                // Add any additional queued events and cause all queued events to be sent asynchronously
                _sendEventsForLatencyAndAbove(1 /* EventLatencyValue.Normal */, 0 /* EventSendType.Batched */, sendReason);
                // All events (should) have been queue -- lets just make sure the queue counts are correct to avoid queue exhaustion (previous bug #9685112)
                _resetQueueCounts();
                _waitForIdleManager(function () {
                    // Only called AFTER the httpManager does not have any outstanding requests
                    if (callback) {
                        callback();
                    }
                    if (_flushCallbackQueue[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_LENGTH /* @min:%2elength */] > 0) {
                        _flushCallbackTimer = _createTimer(function () {
                            _flushCallbackTimer = null;
                            _flushImpl(_flushCallbackQueue.shift(), sendReason);
                        }, 0);
                    }
                    else {
                        // No more flush requests
                        _flushCallbackTimer = null;
                        // Restart the normal timer schedule
                        _scheduleTimer();
                    }
                });
            }
            function _waitForIdleManager(callback) {
                if (_httpManager[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_IS_COMPLETELY_IDLE /* @min:%2eisCompletelyIdle */]()) {
                    callback();
                }
                else {
                    _flushCallbackTimer = _createTimer(function () {
                        _flushCallbackTimer = null;
                        _waitForIdleManager(callback);
                    }, FlushCheckTimer);
                }
            }
            /**
             * Resets the transmit profiles to the default profiles of Real Time, Near Real Time
             * and Best Effort. This removes all the custom profiles that were loaded.
             */
            function _resetTransmitProfiles() {
                _clearScheduledTimer();
                _initializeProfiles();
                _currentProfile = _DataModels__WEBPACK_IMPORTED_MODULE_3__.RT_PROFILE;
                _scheduleTimer();
            }
            function _initializeProfiles() {
                _profiles = {};
                _profiles[_DataModels__WEBPACK_IMPORTED_MODULE_3__.RT_PROFILE] = [2, 1, 0];
                _profiles[_DataModels__WEBPACK_IMPORTED_MODULE_3__.NRT_PROFILE] = [6, 3, 0];
                _profiles[_DataModels__WEBPACK_IMPORTED_MODULE_3__.BE_PROFILE] = [18, 9, 0];
            }
            /**
             * The notification handler for requeue events
             * @ignore
             */
            function _requeueEvents(batches, reason) {
                var droppedEvents = [];
                var maxSendAttempts = _maxEventSendAttempts;
                if (_isPageUnloadTriggered) {
                    // If a page unlaod has been triggered reduce the number of times we try to "retry"
                    maxSendAttempts = _maxUnloadEventSendAttempts;
                }
                (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrForEach)(batches, function (theBatch) {
                    if (theBatch && theBatch[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_COUNT /* @min:%2ecount */]() > 0) {
                        (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrForEach)(theBatch[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_EVENTS /* @min:%2eevents */](), function (theEvent) {
                            if (theEvent) {
                                // Check if the request being added back is for a sync event in which case mark it no longer a sync event
                                if (theEvent[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_SYNC /* @min:%2esync */]) {
                                    theEvent[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_LATENCY /* @min:%2elatency */] = 4 /* EventLatencyValue.Immediate */;
                                    theEvent[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_SYNC /* @min:%2esync */] = false;
                                }
                                if (theEvent[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_SEND_ATTEMPT /* @min:%2esendAttempt */] < maxSendAttempts) {
                                    // Reset the event timings
                                    (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_1__.setProcessTelemetryTimings)(theEvent, _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_IDENTIFIER /* @min:%2eidentifier */]);
                                    _addEventToQueues(theEvent, false);
                                }
                                else {
                                    droppedEvents[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_PUSH /* @min:%2epush */](theEvent);
                                }
                            }
                        });
                    }
                });
                if (droppedEvents[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_LENGTH /* @min:%2elength */] > 0) {
                    _notifyEvents(strEventsDiscarded, droppedEvents, _microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_15__.EventsDiscardedReason.NonRetryableStatus);
                }
                if (_isPageUnloadTriggered) {
                    // Unload event has been received so we need to try and flush new events
                    _releaseAllQueues(2 /* EventSendType.SendBeacon */, 2 /* SendRequestReason.Unload */);
                }
            }
            function _callNotification(evtName, theArgs) {
                var manager = (_notificationManager || {});
                var notifyFunc = manager[evtName];
                if (notifyFunc) {
                    try {
                        notifyFunc.apply(manager, theArgs);
                    }
                    catch (e) {
                        (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_19__._throwInternal)(_self.diagLog(), 1 /* eLoggingSeverity.CRITICAL */, 74 /* _eInternalMessageId.NotificationException */, evtName + " notification failed: " + e);
                    }
                }
            }
            function _notifyEvents(evtName, theEvents) {
                var extraArgs = [];
                for (var _i = 2; _i < arguments.length; _i++) {
                    extraArgs[_i - 2] = arguments[_i];
                }
                if (theEvents && theEvents[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_LENGTH /* @min:%2elength */] > 0) {
                    _callNotification(evtName, [theEvents][_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_CONCAT /* @min:%2econcat */](extraArgs));
                }
            }
            function _notifyBatchEvents(evtName, batches) {
                var extraArgs = [];
                for (var _i = 2; _i < arguments.length; _i++) {
                    extraArgs[_i - 2] = arguments[_i];
                }
                if (batches && batches[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_LENGTH /* @min:%2elength */] > 0) {
                    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrForEach)(batches, function (theBatch) {
                        if (theBatch && theBatch[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_COUNT /* @min:%2ecount */]() > 0) {
                            _callNotification(evtName, [theBatch.events()][_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_CONCAT /* @min:%2econcat */](extraArgs));
                        }
                    });
                }
            }
            /**
             * The notification handler for when batches are about to be sent
             * @ignore
             */
            function _sendingEvent(batches, reason, isSyncRequest) {
                if (batches && batches[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_LENGTH /* @min:%2elength */] > 0) {
                    _callNotification("eventsSendRequest", [(reason >= 1000 /* EventBatchNotificationReason.SendingUndefined */ && reason <= 1999 /* EventBatchNotificationReason.SendingEventMax */ ?
                            reason - 1000 /* EventBatchNotificationReason.SendingUndefined */ :
                            0 /* SendRequestReason.Undefined */), isSyncRequest !== true]);
                }
            }
            /**
             * This event represents that a batch of events have been successfully sent and a response received
             * @param batches The notification handler for when the batches have been successfully sent
             * @param reason For this event the reason will always be EventBatchNotificationReason.Complete
             */
            function _eventsSentEvent(batches, reason) {
                _notifyBatchEvents("eventsSent", batches, reason);
                // Try and schedule the processing timer if we have events
                _scheduleTimer();
            }
            function _eventsDropped(batches, reason) {
                _notifyBatchEvents(strEventsDiscarded, batches, (reason >= 8000 /* EventBatchNotificationReason.EventsDropped */ && reason <= 8999 /* EventBatchNotificationReason.EventsDroppedMax */ ?
                    reason - 8000 /* EventBatchNotificationReason.EventsDropped */ :
                    _microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_15__.EventsDiscardedReason.Unknown));
            }
            function _eventsResponseFail(batches) {
                _notifyBatchEvents(strEventsDiscarded, batches, _microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_15__.EventsDiscardedReason.NonRetryableStatus);
                // Try and schedule the processing timer if we have events
                _scheduleTimer();
            }
            function _otherEvent(batches, reason) {
                _notifyBatchEvents(strEventsDiscarded, batches, _microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_15__.EventsDiscardedReason.Unknown);
                // Try and schedule the processing timer if we have events
                _scheduleTimer();
            }
            function _setAutoLimits() {
                if (!_disableAutoBatchFlushLimit) {
                    _autoFlushBatchLimit = Math.max(MaxNumberEventPerBatch * (MaxConnections + 1), _queueSizeLimit / 6);
                }
                else {
                    _autoFlushBatchLimit = 0;
                }
            }
        });
        return _this;
    }
// Removed Stub for PostChannel.prototype.initialize.
// Removed Stub for PostChannel.prototype.processTelemetry.
// Removed Stub for PostChannel.prototype.setEventQueueLimits.
// Removed Stub for PostChannel.prototype.pause.
// Removed Stub for PostChannel.prototype.resume.
// Removed Stub for PostChannel.prototype.addResponseHandler.
// Removed Stub for PostChannel.prototype.flush.
// Removed Stub for PostChannel.prototype.setMsaAuthTicket.
// Removed Stub for PostChannel.prototype.setAuthPluginHeader.
// Removed Stub for PostChannel.prototype.removeAuthPluginHeader.
// Removed Stub for PostChannel.prototype.hasEvents.
// Removed Stub for PostChannel.prototype._loadTransmitProfiles.
// Removed Stub for PostChannel.prototype._setTransmitProfile.
// Removed Stub for PostChannel.prototype._backOffTransmission.
// Removed Stub for PostChannel.prototype._clearBackOff.
// Removed Stub for PostChannel.prototype.getOfflineSupport.
    // This is a workaround for an IE bug when using dynamicProto() with classes that don't have any
    // non-dynamic functions or static properties/functions when using uglify-js to minify the resulting code.
    PostChannel.__ieDyn=1;

    return PostChannel;
}(_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_20__.BaseTelemetryPlugin));

//# sourceMappingURL=PostChannel.js.map

/***/ }),
/* 78 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BE_PROFILE": () => (/* binding */ BE_PROFILE),
/* harmony export */   "NRT_PROFILE": () => (/* binding */ NRT_PROFILE),
/* harmony export */   "RT_PROFILE": () => (/* binding */ RT_PROFILE)
/* harmony export */ });
/*
 * 1DS JS SDK POST plugin, 4.3.0
 * Copyright (c) Microsoft and contributors. All rights reserved.
 * (Microsoft Internal Only)
 */
/**
 * Real Time profile (default profile). RealTime Latency events are sent every 1 sec and
 * Normal Latency events are sent every 2 sec.
 */
var RT_PROFILE = "REAL_TIME";
/**
 * Near Real Time profile. RealTime Latency events are sent every 3 sec and
 * Normal Latency events are sent every 6 sec.
 */
var NRT_PROFILE = "NEAR_REAL_TIME";
/**
 * Best Effort. RealTime Latency events are sent every 9 sec and
 * Normal Latency events are sent every 18 sec.
 */
var BE_PROFILE = "BEST_EFFORT";
//# sourceMappingURL=DataModels.js.map

/***/ }),
/* 79 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "_DYN_ADD_HEADER": () => (/* binding */ _DYN_ADD_HEADER),
/* harmony export */   "_DYN_ADD_NO_RESPONSE": () => (/* binding */ _DYN_ADD_NO_RESPONSE),
/* harmony export */   "_DYN_ALLOW_REQUEST_SENDIN0": () => (/* binding */ _DYN_ALLOW_REQUEST_SENDIN0),
/* harmony export */   "_DYN_ALWAYS_USE_XHR_OVERR7": () => (/* binding */ _DYN_ALWAYS_USE_XHR_OVERR7),
/* harmony export */   "_DYN_AUTO_FLUSH_EVENTS_LI14": () => (/* binding */ _DYN_AUTO_FLUSH_EVENTS_LI14),
/* harmony export */   "_DYN_AVOID_OPTIONS": () => (/* binding */ _DYN_AVOID_OPTIONS),
/* harmony export */   "_DYN_BASE_DATA": () => (/* binding */ _DYN_BASE_DATA),
/* harmony export */   "_DYN_BATCHES": () => (/* binding */ _DYN_BATCHES),
/* harmony export */   "_DYN_CAN_SEND_REQUEST": () => (/* binding */ _DYN_CAN_SEND_REQUEST),
/* harmony export */   "_DYN_CLEAR_TIMEOUT_OVERRI3": () => (/* binding */ _DYN_CLEAR_TIMEOUT_OVERRI3),
/* harmony export */   "_DYN_CONCAT": () => (/* binding */ _DYN_CONCAT),
/* harmony export */   "_DYN_COUNT": () => (/* binding */ _DYN_COUNT),
/* harmony export */   "_DYN_CREATE_ONE_DSPAYLOAD": () => (/* binding */ _DYN_CREATE_ONE_DSPAYLOAD),
/* harmony export */   "_DYN_CREATE_PAYLOAD": () => (/* binding */ _DYN_CREATE_PAYLOAD),
/* harmony export */   "_DYN_DATA": () => (/* binding */ _DYN_DATA),
/* harmony export */   "_DYN_DISABLE_AUTO_BATCH_F15": () => (/* binding */ _DYN_DISABLE_AUTO_BATCH_F15),
/* harmony export */   "_DYN_DISABLE_EVENT_TIMING5": () => (/* binding */ _DYN_DISABLE_EVENT_TIMING5),
/* harmony export */   "_DYN_DISABLE_FETCH_KEEP_A6": () => (/* binding */ _DYN_DISABLE_FETCH_KEEP_A6),
/* harmony export */   "_DYN_DISABLE_OPTIMIZE_OBJ": () => (/* binding */ _DYN_DISABLE_OPTIMIZE_OBJ),
/* harmony export */   "_DYN_DISABLE_TELEMETRY": () => (/* binding */ _DYN_DISABLE_TELEMETRY),
/* harmony export */   "_DYN_DISABLE_XHR_SYNC": () => (/* binding */ _DYN_DISABLE_XHR_SYNC),
/* harmony export */   "_DYN_ENABLE_COMPOUND_KEY": () => (/* binding */ _DYN_ENABLE_COMPOUND_KEY),
/* harmony export */   "_DYN_EVENTS": () => (/* binding */ _DYN_EVENTS),
/* harmony export */   "_DYN_EVENTS_LIMIT_IN_MEM": () => (/* binding */ _DYN_EVENTS_LIMIT_IN_MEM),
/* harmony export */   "_DYN_EXCLUDE_CS_META_DATA": () => (/* binding */ _DYN_EXCLUDE_CS_META_DATA),
/* harmony export */   "_DYN_FIRST_REQUEST_SENT": () => (/* binding */ _DYN_FIRST_REQUEST_SENT),
/* harmony export */   "_DYN_GET_CLOCK_SKEW_HEADE2": () => (/* binding */ _DYN_GET_CLOCK_SKEW_HEADE2),
/* harmony export */   "_DYN_GET_OFFLINE_REQUEST_9": () => (/* binding */ _DYN_GET_OFFLINE_REQUEST_9),
/* harmony export */   "_DYN_GET_WPARAM": () => (/* binding */ _DYN_GET_WPARAM),
/* harmony export */   "_DYN_HDRS": () => (/* binding */ _DYN_HDRS),
/* harmony export */   "_DYN_HEADERS": () => (/* binding */ _DYN_HEADERS),
/* harmony export */   "_DYN_IDENTIFIER": () => (/* binding */ _DYN_IDENTIFIER),
/* harmony export */   "_DYN_IGNORE_MC1_MS0_COOKI13": () => (/* binding */ _DYN_IGNORE_MC1_MS0_COOKI13),
/* harmony export */   "_DYN_INITIALIZE": () => (/* binding */ _DYN_INITIALIZE),
/* harmony export */   "_DYN_IS_BEACON": () => (/* binding */ _DYN_IS_BEACON),
/* harmony export */   "_DYN_IS_COMPLETELY_IDLE": () => (/* binding */ _DYN_IS_COMPLETELY_IDLE),
/* harmony export */   "_DYN_IS_SYNC": () => (/* binding */ _DYN_IS_SYNC),
/* harmony export */   "_DYN_IS_TEARDOWN": () => (/* binding */ _DYN_IS_TEARDOWN),
/* harmony export */   "_DYN_IS_TENANT_KILLED": () => (/* binding */ _DYN_IS_TENANT_KILLED),
/* harmony export */   "_DYN_I_KEY": () => (/* binding */ _DYN_I_KEY),
/* harmony export */   "_DYN_LATENCY": () => (/* binding */ _DYN_LATENCY),
/* harmony export */   "_DYN_LENGTH": () => (/* binding */ _DYN_LENGTH),
/* harmony export */   "_DYN_OVERRIDE_ENDPOINT_UR4": () => (/* binding */ _DYN_OVERRIDE_ENDPOINT_UR4),
/* harmony export */   "_DYN_OVERRIDE_INSTRUMENTA16": () => (/* binding */ _DYN_OVERRIDE_INSTRUMENTA16),
/* harmony export */   "_DYN_PAYLOAD_BLOB": () => (/* binding */ _DYN_PAYLOAD_BLOB),
/* harmony export */   "_DYN_PAYLOAD_PREPROCESSOR": () => (/* binding */ _DYN_PAYLOAD_PREPROCESSOR),
/* harmony export */   "_DYN_PUSH": () => (/* binding */ _DYN_PUSH),
/* harmony export */   "_DYN_SEND_ATTEMPT": () => (/* binding */ _DYN_SEND_ATTEMPT),
/* harmony export */   "_DYN_SEND_QUEUED_REQUESTS": () => (/* binding */ _DYN_SEND_QUEUED_REQUESTS),
/* harmony export */   "_DYN_SEND_SYNCHRONOUS_BAT10": () => (/* binding */ _DYN_SEND_SYNCHRONOUS_BAT10),
/* harmony export */   "_DYN_SEND_TYPE": () => (/* binding */ _DYN_SEND_TYPE),
/* harmony export */   "_DYN_SERIALIZE_OFFLINE_EV8": () => (/* binding */ _DYN_SERIALIZE_OFFLINE_EV8),
/* harmony export */   "_DYN_SET_CLOCK_SKEW": () => (/* binding */ _DYN_SET_CLOCK_SKEW),
/* harmony export */   "_DYN_SET_KILL_SWITCH_TENA11": () => (/* binding */ _DYN_SET_KILL_SWITCH_TENA11),
/* harmony export */   "_DYN_SET_TIMEOUT_OVERRIDE": () => (/* binding */ _DYN_SET_TIMEOUT_OVERRIDE),
/* harmony export */   "_DYN_SET_UNLOADING": () => (/* binding */ _DYN_SET_UNLOADING),
/* harmony export */   "_DYN_SHOULD_ADD_CLOCK_SKE1": () => (/* binding */ _DYN_SHOULD_ADD_CLOCK_SKE1),
/* harmony export */   "_DYN_SPLICE": () => (/* binding */ _DYN_SPLICE),
/* harmony export */   "_DYN_SPLIT": () => (/* binding */ _DYN_SPLIT),
/* harmony export */   "_DYN_STRINGIFY_OBJECTS": () => (/* binding */ _DYN_STRINGIFY_OBJECTS),
/* harmony export */   "_DYN_SYNC": () => (/* binding */ _DYN_SYNC),
/* harmony export */   "_DYN_TIMEOUT": () => (/* binding */ _DYN_TIMEOUT),
/* harmony export */   "_DYN_TIMINGS": () => (/* binding */ _DYN_TIMINGS),
/* harmony export */   "_DYN_TO_LOWER_CASE": () => (/* binding */ _DYN_TO_LOWER_CASE),
/* harmony export */   "_DYN_UNLOAD_TRANSPORTS": () => (/* binding */ _DYN_UNLOAD_TRANSPORTS),
/* harmony export */   "_DYN_URL_STRING": () => (/* binding */ _DYN_URL_STRING),
/* harmony export */   "_DYN_USE_HDRS": () => (/* binding */ _DYN_USE_HDRS),
/* harmony export */   "_DYN_USE_SEND_BEACON": () => (/* binding */ _DYN_USE_SEND_BEACON),
/* harmony export */   "_DYN__BACK_OFF_TRANSMISSI12": () => (/* binding */ _DYN__BACK_OFF_TRANSMISSI12),
/* harmony export */   "_DYN__SEND_REASON": () => (/* binding */ _DYN__SEND_REASON),
/* harmony export */   "_DYN__THE_PAYLOAD": () => (/* binding */ _DYN__THE_PAYLOAD),
/* harmony export */   "_DYN__TRANSPORT": () => (/* binding */ _DYN__TRANSPORT)
/* harmony export */ });
/*
 * 1DS JS SDK POST plugin, 4.3.0
 * Copyright (c) Microsoft and contributors. All rights reserved.
 * (Microsoft Internal Only)
 */

// Licensed under the MIT License.
// @skip-file-minify
// ##############################################################
// AUTO GENERATED FILE: This file is Auto Generated during build.
// ##############################################################
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// Note: DON'T Export these const from the package as we are still targeting ES3 this will export a mutable variables that someone could change!!!
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
var _DYN_ALLOW_REQUEST_SENDIN0 = "allowRequestSending"; // Count: 3
var _DYN_FIRST_REQUEST_SENT = "firstRequestSent"; // Count: 2
var _DYN_SHOULD_ADD_CLOCK_SKE1 = "shouldAddClockSkewHeaders"; // Count: 2
var _DYN_GET_CLOCK_SKEW_HEADE2 = "getClockSkewHeaderValue"; // Count: 2
var _DYN_SET_CLOCK_SKEW = "setClockSkew"; // Count: 3
var _DYN_LENGTH = "length"; // Count: 38
var _DYN_CONCAT = "concat"; // Count: 7
var _DYN_I_KEY = "iKey"; // Count: 11
var _DYN_COUNT = "count"; // Count: 19
var _DYN_EVENTS = "events"; // Count: 8
var _DYN_PUSH = "push"; // Count: 15
var _DYN_SPLIT = "split"; // Count: 6
var _DYN_SPLICE = "splice"; // Count: 4
var _DYN_TO_LOWER_CASE = "toLowerCase"; // Count: 3
var _DYN_HDRS = "hdrs"; // Count: 7
var _DYN_USE_HDRS = "useHdrs"; // Count: 5
var _DYN_INITIALIZE = "initialize"; // Count: 5
var _DYN_SET_TIMEOUT_OVERRIDE = "setTimeoutOverride"; // Count: 3
var _DYN_CLEAR_TIMEOUT_OVERRI3 = "clearTimeoutOverride"; // Count: 3
var _DYN_PAYLOAD_PREPROCESSOR = "payloadPreprocessor"; // Count: 2
var _DYN_OVERRIDE_ENDPOINT_UR4 = "overrideEndpointUrl"; // Count: 3
var _DYN_AVOID_OPTIONS = "avoidOptions"; // Count: 3
var _DYN_DISABLE_EVENT_TIMING5 = "disableEventTimings"; // Count: 2
var _DYN_STRINGIFY_OBJECTS = "stringifyObjects"; // Count: 2
var _DYN_ENABLE_COMPOUND_KEY = "enableCompoundKey"; // Count: 4
var _DYN_DISABLE_XHR_SYNC = "disableXhrSync"; // Count: 6
var _DYN_DISABLE_FETCH_KEEP_A6 = "disableFetchKeepAlive"; // Count: 7
var _DYN_ADD_NO_RESPONSE = "addNoResponse"; // Count: 3
var _DYN_EXCLUDE_CS_META_DATA = "excludeCsMetaData"; // Count: 2
var _DYN_USE_SEND_BEACON = "useSendBeacon"; // Count: 3
var _DYN_ALWAYS_USE_XHR_OVERR7 = "alwaysUseXhrOverride"; // Count: 3
var _DYN_UNLOAD_TRANSPORTS = "unloadTransports"; // Count: 2
var _DYN_SERIALIZE_OFFLINE_EV8 = "serializeOfflineEvt"; // Count: 2
var _DYN_GET_OFFLINE_REQUEST_9 = "getOfflineRequestDetails"; // Count: 2
var _DYN_CREATE_PAYLOAD = "createPayload"; // Count: 4
var _DYN_CREATE_ONE_DSPAYLOAD = "createOneDSPayload"; // Count: 4
var _DYN_PAYLOAD_BLOB = "payloadBlob"; // Count: 3
var _DYN_HEADERS = "headers"; // Count: 12
var _DYN__THE_PAYLOAD = "_thePayload"; // Count: 6
var _DYN_URL_STRING = "urlString"; // Count: 5
var _DYN_BATCHES = "batches"; // Count: 15
var _DYN_SEND_TYPE = "sendType"; // Count: 13
var _DYN_ADD_HEADER = "addHeader"; // Count: 3
var _DYN_CAN_SEND_REQUEST = "canSendRequest"; // Count: 3
var _DYN_SEND_QUEUED_REQUESTS = "sendQueuedRequests"; // Count: 5
var _DYN_IS_COMPLETELY_IDLE = "isCompletelyIdle"; // Count: 2
var _DYN_SET_UNLOADING = "setUnloading"; // Count: 3
var _DYN_IS_TENANT_KILLED = "isTenantKilled"; // Count: 3
var _DYN_SEND_SYNCHRONOUS_BAT10 = "sendSynchronousBatch"; // Count: 2
var _DYN__TRANSPORT = "_transport"; // Count: 3
var _DYN_GET_WPARAM = "getWParam"; // Count: 4
var _DYN_IS_BEACON = "isBeacon"; // Count: 4
var _DYN_TIMINGS = "timings"; // Count: 4
var _DYN_IS_TEARDOWN = "isTeardown"; // Count: 3
var _DYN_IS_SYNC = "isSync"; // Count: 4
var _DYN_DATA = "data"; // Count: 7
var _DYN_TIMEOUT = "timeout"; // Count: 4
var _DYN__SEND_REASON = "_sendReason"; // Count: 4
var _DYN_SET_KILL_SWITCH_TENA11 = "setKillSwitchTenants"; // Count: 2
var _DYN__BACK_OFF_TRANSMISSI12 = "_backOffTransmission"; // Count: 2
var _DYN_IDENTIFIER = "identifier"; // Count: 4
var _DYN_DISABLE_OPTIMIZE_OBJ = "disableOptimizeObj"; // Count: 2
var _DYN_IGNORE_MC1_MS0_COOKI13 = "ignoreMc1Ms0CookieProcessing"; // Count: 2
var _DYN_EVENTS_LIMIT_IN_MEM = "eventsLimitInMem"; // Count: 2
var _DYN_AUTO_FLUSH_EVENTS_LI14 = "autoFlushEventsLimit"; // Count: 2
var _DYN_DISABLE_AUTO_BATCH_F15 = "disableAutoBatchFlushLimit"; // Count: 2
var _DYN_OVERRIDE_INSTRUMENTA16 = "overrideInstrumentationKey"; // Count: 2
var _DYN_DISABLE_TELEMETRY = "disableTelemetry"; // Count: 2
var _DYN_BASE_DATA = "baseData"; // Count: 3
var _DYN_SEND_ATTEMPT = "sendAttempt"; // Count: 4
var _DYN_LATENCY = "latency"; // Count: 7
var _DYN_SYNC = "sync"; // Count: 7
//# sourceMappingURL=__DynamicConstants.js.map

/***/ }),
/* 80 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createTimeoutWrapper": () => (/* binding */ createTimeoutWrapper)
/* harmony export */ });
/* harmony import */ var _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(30);
/*
 * 1DS JS SDK POST plugin, 4.3.0
 * Copyright (c) Microsoft and contributors. All rights reserved.
 * (Microsoft Internal Only)
 */
/**
* TimeoutOverrideWrapper.ts
* @author  Nev Wylie (newylie)
* @copyright Microsoft 2022
* Simple internal timeout wrapper
*/

function createTimeoutWrapper(argSetTimeout, argClearTimeout) {
    return {
        set: function (callback, ms) {
            var args = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                args[_i - 2] = arguments[_i];
            }
            return (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.scheduleTimeoutWith)([argSetTimeout, argClearTimeout], callback, ms, args);
        }
    };
}
//# sourceMappingURL=TimeoutOverrideWrapper.js.map

/***/ }),
/* 81 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DEFAULT_CACHE_CONTROL": () => (/* binding */ DEFAULT_CACHE_CONTROL),
/* harmony export */   "DEFAULT_CONTENT_TYPE": () => (/* binding */ DEFAULT_CONTENT_TYPE),
/* harmony export */   "STR_API_KEY": () => (/* binding */ STR_API_KEY),
/* harmony export */   "STR_AUTH_WEB_TOKEN": () => (/* binding */ STR_AUTH_WEB_TOKEN),
/* harmony export */   "STR_AUTH_XTOKEN": () => (/* binding */ STR_AUTH_XTOKEN),
/* harmony export */   "STR_CACHE_CONTROL": () => (/* binding */ STR_CACHE_CONTROL),
/* harmony export */   "STR_CLIENT_ID": () => (/* binding */ STR_CLIENT_ID),
/* harmony export */   "STR_CLIENT_VERSION": () => (/* binding */ STR_CLIENT_VERSION),
/* harmony export */   "STR_CONTENT_TYPE_HEADER": () => (/* binding */ STR_CONTENT_TYPE_HEADER),
/* harmony export */   "STR_DISABLED_PROPERTY_NAME": () => (/* binding */ STR_DISABLED_PROPERTY_NAME),
/* harmony export */   "STR_DROPPED": () => (/* binding */ STR_DROPPED),
/* harmony export */   "STR_EMPTY": () => (/* binding */ STR_EMPTY),
/* harmony export */   "STR_KILL_DURATION_HEADER": () => (/* binding */ STR_KILL_DURATION_HEADER),
/* harmony export */   "STR_KILL_DURATION_SECONDS_HEADER": () => (/* binding */ STR_KILL_DURATION_SECONDS_HEADER),
/* harmony export */   "STR_KILL_TOKENS_HEADER": () => (/* binding */ STR_KILL_TOKENS_HEADER),
/* harmony export */   "STR_MSA_DEVICE_TICKET": () => (/* binding */ STR_MSA_DEVICE_TICKET),
/* harmony export */   "STR_MSFPC": () => (/* binding */ STR_MSFPC),
/* harmony export */   "STR_NO_RESPONSE_BODY": () => (/* binding */ STR_NO_RESPONSE_BODY),
/* harmony export */   "STR_OTHER": () => (/* binding */ STR_OTHER),
/* harmony export */   "STR_POST_METHOD": () => (/* binding */ STR_POST_METHOD),
/* harmony export */   "STR_REQUEUE": () => (/* binding */ STR_REQUEUE),
/* harmony export */   "STR_RESPONSE_FAIL": () => (/* binding */ STR_RESPONSE_FAIL),
/* harmony export */   "STR_SDK_VERSION": () => (/* binding */ STR_SDK_VERSION),
/* harmony export */   "STR_SENDING": () => (/* binding */ STR_SENDING),
/* harmony export */   "STR_TIME_DELTA_HEADER": () => (/* binding */ STR_TIME_DELTA_HEADER),
/* harmony export */   "STR_TIME_DELTA_TO_APPLY": () => (/* binding */ STR_TIME_DELTA_TO_APPLY),
/* harmony export */   "STR_TRACE": () => (/* binding */ STR_TRACE),
/* harmony export */   "STR_UPLOAD_TIME": () => (/* binding */ STR_UPLOAD_TIME),
/* harmony export */   "STR_USER": () => (/* binding */ STR_USER)
/* harmony export */ });
/*
 * 1DS JS SDK POST plugin, 4.3.0
 * Copyright (c) Microsoft and contributors. All rights reserved.
 * (Microsoft Internal Only)
 */

// Licensed under the MIT License.
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// Note: DON'T Export these const from the package as we are still targeting ES3 this will export a mutable variables that someone could change!!!
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// Generally you should only put values that are used more than 2 times and then only if not already exposed as a constant (such as SdkCoreNames)
// as when using "short" named values from here they will be will be minified smaller than the SdkCoreNames[eSdkCoreNames.xxxx] value.
var STR_EMPTY = "";
var STR_POST_METHOD = "POST";
var STR_DISABLED_PROPERTY_NAME = "Microsoft_ApplicationInsights_BypassAjaxInstrumentation";
var STR_DROPPED = "drop";
var STR_SENDING = "send";
var STR_REQUEUE = "requeue";
var STR_RESPONSE_FAIL = "rspFail";
var STR_OTHER = "oth";
var DEFAULT_CACHE_CONTROL = "no-cache, no-store";
var DEFAULT_CONTENT_TYPE = "application/x-json-stream";
var STR_CACHE_CONTROL = "cache-control";
var STR_CONTENT_TYPE_HEADER = "content-type";
var STR_KILL_TOKENS_HEADER = "kill-tokens";
var STR_KILL_DURATION_HEADER = "kill-duration";
var STR_KILL_DURATION_SECONDS_HEADER = "kill-duration-seconds";
var STR_TIME_DELTA_HEADER = "time-delta-millis";
var STR_CLIENT_VERSION = "client-version";
var STR_CLIENT_ID = "client-id";
var STR_TIME_DELTA_TO_APPLY = "time-delta-to-apply-millis";
var STR_UPLOAD_TIME = "upload-time";
var STR_API_KEY = "apikey";
var STR_MSA_DEVICE_TICKET = "AuthMsaDeviceTicket";
var STR_AUTH_WEB_TOKEN = "WebAuthToken";
var STR_AUTH_XTOKEN = "AuthXToken";
var STR_SDK_VERSION = "sdk-version";
var STR_NO_RESPONSE_BODY = "NoResponseBody";
var STR_MSFPC = "msfpc";
var STR_TRACE = "trace";
var STR_USER = "user";
//# sourceMappingURL=InternalConstants.js.map

/***/ }),
/* 82 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EventBatch": () => (/* binding */ EventBatch)
/* harmony export */ });
/* harmony import */ var _microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(52);
/* harmony import */ var _microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(30);
/* harmony import */ var _InternalConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(81);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(79);
/*
 * 1DS JS SDK POST plugin, 4.3.0
 * Copyright (c) Microsoft and contributors. All rights reserved.
 * (Microsoft Internal Only)
 */
/**
* EventBatch.ts
* @author Nev Wylie (newylie)
* @copyright Microsoft 2020
*/



function _getEventMsfpc(theEvent) {
    var intWeb = ((theEvent.ext || {})["intweb"]);
    if (intWeb && (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_0__.isValueAssigned)(intWeb[_InternalConstants__WEBPACK_IMPORTED_MODULE_1__.STR_MSFPC])) {
        return intWeb[_InternalConstants__WEBPACK_IMPORTED_MODULE_1__.STR_MSFPC];
    }
    return null;
}
function _getMsfpc(theEvents) {
    var msfpc = null;
    for (var lp = 0; msfpc === null && lp < theEvents[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_LENGTH /* @min:%2elength */]; lp++) {
        msfpc = _getEventMsfpc(theEvents[lp]);
    }
    return msfpc;
}
/**
* This class defines a "batch" events related to a specific iKey, it is used by the PostChannel and HttpManager
* to collect and transfer ownership of events without duplicating them in-memory. This reduces the previous
* array duplication and shared ownership issues that occurred due to race conditions caused by the async nature
* of sending requests.
*/
var EventBatch = /** @class */ (function () {
    /**
     * Private constructor so that caller is forced to use the static create method.
     * @param iKey - The iKey to associate with the events (not validated)
     * @param addEvents - The optional collection of events to assign to this batch - defaults to an empty array.
     */
    function EventBatch(iKey, addEvents) {
        var events = addEvents ? [][_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_CONCAT /* @min:%2econcat */](addEvents) : [];
        var _self = this;
        var _msfpc = _getMsfpc(events);
        _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_I_KEY /* @min:%2eiKey */] = function () {
            return iKey;
        };
        _self.Msfpc = function () {
            // return the cached value unless it's undefined -- used to avoid cpu
            return _msfpc || _InternalConstants__WEBPACK_IMPORTED_MODULE_1__.STR_EMPTY;
        };
        _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_COUNT /* @min:%2ecount */] = function () {
            return events[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_LENGTH /* @min:%2elength */];
        };
        _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_EVENTS /* @min:%2eevents */] = function () {
            return events;
        };
        _self.addEvent = function (theEvent) {
            if (theEvent) {
                events[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_PUSH /* @min:%2epush */](theEvent);
                if (!_msfpc) {
                    // Not found so try and find one
                    _msfpc = _getEventMsfpc(theEvent);
                }
                return true;
            }
            return false;
        };
        _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_SPLIT /* @min:%2esplit */] = function (fromEvent, numEvents) {
            // Create a new batch with the same iKey
            var theEvents;
            if (fromEvent < events[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_LENGTH /* @min:%2elength */]) {
                var cnt = events[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_LENGTH /* @min:%2elength */] - fromEvent;
                if (!(0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_3__.isNullOrUndefined)(numEvents)) {
                    cnt = numEvents < cnt ? numEvents : cnt;
                }
                theEvents = events[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_SPLICE /* @min:%2esplice */](fromEvent, cnt);
                // reset the fetched msfpc value
                _msfpc = _getMsfpc(events);
            }
            return new EventBatch(iKey, theEvents);
        };
    }
    /**
     * Creates a new Event Batch object
     * @param iKey The iKey associated with this batch of events
     */
    EventBatch.create = function (iKey, theEvents) {
        return new EventBatch(iKey, theEvents);
    };
    return EventBatch;
}());

//# sourceMappingURL=EventBatch.js.map

/***/ }),
/* 83 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "HttpManager": () => (/* binding */ HttpManager)
/* harmony export */ });
/* harmony import */ var _microsoft_dynamicproto_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(35);
/* harmony import */ var _microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(30);
/* harmony import */ var _microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(40);
/* harmony import */ var _microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(52);
/* harmony import */ var _microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(44);
/* harmony import */ var _microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(74);
/* harmony import */ var _microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(45);
/* harmony import */ var _microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(50);
/* harmony import */ var _microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(37);
/* harmony import */ var _microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(34);
/* harmony import */ var _ClockSkewManager__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(86);
/* harmony import */ var _EventBatch__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(82);
/* harmony import */ var _InternalConstants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(81);
/* harmony import */ var _KillSwitch__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(85);
/* harmony import */ var _RetryPolicy__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(87);
/* harmony import */ var _Serializer__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(84);
/* harmony import */ var _TimeoutOverrideWrapper__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(80);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(79);
/*
 * 1DS JS SDK POST plugin, 4.3.0
 * Copyright (c) Microsoft and contributors. All rights reserved.
 * (Microsoft Internal Only)
 */
var _a;
/**
* HttpManager.ts
* @author Abhilash Panwar (abpanwar); Hector Hernandez (hectorh); Nev Wylie (newylie)
* @copyright Microsoft 2018-2020
*/











var strSendAttempt = "sendAttempt";
var _noResponseQs = "&" + _InternalConstants__WEBPACK_IMPORTED_MODULE_0__.STR_NO_RESPONSE_BODY + "=true";
var UrlQueryString = "?cors=true&" + _InternalConstants__WEBPACK_IMPORTED_MODULE_0__.STR_CONTENT_TYPE_HEADER[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_TO_LOWER_CASE /* @min:%2etoLowerCase */]() + "=" + _InternalConstants__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_CONTENT_TYPE;
/**
 * Identifies the default notification reason to the action names
 */
var _eventActionMap = (_a = {},
    _a[1 /* EventBatchNotificationReason.Paused */] = _InternalConstants__WEBPACK_IMPORTED_MODULE_0__.STR_REQUEUE,
    _a[100 /* EventBatchNotificationReason.RequeueEvents */] = _InternalConstants__WEBPACK_IMPORTED_MODULE_0__.STR_REQUEUE,
    _a[200 /* EventBatchNotificationReason.Complete */] = "sent",
    _a[8004 /* EventBatchNotificationReason.KillSwitch */] = _InternalConstants__WEBPACK_IMPORTED_MODULE_0__.STR_DROPPED,
    _a[8003 /* EventBatchNotificationReason.SizeLimitExceeded */] = _InternalConstants__WEBPACK_IMPORTED_MODULE_0__.STR_DROPPED,
    _a);
var _collectorQsHeaders = {};
var _collectorHeaderToQs = {};
function _addCollectorHeaderQsMapping(qsName, headerName, allowQs) {
    _collectorQsHeaders[qsName] = headerName;
    if (allowQs !== false) {
        _collectorHeaderToQs[headerName] = qsName;
    }
}
_addCollectorHeaderQsMapping(_InternalConstants__WEBPACK_IMPORTED_MODULE_0__.STR_MSA_DEVICE_TICKET, _InternalConstants__WEBPACK_IMPORTED_MODULE_0__.STR_MSA_DEVICE_TICKET, false);
_addCollectorHeaderQsMapping(_InternalConstants__WEBPACK_IMPORTED_MODULE_0__.STR_CLIENT_VERSION, _InternalConstants__WEBPACK_IMPORTED_MODULE_0__.STR_CLIENT_VERSION);
_addCollectorHeaderQsMapping(_InternalConstants__WEBPACK_IMPORTED_MODULE_0__.STR_CLIENT_ID, "Client-Id");
_addCollectorHeaderQsMapping(_InternalConstants__WEBPACK_IMPORTED_MODULE_0__.STR_API_KEY, _InternalConstants__WEBPACK_IMPORTED_MODULE_0__.STR_API_KEY);
_addCollectorHeaderQsMapping(_InternalConstants__WEBPACK_IMPORTED_MODULE_0__.STR_TIME_DELTA_TO_APPLY, _InternalConstants__WEBPACK_IMPORTED_MODULE_0__.STR_TIME_DELTA_TO_APPLY);
_addCollectorHeaderQsMapping(_InternalConstants__WEBPACK_IMPORTED_MODULE_0__.STR_UPLOAD_TIME, _InternalConstants__WEBPACK_IMPORTED_MODULE_0__.STR_UPLOAD_TIME);
_addCollectorHeaderQsMapping(_InternalConstants__WEBPACK_IMPORTED_MODULE_0__.STR_AUTH_XTOKEN, _InternalConstants__WEBPACK_IMPORTED_MODULE_0__.STR_AUTH_XTOKEN);
function _hasHeader(headers, header) {
    var hasHeader = false;
    if (headers && header) {
        var keys = (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_2__.objKeys)(headers);
        if (keys && keys[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LENGTH /* @min:%2elength */] > 0) {
            var lowerHeader = header[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_TO_LOWER_CASE /* @min:%2etoLowerCase */]();
            for (var lp = 0; lp < keys[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LENGTH /* @min:%2elength */]; lp++) {
                var value = keys[lp];
                if (value && (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_2__.objHasOwnProperty)(header, value) &&
                    value[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_TO_LOWER_CASE /* @min:%2etoLowerCase */]() === lowerHeader) {
                    hasHeader = true;
                    break;
                }
            }
        }
    }
    return hasHeader;
}
function _addRequestDetails(details, name, value, useHeaders) {
    if (name && value && value[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LENGTH /* @min:%2elength */] > 0) {
        if (useHeaders && _collectorQsHeaders[name]) {
            details[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_HDRS /* @min:%2ehdrs */][_collectorQsHeaders[name]] = value;
            details[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_USE_HDRS /* @min:%2euseHdrs */] = true;
        }
        else {
            details.url += "&" + name + "=" + value;
        }
    }
}
function _addQueryStringParameter(qsParams, name, value) {
    for (var i = 0; i < qsParams[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LENGTH /* @min:%2elength */]; i++) {
        if (qsParams[i].name === name) {
            qsParams[i].value = value;
            return;
        }
    }
    qsParams[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_PUSH /* @min:%2epush */]({ name: name, value: value });
}
function _removeQueryStringParameter(qsParams, name) {
    for (var i = 0; i < qsParams[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LENGTH /* @min:%2elength */]; i++) {
        if (qsParams[i].name === name) {
            qsParams[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_SPLICE /* @min:%2esplice */](i, 1);
            return;
        }
    }
}
/**
 * Class managing the sending of requests.
 */
var HttpManager = /** @class */ (function () {
    /**
     * @constructor
     * @param requestQueue   - The queue that contains the requests to be sent.
     */
    function HttpManager(maxEventsPerBatch, maxConnections, maxRequestRetriesBeforeBackoff, actions) {
        // ------------------------------------------------------------------------------------------------------------------------
        // Only set "Default" values in the _initDefaults() method, unless value are not "reset" during unloading
        // ------------------------------------------------------------------------------------------------------------------------
        var _urlString;
        var _killSwitch;
        var _paused;
        var _clockSkewManager;
        var _useBeacons = false;
        var _outstandingRequests; // Holds the number of outstanding async requests that have not returned a response yet
        var _postManager;
        var _logger;
        var _sendInterfaces;
        var _core;
        var _customHttpInterface;
        var _queryStringParameters;
        var _headers;
        var _batchQueue;
        var _serializer;
        var _enableEventTimings;
        var _cookieMgr;
        var _isUnloading;
        var _useHeaders;
        var _xhrTimeout;
        var _disableXhrSync;
        var _disableFetchKeepAlive;
        var _canHaveReducedPayload;
        var _addNoResponse;
        var _unloadHooks;
        var _sendHook;
        var _sendListener;
        var _responseHandlers;
        var _isInitialized;
        var _timeoutWrapper;
        var _excludeCsMetaData;
        var _sendPostMgr;
        (0,_microsoft_dynamicproto_js__WEBPACK_IMPORTED_MODULE_3__["default"])(HttpManager, this, function (_self) {
            _initDefaults();
            var _sendCredentials = true;
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_INITIALIZE /* @min:%2einitialize */] = function (theConfig, core, postChannel) {
                if (!_isInitialized) {
                    _core = core;
                    _cookieMgr = core.getCookieMgr();
                    _postManager = postChannel;
                    _logger = _postManager.diagLog();
                    (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_2__.arrAppend)(_unloadHooks, (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_4__.onConfigChange)(theConfig, function (details) {
                        var _a;
                        var coreConfig = details.cfg;
                        var channelConfig = details.cfg.extensionConfig[postChannel.identifier];
                        _timeoutWrapper = (0,_TimeoutOverrideWrapper__WEBPACK_IMPORTED_MODULE_5__.createTimeoutWrapper)(channelConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_SET_TIMEOUT_OVERRIDE /* @min:%2esetTimeoutOverride */], channelConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_CLEAR_TIMEOUT_OVERRI3 /* @min:%2eclearTimeoutOverride */]);
                        if ((0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_6__.isValueAssigned)(coreConfig.anonCookieName)) {
                            _addQueryStringParameter(_queryStringParameters, "anoncknm", coreConfig.anonCookieName);
                        }
                        else {
                            _removeQueryStringParameter(_queryStringParameters, "anoncknm");
                        }
                        _sendHook = channelConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_PAYLOAD_PREPROCESSOR /* @min:%2epayloadPreprocessor */];
                        _sendListener = channelConfig.payloadListener;
                        var httpInterface = channelConfig.httpXHROverride;
                        // Override endpointUrl if provided in Post config
                        var endpointUrl = channelConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_OVERRIDE_ENDPOINT_UR4 /* @min:%2eoverrideEndpointUrl */] ? channelConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_OVERRIDE_ENDPOINT_UR4 /* @min:%2eoverrideEndpointUrl */] : coreConfig.endpointUrl;
                        _urlString = endpointUrl + UrlQueryString;
                        _useHeaders = !(0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_2__.isUndefined)(channelConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_AVOID_OPTIONS /* @min:%2eavoidOptions */]) ? !channelConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_AVOID_OPTIONS /* @min:%2eavoidOptions */] : true;
                        _enableEventTimings = !channelConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_DISABLE_EVENT_TIMING5 /* @min:%2edisableEventTimings */];
                        var valueSanitizer = channelConfig.valueSanitizer;
                        var stringifyObjects = channelConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_STRINGIFY_OBJECTS /* @min:%2estringifyObjects */];
                        var enableCompoundKey = !!coreConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_ENABLE_COMPOUND_KEY /* @min:%2eenableCompoundKey */];
                        if (!(0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_2__.isUndefined)(channelConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_ENABLE_COMPOUND_KEY /* @min:%2eenableCompoundKey */])) {
                            enableCompoundKey = !!channelConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_ENABLE_COMPOUND_KEY /* @min:%2eenableCompoundKey */];
                        }
                        _xhrTimeout = channelConfig.xhrTimeout;
                        _disableXhrSync = !!channelConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_DISABLE_XHR_SYNC /* @min:%2edisableXhrSync */];
                        _disableFetchKeepAlive = !!channelConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_DISABLE_FETCH_KEEP_A6 /* @min:%2edisableFetchKeepAlive */];
                        _addNoResponse = channelConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_ADD_NO_RESPONSE /* @min:%2eaddNoResponse */] !== false;
                        _excludeCsMetaData = !!channelConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_EXCLUDE_CS_META_DATA /* @min:%2eexcludeCsMetaData */];
                        if (!!core.getPlugin("LocalStorage")) {
                            // Always disable fetch keep alive when persisten storage is available
                            _disableFetchKeepAlive = true;
                        }
                        _useBeacons = !(0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_7__.isReactNative)(); // Only use beacons if not running in React Native
                        _serializer = new _Serializer__WEBPACK_IMPORTED_MODULE_8__.Serializer(_core, valueSanitizer, stringifyObjects, enableCompoundKey, _microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_6__.getCommonSchemaMetaData, _excludeCsMetaData);
                        if (!(0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_2__.isNullOrUndefined)(channelConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_USE_SEND_BEACON /* @min:%2euseSendBeacon */])) {
                            _useBeacons = !!channelConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_USE_SEND_BEACON /* @min:%2euseSendBeacon */];
                        }
                        var sendPostConfig = _getSendPostMgrConfig();
                        // only init it once
                        if (!_sendPostMgr) {
                            _sendPostMgr = new _microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_9__.SenderPostManager();
                            _sendPostMgr[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_INITIALIZE /* @min:%2einitialize */](sendPostConfig, _logger);
                        }
                        else {
                            _sendPostMgr.SetConfig(sendPostConfig);
                        }
                        var syncHttpInterface = httpInterface;
                        var beaconHttpInterface = channelConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_ALWAYS_USE_XHR_OVERR7 /* @min:%2ealwaysUseXhrOverride */] ? httpInterface : null;
                        var fetchSyncHttpInterface = channelConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_ALWAYS_USE_XHR_OVERR7 /* @min:%2ealwaysUseXhrOverride */] ? httpInterface : null;
                        var beaconUnloadTransports = [3 /* TransportType.Beacon */, 2 /* TransportType.Fetch */];
                        if (!httpInterface) {
                            _customHttpInterface = false;
                            // this is handled in SendPostManager now
                            // let location = getLocation();
                            // if (location && location.protocol && location.protocol.toLowerCase() === "file:") {
                            //     // Special case where a local html file fails with a CORS error on Chromium browsers
                            //     _sendCredentials = false;
                            // }
                            var theTransports = [];
                            if ((0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_7__.isReactNative)()) {
                                // Use Fetch or XDR/XHR
                                theTransports = [2 /* TransportType.Fetch */, 1 /* TransportType.Xhr */];
                                beaconUnloadTransports = [2 /* TransportType.Fetch */, 1 /* TransportType.Xhr */, 3 /* TransportType.Beacon */];
                            }
                            else {
                                // Use XDR/XHR, Fetch or beacons
                                theTransports = [1 /* TransportType.Xhr */, 2 /* TransportType.Fetch */, 3 /* TransportType.Beacon */];
                            }
                            // Prefix any user requested transport(s) values
                            theTransports = (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_10__.prependTransports)(theTransports, channelConfig.transports);
                            httpInterface = _getSenderInterface(theTransports, false);
                            if (!httpInterface) {
                                (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_11__._warnToConsole)(_logger, "No available transport to send events");
                            }
                            syncHttpInterface = _getSenderInterface(theTransports, true);
                        }
                        if (!beaconHttpInterface) {
                            // Allow overriding the usage of sendBeacon
                            beaconUnloadTransports = (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_10__.prependTransports)(beaconUnloadTransports, channelConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_UNLOAD_TRANSPORTS /* @min:%2eunloadTransports */]);
                            beaconHttpInterface = _getSenderInterface(beaconUnloadTransports, true);
                        }
                        _canHaveReducedPayload = !_customHttpInterface && ((_useBeacons && (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_7__.isBeaconsSupported)()) || (!_disableFetchKeepAlive && (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_7__.isFetchSupported)(true)));
                        _sendInterfaces = (_a = {},
                            _a[0 /* EventSendType.Batched */] = httpInterface,
                            _a[1 /* EventSendType.Synchronous */] = syncHttpInterface || _getSenderInterface([1 /* TransportType.Xhr */, 2 /* TransportType.Fetch */, 3 /* TransportType.Beacon */], true),
                            _a[2 /* EventSendType.SendBeacon */] = beaconHttpInterface || syncHttpInterface || _getSenderInterface([1 /* TransportType.Xhr */], true),
                            _a[3 /* EventSendType.SyncFetch */] = fetchSyncHttpInterface || _getSenderInterface([2 /* TransportType.Fetch */, 3 /* TransportType.Beacon */], true) || syncHttpInterface || _getSenderInterface([1 /* TransportType.Xhr */], true),
                            _a);
                    }));
                    _isInitialized = true;
                }
            };
            _self.addResponseHandler = function (responseHandler) {
                _responseHandlers[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_PUSH /* @min:%2epush */](responseHandler);
                return {
                    rm: function () {
                        var index = _responseHandlers.indexOf(responseHandler);
                        if (index >= 0) {
                            _responseHandlers[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_SPLICE /* @min:%2esplice */](index, 1);
                        }
                    }
                };
            };
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_SERIALIZE_OFFLINE_EV8 /* @min:%2eserializeOfflineEvt */] = function (evt) {
                try {
                    if (_serializer) {
                        return _serializer.getEventBlob(evt);
                    }
                }
                catch (e) {
                    // eslint-disable-next-line no-empty
                }
                return _InternalConstants__WEBPACK_IMPORTED_MODULE_0__.STR_EMPTY;
            };
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_GET_OFFLINE_REQUEST_9 /* @min:%2egetOfflineRequestDetails */] = function () {
                try {
                    // get current url without paramter
                    var payload = _serializer && _serializer[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_CREATE_PAYLOAD /* @min:%2ecreatePayload */](0, false, false, false, 1 /* SendRequestReason.NormalSchedule */, 0 /* EventSendType.Batched */);
                    return _buildRequestDetails(payload, _useHeaders);
                }
                catch (e) {
                    // eslint-disable-next-line no-empty
                }
                return null;
            };
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_CREATE_ONE_DSPAYLOAD /* @min:%2ecreateOneDSPayload */] = function (evts, optimize) {
                try {
                    // TODO: optimize
                    var theBatches_1 = [];
                    // create a eventBatch for each event
                    (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_2__.arrForEach)(evts, function (evt) {
                        if (optimize) {
                            evt = (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_10__.optimizeObject)(evt);
                        }
                        var batch = _EventBatch__WEBPACK_IMPORTED_MODULE_12__.EventBatch.create(evt[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_I_KEY /* @min:%2eiKey */], [evt]);
                        theBatches_1[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_PUSH /* @min:%2epush */](batch);
                    });
                    var thePayload = null;
                    while (theBatches_1[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LENGTH /* @min:%2elength */] > 0 && _serializer) {
                        var theBatch = theBatches_1.shift();
                        if (theBatch && theBatch[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_COUNT /* @min:%2ecount */]() > 0) {
                            thePayload = thePayload || _serializer[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_CREATE_PAYLOAD /* @min:%2ecreatePayload */](0, false, false, false, 1 /* SendRequestReason.NormalSchedule */, 0 /* EventSendType.Batched */);
                            _serializer.appendPayload(thePayload, theBatch, maxEventsPerBatch);
                        }
                    }
                    var requestDetails = _buildRequestDetails(thePayload, _useHeaders);
                    var payloadData = {
                        data: thePayload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_PAYLOAD_BLOB /* @min:%2epayloadBlob */],
                        urlString: requestDetails.url,
                        headers: requestDetails[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_HDRS /* @min:%2ehdrs */],
                        timeout: _xhrTimeout,
                        disableXhrSync: _disableXhrSync,
                        disableFetchKeepAlive: _disableFetchKeepAlive
                    };
                    // Only automatically add the following headers if already sending headers and we are not attempting to avoid an options call
                    if (_useHeaders) {
                        if (!_hasHeader(payloadData[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_HEADERS /* @min:%2eheaders */], _InternalConstants__WEBPACK_IMPORTED_MODULE_0__.STR_CACHE_CONTROL)) {
                            payloadData[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_HEADERS /* @min:%2eheaders */][_InternalConstants__WEBPACK_IMPORTED_MODULE_0__.STR_CACHE_CONTROL] = _InternalConstants__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_CACHE_CONTROL;
                        }
                        if (!_hasHeader(payloadData[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_HEADERS /* @min:%2eheaders */], _InternalConstants__WEBPACK_IMPORTED_MODULE_0__.STR_CONTENT_TYPE_HEADER)) {
                            payloadData[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_HEADERS /* @min:%2eheaders */][_InternalConstants__WEBPACK_IMPORTED_MODULE_0__.STR_CONTENT_TYPE_HEADER] = _InternalConstants__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_CONTENT_TYPE;
                        }
                    }
                    return payloadData;
                }
                catch (e) {
                    // eslint-disable-next-line no-empty
                }
                return null;
            };
            // Special internal method to allow the DebugPlugin to hook embedded objects
            function _getSenderInterface(transports, syncSupport) {
                try {
                    return _sendPostMgr && _sendPostMgr.getSenderInst(transports, syncSupport);
                }
                catch (e) {
                    // eslint-disable-next-line no-empty
                }
                return null;
            }
            _self["_getDbgPlgTargets"] = function () {
                return [_sendInterfaces[0 /* EventSendType.Batched */], _killSwitch, _serializer, _sendInterfaces];
            };
            function _getSendPostMgrConfig() {
                try {
                    var onCompleteFuncs = {
                        xdrOnComplete: _xdrOncomplete,
                        fetchOnComplete: _fetchOnComplete,
                        xhrOnComplete: _xhrOnComplete,
                        beaconOnRetry: _onBeaconRetry
                    };
                    var config = {
                        enableSendPromise: false,
                        isOneDs: true,
                        disableCredentials: !_sendCredentials,
                        disableXhr: false,
                        disableBeacon: !_useBeacons,
                        disableBeaconSync: !_useBeacons,
                        disableFetchKeepAlive: _disableFetchKeepAlive,
                        timeWrapper: _timeoutWrapper,
                        addNoResponse: _addNoResponse,
                        senderOnCompleteCallBack: onCompleteFuncs
                    };
                    return config;
                }
                catch (e) {
                    // eslint-disable-next-line no-empty
                }
                return null;
            }
            function _xdrOncomplete(xdr, oncomplete, payload) {
                var response = (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_10__.getResponseText)(xdr);
                _doOnComplete(oncomplete, 200, {}, response);
                _handleCollectorResponse(response);
            }
            function _initDefaults() {
                var undefValue;
                _urlString = null;
                _killSwitch = new _KillSwitch__WEBPACK_IMPORTED_MODULE_13__.KillSwitch();
                _paused = false;
                _clockSkewManager = new _ClockSkewManager__WEBPACK_IMPORTED_MODULE_14__.ClockSkewManager();
                _useBeacons = false;
                _outstandingRequests = 0; // Holds the number of outstanding async requests that have not returned a response yet
                _postManager = null;
                _logger = null;
                _sendInterfaces = null;
                _core = null;
                _customHttpInterface = true;
                _queryStringParameters = [];
                _headers = {};
                _batchQueue = [];
                _serializer = null;
                _enableEventTimings = false;
                _cookieMgr = null;
                _isUnloading = false;
                _useHeaders = false;
                _xhrTimeout = undefValue;
                _disableXhrSync = undefValue;
                _disableFetchKeepAlive = undefValue;
                _canHaveReducedPayload = undefValue;
                _addNoResponse = undefValue;
                _unloadHooks = [];
                _sendHook = undefValue;
                _sendListener = undefValue;
                _responseHandlers = [];
                _isInitialized = false;
                _timeoutWrapper = (0,_TimeoutOverrideWrapper__WEBPACK_IMPORTED_MODULE_5__.createTimeoutWrapper)();
                _excludeCsMetaData = false;
                _sendPostMgr = null;
            }
            function _fetchOnComplete(response, onComplete, resValue, payload) {
                var handleResponse = function (status, headerMap, responseText) {
                    _doOnComplete(onComplete, status, headerMap, responseText);
                    _handleCollectorResponse(responseText);
                };
                var headerMap = {};
                var headers = response[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_HEADERS /* @min:%2eheaders */];
                if (headers) {
                    headers["forEach"](function (value, name) {
                        headerMap[name] = value;
                    });
                }
                handleResponse(response.status, headerMap, resValue || _InternalConstants__WEBPACK_IMPORTED_MODULE_0__.STR_EMPTY);
            }
            function _xhrOnComplete(request, oncomplete, payload) {
                var response = (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_10__.getResponseText)(request);
                _doOnComplete(oncomplete, request.status, (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_10__._getAllResponseHeaders)(request, true), response);
                _handleCollectorResponse(response);
            }
            function _doOnComplete(oncomplete, status, headers, response) {
                try {
                    oncomplete(status, headers, response);
                }
                catch (e) {
                    (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_11__._throwInternal)(_logger, 2 /* eLoggingSeverity.WARNING */, 518 /* _eExtendedInternalMessageId.SendPostOnCompleteFailure */, (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_2__.dumpObj)(e));
                }
            }
            function _onBeaconRetry(payload, onComplete, canSend) {
                // Custom headers not supported in sendBeacon payload.headers would be ignored
                var internalPayloadData = payload;
                var status = 200;
                var thePayload = internalPayloadData[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN__THE_PAYLOAD /* @min:%2e_thePayload */];
                var theUrl = payload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_URL_STRING /* @min:%2eurlString */] + (_addNoResponse ? _noResponseQs : _InternalConstants__WEBPACK_IMPORTED_MODULE_0__.STR_EMPTY);
                try {
                    var nav_1 = (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_2__.getNavigator)();
                    if (thePayload) {
                        var persistStorage = !!_core.getPlugin("LocalStorage");
                        // Failed to send entire payload so try and split data and try to send as much events as possible
                        var droppedBatches_1 = [];
                        var sentBatches_1 = [];
                        (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_2__.arrForEach)(thePayload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_BATCHES /* @min:%2ebatches */], function (theBatch) {
                            if (droppedBatches_1 && theBatch && theBatch[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_COUNT /* @min:%2ecount */]() > 0) {
                                var theEvents = theBatch[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_EVENTS /* @min:%2eevents */]();
                                for (var lp = 0; lp < theEvents[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LENGTH /* @min:%2elength */]; lp++) {
                                    if (!nav_1.sendBeacon(theUrl, _serializer.getEventBlob(theEvents[lp]))) {
                                        // Can't send anymore, so split the batch and drop the rest
                                        droppedBatches_1[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_PUSH /* @min:%2epush */](theBatch[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_SPLIT /* @min:%2esplit */](lp));
                                        break;
                                    }
                                    else {
                                        sentBatches_1[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_PUSH /* @min:%2epush */](theBatch[lp]);
                                    }
                                }
                            }
                            else {
                                // Remove all of the events from the existing batch in the payload as the copy includes the original
                                droppedBatches_1[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_PUSH /* @min:%2epush */](theBatch[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_SPLIT /* @min:%2esplit */](0));
                            }
                        });
                        if (sentBatches_1[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LENGTH /* @min:%2elength */] > 0) {
                            // Update the payload with the sent batches
                            thePayload.sentEvts = sentBatches_1;
                        }
                        if (!persistStorage) {
                            _sendBatchesNotification(droppedBatches_1, 8003 /* EventBatchNotificationReason.SizeLimitExceeded */, thePayload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_SEND_TYPE /* @min:%2esendType */], true);
                        }
                    }
                    else {
                        status = 0;
                    }
                }
                catch (ex) {
                    (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_11__._warnToConsole)(_logger, "Failed to send telemetry using sendBeacon API. Ex:" + (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_2__.dumpObj)(ex));
                    status = 0;
                }
                finally {
                    _doOnComplete(onComplete, status, {}, _InternalConstants__WEBPACK_IMPORTED_MODULE_0__.STR_EMPTY);
                }
            }
            function _isBeaconPayload(sendType) {
                // Sync Fetch has the same payload limitation as sendBeacon -- 64kb limit, so treat both as a beacon send
                return sendType === 2 /* EventSendType.SendBeacon */ || sendType === 3 /* EventSendType.SyncFetch */;
            }
            function _adjustSendType(sendType) {
                if (_isUnloading && _isBeaconPayload(sendType)) {
                    sendType = 2 /* EventSendType.SendBeacon */;
                }
                return sendType;
            }
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_ADD_HEADER /* @min:%2eaddHeader */] = function (name, value) {
                _headers[name] = value;
            };
            _self.removeHeader = function (name) {
                delete _headers[name];
            };
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_CAN_SEND_REQUEST /* @min:%2ecanSendRequest */] = function () {
                return _hasIdleConnection() && _clockSkewManager[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_ALLOW_REQUEST_SENDIN0 /* @min:%2eallowRequestSending */]();
            };
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_SEND_QUEUED_REQUESTS /* @min:%2esendQueuedRequests */] = function (sendType, sendReason) {
                if ((0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_2__.isUndefined)(sendType)) {
                    sendType = 0 /* EventSendType.Batched */;
                }
                if (_isUnloading) {
                    sendType = _adjustSendType(sendType);
                    sendReason = 2 /* SendRequestReason.Unload */;
                }
                if (_canSendPayload(_batchQueue, sendType, 0)) {
                    _sendBatches(_clearQueue(), 0, false, sendType, sendReason || 0 /* SendRequestReason.Undefined */);
                }
            };
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_IS_COMPLETELY_IDLE /* @min:%2eisCompletelyIdle */] = function () {
                return !_paused && _outstandingRequests === 0 && _batchQueue[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LENGTH /* @min:%2elength */] === 0;
            };
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_SET_UNLOADING /* @min:%2esetUnloading */] = function (value) {
                _isUnloading = value;
            };
            _self.addBatch = function (theBatch) {
                if (theBatch && theBatch[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_COUNT /* @min:%2ecount */]() > 0) {
                    // Try and kill the event faster
                    if (_killSwitch.isTenantKilled(theBatch[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_I_KEY /* @min:%2eiKey */]())) {
                        return false;
                    }
                    _batchQueue[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_PUSH /* @min:%2epush */](theBatch);
                }
                return true;
            };
            /**
             * Queue all the remaining requests to be sent. The requests will be
             * sent using HTML5 Beacons if they are available.
             */
            _self.teardown = function () {
                if (_batchQueue[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LENGTH /* @min:%2elength */] > 0) {
                    _sendBatches(_clearQueue(), 0, true, 2 /* EventSendType.SendBeacon */, 2 /* SendRequestReason.Unload */);
                }
                (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_2__.arrForEach)(_unloadHooks, function (hook) {
                    hook && hook.rm && hook.rm();
                });
                _unloadHooks = [];
            };
            /**
             * Pause the sending of requests. No new requests will be sent.
             */
            _self.pause = function () {
                _paused = true;
            };
            /**
             * Resume the sending of requests.
             */
            _self.resume = function () {
                _paused = false;
                _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_SEND_QUEUED_REQUESTS /* @min:%2esendQueuedRequests */](0 /* EventSendType.Batched */, 4 /* SendRequestReason.Resumed */);
            };
            /**
             * Sends a request synchronously to the Aria collector. This api is used to send
             * a request containing a single immediate event.
             *
             * @param batch - The request to be sent.
             * @param sendReason   - The token used to send the request.
             */
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_SEND_SYNCHRONOUS_BAT10 /* @min:%2esendSynchronousBatch */] = function (batch, sendType, sendReason) {
                // This will not take into account the max connections restriction. Since this is sync, we can
                // only send one of this request at a time and thus should not worry about multiple connections
                // being used to send synchronous events.
                // Increment active connection since we are still going to use a connection to send the request.
                if (batch && batch[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_COUNT /* @min:%2ecount */]() > 0) {
                    if ((0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_2__.isNullOrUndefined)(sendType)) {
                        sendType = 1 /* EventSendType.Synchronous */;
                    }
                    if (_isUnloading) {
                        sendType = _adjustSendType(sendType);
                        sendReason = 2 /* SendRequestReason.Unload */;
                    }
                    // For sync requests we will not wait for the clock skew.
                    _sendBatches([batch], 0, false, sendType, sendReason || 0 /* SendRequestReason.Undefined */);
                }
            };
            function _hasIdleConnection() {
                return !_paused && _outstandingRequests < maxConnections;
            }
            function _clearQueue() {
                var theQueue = _batchQueue;
                _batchQueue = [];
                return theQueue;
            }
            function _canSendPayload(theBatches, sendType, retryCnt) {
                var result = false;
                if (theBatches && theBatches[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LENGTH /* @min:%2elength */] > 0 && !_paused && _sendInterfaces[sendType] && _serializer) {
                    // Always attempt to send synchronous events don't wait for idle or clockSkew
                    // and don't block retry requests if clockSkew is not yet set
                    result = (sendType !== 0 /* EventSendType.Batched */) || (_hasIdleConnection() && (retryCnt > 0 || _clockSkewManager[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_ALLOW_REQUEST_SENDIN0 /* @min:%2eallowRequestSending */]()));
                }
                return result;
            }
            function _createDebugBatches(theBatches) {
                var values = {};
                if (theBatches) {
                    (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_2__.arrForEach)(theBatches, function (theBatch, idx) {
                        values[idx] = {
                            iKey: theBatch[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_I_KEY /* @min:%2eiKey */](),
                            evts: theBatch[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_EVENTS /* @min:%2eevents */]()
                        };
                    });
                }
                return values;
            }
            function _sendBatches(theBatches, retryCount, isTeardown, sendType, sendReason) {
                if (!theBatches || theBatches[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LENGTH /* @min:%2elength */] === 0) {
                    // Nothing to do
                    return;
                }
                if (_paused) {
                    _sendBatchesNotification(theBatches, 1 /* EventBatchNotificationReason.Paused */, sendType);
                    return;
                }
                // Make sure that if we are unloading the sendType is a supported version
                sendType = _adjustSendType(sendType);
                try {
                    var orgBatches_1 = theBatches;
                    var isSynchronous_1 = sendType !== 0 /* EventSendType.Batched */;
                    (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_15__.doPerf)(_core, function () { return "HttpManager:_sendBatches"; }, function (perfEvt) {
                        if (perfEvt) {
                            // Perf Monitoring is enabled, so create a "Quick" copy of the original batches so we still report
                            // the original values as part of the perfEvent. This is because theBatches uses .shift() to remove each
                            // batch as they are processed - removing from the original array, so by the time the _createDebugBatches()
                            // function is called the passed in value has changed and therefore the reported value for the perfEvent is incorrect
                            theBatches = theBatches.slice(0);
                        }
                        var droppedBatches = [];
                        var thePayload = null;
                        var serializationStart = (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_6__.getTime)();
                        var sendInterface = _sendInterfaces[sendType] || (isSynchronous_1 ? _sendInterfaces[1 /* EventSendType.Synchronous */] : _sendInterfaces[0 /* EventSendType.Batched */]);
                        var sendTransport = sendInterface && sendInterface[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN__TRANSPORT /* @min:%2e_transport */];
                        // Sync Fetch has the same payload limitation as sendBeacon -- 64kb limit
                        var isReducedPayload = _canHaveReducedPayload && (_isUnloading || _isBeaconPayload(sendType) || (sendTransport === 3 /* TransportType.Beacon */ || (sendInterface._isSync && sendTransport === 2 /* TransportType.Fetch */)));
                        while (_canSendPayload(theBatches, sendType, retryCount)) {
                            var theBatch = theBatches.shift();
                            if (theBatch && theBatch[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_COUNT /* @min:%2ecount */]() > 0) {
                                if (!_killSwitch.isTenantKilled(theBatch[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_I_KEY /* @min:%2eiKey */]())) {
                                    // Make sure we have a payload object
                                    thePayload = thePayload || _serializer[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_CREATE_PAYLOAD /* @min:%2ecreatePayload */](retryCount, isTeardown, isSynchronous_1, isReducedPayload, sendReason, sendType);
                                    // Add the batch to the current payload
                                    if (!_serializer.appendPayload(thePayload, theBatch, maxEventsPerBatch)) {
                                        // Entire batch was not added so send the payload and retry adding this batch
                                        _doPayloadSend(thePayload, serializationStart, (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_6__.getTime)(), sendReason);
                                        serializationStart = (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_6__.getTime)();
                                        theBatches = [theBatch][_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_CONCAT /* @min:%2econcat */](theBatches);
                                        thePayload = null;
                                    }
                                    else if (thePayload.overflow !== null) {
                                        // Total Payload size was exceeded so send the payload and add the unsent as the next batch to send
                                        theBatches = [thePayload.overflow][_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_CONCAT /* @min:%2econcat */](theBatches);
                                        thePayload.overflow = null;
                                        _doPayloadSend(thePayload, serializationStart, (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_6__.getTime)(), sendReason);
                                        serializationStart = (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_6__.getTime)();
                                        thePayload = null;
                                    }
                                }
                                else {
                                    droppedBatches[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_PUSH /* @min:%2epush */](theBatch);
                                }
                            }
                        }
                        // Make sure to flush any remaining payload
                        if (thePayload) {
                            _doPayloadSend(thePayload, serializationStart, (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_6__.getTime)(), sendReason);
                        }
                        if (theBatches[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LENGTH /* @min:%2elength */] > 0) {
                            // Add any unsent batches back to the head of the queue
                            _batchQueue = theBatches[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_CONCAT /* @min:%2econcat */](_batchQueue);
                        }
                        // Now send notification about any dropped events
                        _sendBatchesNotification(droppedBatches, 8004 /* EventBatchNotificationReason.KillSwitch */, sendType);
                    }, function () { return ({ batches: _createDebugBatches(orgBatches_1), retryCount: retryCount, isTeardown: isTeardown, isSynchronous: isSynchronous_1, sendReason: sendReason, useSendBeacon: _isBeaconPayload(sendType), sendType: sendType }); }, !isSynchronous_1);
                }
                catch (ex) {
                    (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_11__._throwInternal)(_logger, 2 /* eLoggingSeverity.WARNING */, 48 /* _eInternalMessageId.CannotSerializeObject */, "Unexpected Exception sending batch: " + (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_2__.dumpObj)(ex));
                }
            }
            function _buildRequestDetails(thePayload, useHeaders) {
                var requestDetails = {
                    url: _urlString,
                    hdrs: {},
                    useHdrs: false // Assume no headers
                };
                if (!useHeaders) {
                    // Attempt to map headers to a query string if possible
                    (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_2__.objForEachKey)(_headers, function (name, value) {
                        if (_collectorHeaderToQs[name]) {
                            _addRequestDetails(requestDetails, _collectorHeaderToQs[name], value, false);
                        }
                        else {
                            // No mapping, so just include in the headers anyway (may not get sent if using sendBeacon())
                            requestDetails[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_HDRS /* @min:%2ehdrs */][name] = value;
                            requestDetails[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_USE_HDRS /* @min:%2euseHdrs */] = true;
                        }
                    });
                }
                else {
                    // Copy the pre-defined headers into the payload headers
                    requestDetails[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_HDRS /* @min:%2ehdrs */] = (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_6__.extend)(requestDetails[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_HDRS /* @min:%2ehdrs */], _headers);
                    requestDetails.useHdrs = ((0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_2__.objKeys)(requestDetails.hdrs)[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LENGTH /* @min:%2elength */] > 0);
                }
                _addRequestDetails(requestDetails, _InternalConstants__WEBPACK_IMPORTED_MODULE_0__.STR_CLIENT_ID, "NO_AUTH", useHeaders);
                _addRequestDetails(requestDetails, _InternalConstants__WEBPACK_IMPORTED_MODULE_0__.STR_CLIENT_VERSION, _microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_6__.FullVersionString, useHeaders);
                var apiQsKeys = _InternalConstants__WEBPACK_IMPORTED_MODULE_0__.STR_EMPTY;
                (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_2__.arrForEach)(thePayload.apiKeys, function (apiKey) {
                    if (apiQsKeys[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LENGTH /* @min:%2elength */] > 0) {
                        apiQsKeys += ",";
                    }
                    apiQsKeys += apiKey;
                });
                _addRequestDetails(requestDetails, _InternalConstants__WEBPACK_IMPORTED_MODULE_0__.STR_API_KEY, apiQsKeys, useHeaders);
                _addRequestDetails(requestDetails, _InternalConstants__WEBPACK_IMPORTED_MODULE_0__.STR_UPLOAD_TIME, (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_2__.utcNow)().toString(), useHeaders);
                var msfpc = _getMsfpc(thePayload);
                if ((0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_6__.isValueAssigned)(msfpc)) {
                    requestDetails.url += "&ext.intweb.msfpc=" + msfpc;
                }
                if (_clockSkewManager[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_SHOULD_ADD_CLOCK_SKE1 /* @min:%2eshouldAddClockSkewHeaders */]()) {
                    _addRequestDetails(requestDetails, _InternalConstants__WEBPACK_IMPORTED_MODULE_0__.STR_TIME_DELTA_TO_APPLY, _clockSkewManager[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_GET_CLOCK_SKEW_HEADE2 /* @min:%2egetClockSkewHeaderValue */](), useHeaders);
                }
                if (_core[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_GET_WPARAM /* @min:%2egetWParam */]) {
                    var wParam = _core[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_GET_WPARAM /* @min:%2egetWParam */]();
                    if (wParam >= 0) {
                        requestDetails.url += "&w=" + wParam;
                    }
                }
                for (var i = 0; i < _queryStringParameters[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LENGTH /* @min:%2elength */]; i++) {
                    requestDetails.url += "&" + _queryStringParameters[i].name + "=" + _queryStringParameters[i].value;
                }
                return requestDetails;
            }
            function _setTimingValue(timings, name, value) {
                timings[name] = timings[name] || {};
                timings[name][_postManager.identifier] = value;
            }
            function _doPayloadSend(thePayload, serializationStart, serializationCompleted, sendReason) {
                if (thePayload && thePayload.payloadBlob && thePayload.payloadBlob[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LENGTH /* @min:%2elength */] > 0) {
                    var useSendHook_1 = !!_sendHook;
                    var sendInterface_1 = _sendInterfaces[thePayload.sendType];
                    // Send all data using a beacon style transport if closing mode is on or channel was teared down
                    if (!_isBeaconPayload(thePayload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_SEND_TYPE /* @min:%2esendType */]) && thePayload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_IS_BEACON /* @min:%2eisBeacon */] && thePayload.sendReason === 2 /* SendRequestReason.Unload */) {
                        sendInterface_1 = _sendInterfaces[2 /* EventSendType.SendBeacon */] || _sendInterfaces[3 /* EventSendType.SyncFetch */] || sendInterface_1;
                    }
                    var useHeaders_1 = _useHeaders;
                    // Disable header usage if we know we are using sendBeacon as additional headers are not supported
                    if (thePayload.isBeacon || sendInterface_1[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN__TRANSPORT /* @min:%2e_transport */] === 3 /* TransportType.Beacon */) {
                        useHeaders_1 = false;
                    }
                    var requestDetails_1 = _buildRequestDetails(thePayload, useHeaders_1);
                    useHeaders_1 = useHeaders_1 || requestDetails_1[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_USE_HDRS /* @min:%2euseHdrs */];
                    var sendEventStart_1 = (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_6__.getTime)();
                    (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_15__.doPerf)(_core, function () { return "HttpManager:_doPayloadSend"; }, function () {
                        // Increment the send attempt count and add timings after packaging (So it's not serialized in the 1st attempt)
                        for (var batchLp = 0; batchLp < thePayload.batches[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LENGTH /* @min:%2elength */]; batchLp++) {
                            var theBatch = thePayload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_BATCHES /* @min:%2ebatches */][batchLp];
                            var theEvents = theBatch[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_EVENTS /* @min:%2eevents */]();
                            for (var evtLp = 0; evtLp < theEvents[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LENGTH /* @min:%2elength */]; evtLp++) {
                                var telemetryItem = theEvents[evtLp];
                                if (_enableEventTimings) {
                                    var timings = telemetryItem[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_TIMINGS /* @min:%2etimings */] = telemetryItem[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_TIMINGS /* @min:%2etimings */] || {};
                                    _setTimingValue(timings, "sendEventStart", sendEventStart_1);
                                    _setTimingValue(timings, "serializationStart", serializationStart);
                                    _setTimingValue(timings, "serializationCompleted", serializationCompleted);
                                }
                                telemetryItem[strSendAttempt] > 0 ? telemetryItem[strSendAttempt]++ : telemetryItem[strSendAttempt] = 1;
                            }
                        }
                        // Note: always sending this notification in a synchronous manner.
                        _sendBatchesNotification(thePayload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_BATCHES /* @min:%2ebatches */], (1000 /* EventBatchNotificationReason.SendingUndefined */ + (sendReason || 0 /* SendRequestReason.Undefined */)), thePayload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_SEND_TYPE /* @min:%2esendType */], true);
                        // Disabling the use of const because of Issue:
                        // - Task 9227844: [1DS] Some environments and packagers automatically "freeze" objects which are defined as const which causes any mutations to throw
                        // eslint-disable-next-line prefer-const
                        var orgPayloadData = {
                            data: thePayload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_PAYLOAD_BLOB /* @min:%2epayloadBlob */],
                            urlString: requestDetails_1.url,
                            headers: requestDetails_1[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_HDRS /* @min:%2ehdrs */],
                            _thePayload: thePayload,
                            _sendReason: sendReason,
                            timeout: _xhrTimeout,
                            disableXhrSync: _disableXhrSync,
                            disableFetchKeepAlive: _disableFetchKeepAlive
                        };
                        // Only automatically add the following headers if already sending headers and we are not attempting to avoid an options call
                        if (useHeaders_1) {
                            if (!_hasHeader(orgPayloadData[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_HEADERS /* @min:%2eheaders */], _InternalConstants__WEBPACK_IMPORTED_MODULE_0__.STR_CACHE_CONTROL)) {
                                orgPayloadData[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_HEADERS /* @min:%2eheaders */][_InternalConstants__WEBPACK_IMPORTED_MODULE_0__.STR_CACHE_CONTROL] = _InternalConstants__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_CACHE_CONTROL;
                            }
                            if (!_hasHeader(orgPayloadData[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_HEADERS /* @min:%2eheaders */], _InternalConstants__WEBPACK_IMPORTED_MODULE_0__.STR_CONTENT_TYPE_HEADER)) {
                                orgPayloadData[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_HEADERS /* @min:%2eheaders */][_InternalConstants__WEBPACK_IMPORTED_MODULE_0__.STR_CONTENT_TYPE_HEADER] = _InternalConstants__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_CONTENT_TYPE;
                            }
                        }
                        var sender = null;
                        if (sendInterface_1) {
                            // Send sync requests if the request is immediate or we are tearing down telemetry.
                            sender = function (payload) {
                                // Notify the clock skew manager that we are sending the first request (Potentially blocking all further requests)
                                _clockSkewManager[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_FIRST_REQUEST_SENT /* @min:%2efirstRequestSent */]();
                                var onComplete = function (status, headers) {
                                    _retryRequestIfNeeded(status, headers, thePayload, sendReason);
                                };
                                var isSync = thePayload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_IS_TEARDOWN /* @min:%2eisTeardown */] || thePayload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_IS_SYNC /* @min:%2eisSync */];
                                try {
                                    sendInterface_1.sendPOST(payload, onComplete, isSync);
                                    if (_sendListener) {
                                        // Send the original payload to the listener
                                        _sendListener(orgPayloadData, payload, isSync, thePayload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_IS_BEACON /* @min:%2eisBeacon */]);
                                    }
                                }
                                catch (ex) {
                                    (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_11__._warnToConsole)(_logger, "Unexpected exception sending payload. Ex:" + (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_2__.dumpObj)(ex));
                                    _doOnComplete(onComplete, 0, {});
                                }
                            };
                        }
                        (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_15__.doPerf)(_core, function () { return "HttpManager:_doPayloadSend.sender"; }, function () {
                            if (sender) {
                                if (thePayload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_SEND_TYPE /* @min:%2esendType */] === 0 /* EventSendType.Batched */) {
                                    _outstandingRequests++;
                                }
                                // Only call the hook if it's defined and we are not using sendBeacon as additional headers are not supported
                                if (useSendHook_1 && !thePayload.isBeacon && sendInterface_1[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN__TRANSPORT /* @min:%2e_transport */] !== 3 /* TransportType.Beacon */) {
                                    // Create a new IPayloadData that is sent into the hook method, so that the hook method
                                    // can't change the object references to the orgPayloadData (it can still change the content -- mainly the headers)
                                    // Disabling the use of const because of Issue:
                                    // - Task 9227844: [1DS] Some environments and packagers automatically "freeze" objects which are defined as const which causes any mutations to throw
                                    // eslint-disable-next-line prefer-const
                                    var hookData_1 = {
                                        data: orgPayloadData[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_DATA /* @min:%2edata */],
                                        urlString: orgPayloadData[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_URL_STRING /* @min:%2eurlString */],
                                        headers: (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_6__.extend)({}, orgPayloadData[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_HEADERS /* @min:%2eheaders */]),
                                        timeout: orgPayloadData[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_TIMEOUT /* @min:%2etimeout */],
                                        disableXhrSync: orgPayloadData[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_DISABLE_XHR_SYNC /* @min:%2edisableXhrSync */],
                                        disableFetchKeepAlive: orgPayloadData[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_DISABLE_FETCH_KEEP_A6 /* @min:%2edisableFetchKeepAlive */]
                                    };
                                    var senderCalled_1 = false;
                                    (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_15__.doPerf)(_core, function () { return "HttpManager:_doPayloadSend.sendHook"; }, function () {
                                        try {
                                            _sendHook(hookData_1, function (payload) {
                                                senderCalled_1 = true;
                                                // Add back the internal properties
                                                if (!_customHttpInterface && !payload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN__THE_PAYLOAD /* @min:%2e_thePayload */]) {
                                                    payload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN__THE_PAYLOAD /* @min:%2e_thePayload */] = payload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN__THE_PAYLOAD /* @min:%2e_thePayload */] || orgPayloadData[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN__THE_PAYLOAD /* @min:%2e_thePayload */];
                                                    payload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN__SEND_REASON /* @min:%2e_sendReason */] = payload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN__SEND_REASON /* @min:%2e_sendReason */] || orgPayloadData[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN__SEND_REASON /* @min:%2e_sendReason */];
                                                }
                                                sender(payload);
                                            }, thePayload.isSync || thePayload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_IS_TEARDOWN /* @min:%2eisTeardown */]);
                                        }
                                        catch (ex) {
                                            if (!senderCalled_1) {
                                                // The hook never called the sender -- assume that it never will
                                                sender(orgPayloadData);
                                            }
                                        }
                                    });
                                }
                                else {
                                    sender(orgPayloadData);
                                }
                            }
                        });
                    }, function () { return ({ thePayload: thePayload, serializationStart: serializationStart, serializationCompleted: serializationCompleted, sendReason: sendReason }); }, thePayload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_IS_SYNC /* @min:%2eisSync */]);
                }
                if (thePayload.sizeExceed && thePayload.sizeExceed[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LENGTH /* @min:%2elength */] > 0) {
                    // Ensure that we send any discard events for oversize events even when there was no payload to send
                    _sendBatchesNotification(thePayload.sizeExceed, 8003 /* EventBatchNotificationReason.SizeLimitExceeded */, thePayload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_SEND_TYPE /* @min:%2esendType */]);
                }
                if (thePayload.failedEvts && thePayload.failedEvts[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LENGTH /* @min:%2elength */] > 0) {
                    // Ensure that we send any discard events for events that could not be serialized even when there was no payload to send
                    _sendBatchesNotification(thePayload.failedEvts, 8002 /* EventBatchNotificationReason.InvalidEvent */, thePayload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_SEND_TYPE /* @min:%2esendType */]);
                }
            }
            function _addEventCompletedTimings(theEvents, sendEventCompleted) {
                if (_enableEventTimings) {
                    (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_2__.arrForEach)(theEvents, function (theEvent) {
                        var timings = theEvent[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_TIMINGS /* @min:%2etimings */] = theEvent[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_TIMINGS /* @min:%2etimings */] || {};
                        _setTimingValue(timings, "sendEventCompleted", sendEventCompleted);
                    });
                }
            }
            function _retryRequestIfNeeded(status, headers, thePayload, sendReason) {
                var reason = 9000 /* EventBatchNotificationReason.ResponseFailure */;
                var droppedBatches = null;
                var isRetrying = false;
                var backOffTrans = false;
                try {
                    var shouldRetry = true;
                    if (typeof status !== _microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_16__.strShimUndefined) {
                        if (headers) {
                            _clockSkewManager[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_SET_CLOCK_SKEW /* @min:%2esetClockSkew */](headers[_InternalConstants__WEBPACK_IMPORTED_MODULE_0__.STR_TIME_DELTA_HEADER]);
                            var killDuration = headers[_InternalConstants__WEBPACK_IMPORTED_MODULE_0__.STR_KILL_DURATION_HEADER] || headers["kill-duration-seconds"];
                            (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_2__.arrForEach)(_killSwitch[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_SET_KILL_SWITCH_TENA11 /* @min:%2esetKillSwitchTenants */](headers[_InternalConstants__WEBPACK_IMPORTED_MODULE_0__.STR_KILL_TOKENS_HEADER], killDuration), function (killToken) {
                                (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_2__.arrForEach)(thePayload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_BATCHES /* @min:%2ebatches */], function (theBatch) {
                                    if (theBatch[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_I_KEY /* @min:%2eiKey */]() === killToken) {
                                        // Make sure we have initialized the array
                                        droppedBatches = droppedBatches || [];
                                        // Create a copy of the batch with all of the events (and more importantly the action functions)
                                        var removedEvents = theBatch[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_SPLIT /* @min:%2esplit */](0);
                                        // And then remove the events for the payload batch and reduce the actual number of processed
                                        thePayload.numEvents -= removedEvents[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_COUNT /* @min:%2ecount */]();
                                        droppedBatches[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_PUSH /* @min:%2epush */](removedEvents);
                                    }
                                });
                            });
                        }
                        // Disabling triple-equals rule to avoid httpOverrides from failing because they are returning a string value
                        // tslint:disable-next-line:triple-equals
                        if (status == 200 || status == 204) {
                            // Response was successfully sent
                            reason = 200 /* EventBatchNotificationReason.Complete */;
                            return;
                        }
                        if (!(0,_RetryPolicy__WEBPACK_IMPORTED_MODULE_17__.retryPolicyShouldRetryForStatus)(status) || thePayload.numEvents <= 0) {
                            // Only retry for specific response codes and if there is still events after kill switch processing
                            shouldRetry = false;
                        }
                        // Derive the notification response from the HttpStatus Code
                        reason = 9000 /* EventBatchNotificationReason.ResponseFailure */ + (status % 1000);
                    }
                    if (shouldRetry) {
                        // The events should be retried -- so change notification to requeue them
                        reason = 100 /* EventBatchNotificationReason.RequeueEvents */;
                        var retryCount_1 = thePayload.retryCnt;
                        if (thePayload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_SEND_TYPE /* @min:%2esendType */] === 0 /* EventSendType.Batched */) {
                            // attempt to resend the entire batch
                            if (retryCount_1 < maxRequestRetriesBeforeBackoff) {
                                isRetrying = true;
                                _doAction(function () {
                                    // try to resend the same batches
                                    if (thePayload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_SEND_TYPE /* @min:%2esendType */] === 0 /* EventSendType.Batched */) {
                                        // Reduce the outstanding request count (if this was an async request) as we didn't reduce the count
                                        // previously and we are about to reschedule our retry attempt and we want an attempt to send
                                        // to occur, it's also required to ensure that a follow up handleRequestFinished() call occurs
                                        _outstandingRequests--;
                                    }
                                    _sendBatches(thePayload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_BATCHES /* @min:%2ebatches */], retryCount_1 + 1, thePayload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_IS_TEARDOWN /* @min:%2eisTeardown */], _isUnloading ? 2 /* EventSendType.SendBeacon */ : thePayload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_SEND_TYPE /* @min:%2esendType */], 5 /* SendRequestReason.Retry */);
                                }, _isUnloading, (0,_RetryPolicy__WEBPACK_IMPORTED_MODULE_17__.retryPolicyGetMillisToBackoffForRetry)(retryCount_1));
                            }
                            else {
                                backOffTrans = true;
                                if (_isUnloading) {
                                    // we are unloading so don't try and requeue the events otherwise let the events get requeued and resent during the backoff sending
                                    // This will also cause the events to be purged based on the priority (if necessary)
                                    reason = 8001 /* EventBatchNotificationReason.NonRetryableStatus */;
                                }
                            }
                        }
                    }
                }
                finally {
                    if (!isRetrying) {
                        // Make sure the clockSkewManager doesn't blocking further sending of requests once we have a proper response
                        // This won't override any previously sent clock Skew value
                        _clockSkewManager[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_SET_CLOCK_SKEW /* @min:%2esetClockSkew */]();
                        _handleRequestFinished(thePayload, reason, sendReason, backOffTrans);
                    }
                    _sendBatchesNotification(droppedBatches, 8004 /* EventBatchNotificationReason.KillSwitch */, thePayload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_SEND_TYPE /* @min:%2esendType */]);
                }
            }
            function _handleRequestFinished(thePayload, batchReason, sendReason, backOffTrans) {
                try {
                    if (backOffTrans) {
                        // Slow down the transmission requests
                        _postManager[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN__BACK_OFF_TRANSMISSI12 /* @min:%2e_backOffTransmission */]();
                    }
                    var theBatches = thePayload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_BATCHES /* @min:%2ebatches */];
                    if (batchReason === 200 /* EventBatchNotificationReason.Complete */) {
                        theBatches = thePayload.sentEvts || thePayload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_BATCHES /* @min:%2ebatches */];
                        if (!backOffTrans && !thePayload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_IS_SYNC /* @min:%2eisSync */]) {
                            // We have a successful async response, so the lets open the floodgates
                            // The reason for checking isSync is to avoid unblocking if beacon send occurred as it
                            // doesn't wait for a response.
                            _postManager._clearBackOff();
                        }
                        _addCompleteTimings(theBatches);
                    }
                    // Send the notifications synchronously
                    _sendBatchesNotification(theBatches, batchReason, thePayload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_SEND_TYPE /* @min:%2esendType */], true);
                }
                finally {
                    if (thePayload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_SEND_TYPE /* @min:%2esendType */] === 0 /* EventSendType.Batched */) {
                        // we always need to decrement this value otherwise the httpmanager locks up and won't send any more events
                        _outstandingRequests--;
                        // Don't try to send additional queued events if this is a retry operation as the retried
                        // response will eventually call _handleRequestFinished for the retried event
                        if (sendReason !== 5 /* SendRequestReason.Retry */) {
                            // Try and send any other queued batched events
                            _self.sendQueuedRequests(thePayload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_SEND_TYPE /* @min:%2esendType */], sendReason);
                        }
                    }
                }
            }
            function _addCompleteTimings(theBatches) {
                if (_enableEventTimings) {
                    var sendEventCompleted_1 = (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_6__.getTime)();
                    (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_2__.arrForEach)(theBatches, function (theBatch) {
                        if (theBatch && theBatch[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_COUNT /* @min:%2ecount */]() > 0) {
                            _addEventCompletedTimings(theBatch[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_EVENTS /* @min:%2eevents */](), sendEventCompleted_1);
                        }
                    });
                }
            }
            function _doAction(cb, isSync, interval) {
                if (isSync) {
                    cb();
                }
                else {
                    _timeoutWrapper.set(cb, interval);
                }
            }
            function _getMsfpc(thePayload) {
                for (var lp = 0; lp < thePayload.batches[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LENGTH /* @min:%2elength */]; lp++) {
                    var msfpc = thePayload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_BATCHES /* @min:%2ebatches */][lp].Msfpc();
                    if (msfpc) {
                        return encodeURIComponent(msfpc);
                    }
                }
                return _InternalConstants__WEBPACK_IMPORTED_MODULE_0__.STR_EMPTY;
            }
            function _handleCollectorResponse(responseText) {
                var responseHandlers = _responseHandlers;
                try {
                    for (var i = 0; i < responseHandlers[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LENGTH /* @min:%2elength */]; i++) {
                        try {
                            responseHandlers[i](responseText);
                        }
                        catch (e) {
                            (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_11__._throwInternal)(_logger, 1 /* eLoggingSeverity.CRITICAL */, 519 /* _eExtendedInternalMessageId.PostResponseHandler */, "Response handler failed: " + e);
                        }
                    }
                    if (responseText) {
                        var response = JSON.parse(responseText);
                        if ((0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_6__.isValueAssigned)(response.webResult) && (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_6__.isValueAssigned)(response.webResult[_InternalConstants__WEBPACK_IMPORTED_MODULE_0__.STR_MSFPC])) {
                            // Set cookie
                            _cookieMgr.set("MSFPC", response.webResult[_InternalConstants__WEBPACK_IMPORTED_MODULE_0__.STR_MSFPC], 365 * 86400);
                        }
                    }
                }
                catch (ex) {
                    // Doing nothing
                }
            }
            function _sendBatchesNotification(theBatches, batchReason, sendType, sendSync) {
                if (theBatches && theBatches[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LENGTH /* @min:%2elength */] > 0 && actions) {
                    var theAction_1 = actions[_getNotificationAction(batchReason)];
                    if (theAction_1) {
                        var isSyncRequest_1 = sendType !== 0 /* EventSendType.Batched */;
                        (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_15__.doPerf)(_core, function () { return "HttpManager:_sendBatchesNotification"; }, function () {
                            _doAction(function () {
                                try {
                                    theAction_1.call(actions, theBatches, batchReason, isSyncRequest_1, sendType);
                                }
                                catch (e) {
                                    (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_11__._throwInternal)(_logger, 1 /* eLoggingSeverity.CRITICAL */, 74 /* _eInternalMessageId.NotificationException */, "send request notification failed: " + e);
                                }
                            }, sendSync || isSyncRequest_1, 0);
                        }, function () { return ({ batches: _createDebugBatches(theBatches), reason: batchReason, isSync: isSyncRequest_1, sendSync: sendSync, sendType: sendType }); }, !isSyncRequest_1);
                    }
                }
            }
            function _getNotificationAction(reason) {
                var action = _eventActionMap[reason];
                if (!(0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_6__.isValueAssigned)(action)) {
                    action = _InternalConstants__WEBPACK_IMPORTED_MODULE_0__.STR_OTHER;
                    if (reason >= 9000 /* EventBatchNotificationReason.ResponseFailure */ && reason <= 9999 /* EventBatchNotificationReason.ResponseFailureMax */) {
                        action = _InternalConstants__WEBPACK_IMPORTED_MODULE_0__.STR_RESPONSE_FAIL;
                    }
                    else if (reason >= 8000 /* EventBatchNotificationReason.EventsDropped */ && reason <= 8999 /* EventBatchNotificationReason.EventsDroppedMax */) {
                        action = _InternalConstants__WEBPACK_IMPORTED_MODULE_0__.STR_DROPPED;
                    }
                    else if (reason >= 1000 /* EventBatchNotificationReason.SendingUndefined */ && reason <= 1999 /* EventBatchNotificationReason.SendingEventMax */) {
                        action = _InternalConstants__WEBPACK_IMPORTED_MODULE_0__.STR_SENDING;
                    }
                }
                return action;
            }
        });
    }
// Removed Stub for HttpManager.prototype.initialize.
// Removed Stub for HttpManager.prototype.addHeader.
// Removed Stub for HttpManager.prototype.removeHeader.
// Removed Stub for HttpManager.prototype.addResponseHandler.
// Removed Stub for HttpManager.prototype.addBatch.
// Removed Stub for HttpManager.prototype.canSendRequest.
// Removed Stub for HttpManager.prototype.sendQueuedRequests.
// Removed Stub for HttpManager.prototype.isCompletelyIdle.
// Removed Stub for HttpManager.prototype.setUnloading.
// Removed Stub for HttpManager.prototype.teardown.
// Removed Stub for HttpManager.prototype.pause.
// Removed Stub for HttpManager.prototype.resume.
// Removed Stub for HttpManager.prototype.sendSynchronousBatch.
// Removed Stub for HttpManager.prototype.serializeOfflineEvt.
// Removed Stub for HttpManager.prototype.getOfflineRequestDetails.
// Removed Stub for HttpManager.prototype.createOneDSPayload.
    // This is a workaround for an IE bug when using dynamicProto() with classes that don't have any
    // non-dynamic functions or static properties/functions when using uglify-js to minify the resulting code.
    HttpManager.__ieDyn=1;

    return HttpManager;
}());

//# sourceMappingURL=HttpManager.js.map

/***/ }),
/* 84 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Serializer": () => (/* binding */ Serializer)
/* harmony export */ });
/* harmony import */ var _microsoft_dynamicproto_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(35);
/* harmony import */ var _microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(52);
/* harmony import */ var _microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(37);
/* harmony import */ var _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(30);
/* harmony import */ var _EventBatch__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(82);
/* harmony import */ var _InternalConstants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(81);
/*
 * 1DS JS SDK POST plugin, 4.3.0
 * Copyright (c) Microsoft and contributors. All rights reserved.
 * (Microsoft Internal Only)
 */
/**
* Serializer.ts
* @author Abhilash Panwar (abpanwar); Hector Hernandez (hectorh); Nev Wylie (newylie)
* @copyright Microsoft 2018-2020
*/
// @skip-file-minify





/**
 * Note: This is an optimization for V8-based browsers. When V8 concatenates a string,
 * the strings are only joined logically using a "cons string" or "constructed/concatenated
 * string". These containers keep references to one another and can result in very large
 * memory usage. For example, if a 2MB string is constructed by concatenating 4 bytes
 * together at a time, the memory usage will be ~44MB; so ~22x increase. The strings are
 * only joined together when an operation requiring their joining takes place, such as
 * substr(). This function is called when adding data to this buffer to ensure these
 * types of strings are periodically joined to reduce the memory footprint.
 * Setting to every 20 events as the JSON.stringify() may have joined many strings
 * and calling this too much causes a minor delay while processing.
 */
var _MAX_STRING_JOINS = 20;
var RequestSizeLimitBytes = 3984588; // approx 3.8 Mb
var BeaconRequestSizeLimitBytes = 65000; // approx 64kb (the current Edge, Firefox and Chrome max limit)
var MaxRecordSize = 2000000; // approx 2 Mb
var MaxBeaconRecordSize = Math.min(MaxRecordSize, BeaconRequestSizeLimitBytes);
var metadata = "metadata";
var f = "f";
var rCheckDot = /\./;
/**
* Class to handle serialization of event and request.
* Currently uses Bond for serialization. Please note that this may be subject to change.
*/
var Serializer = /** @class */ (function () {
    /**
     * Constructs a new instance of the Serializer class
     * @param perfManager - The performance manager to use for tracking performance
     * @param valueSanitizer - The value sanitizer to use for sanitizing field values
     * @param stringifyObjects - Should objects be stringified before being sent
     * @param enableCompoundKey - Should compound keys be enabled (defaults to false)
     * @param getEncodedTypeOverride - The callback to get the encoded type for a property defaults to ({@link getCommonSchemaMetaData }(...))
     * @param excludeCsMetaData - (!DANGER!) Should metadata be populated when encoding the event blob (defaults to false) - PII data will NOT be tagged as PII for backend processing
     */
    function Serializer(perfManager, valueSanitizer, stringifyObjects, enableCompoundKey, getEncodedTypeOverride, excludeCsMetaData) {
        var strData = "data";
        var strBaseData = "baseData";
        var strExt = "ext";
        var _checkForCompoundkey = !!enableCompoundKey;
        var _processSubKeys = true;
        var _theSanitizer = valueSanitizer;
        var _isReservedCache = {};
        var _excludeCsMetaData = !!excludeCsMetaData;
        var _getEncodedType = getEncodedTypeOverride || _microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_0__.getCommonSchemaMetaData;
        (0,_microsoft_dynamicproto_js__WEBPACK_IMPORTED_MODULE_1__["default"])(Serializer, this, function (_self) {
            _self.createPayload = function (retryCnt, isTeardown, isSync, isReducedPayload, sendReason, sendType) {
                return {
                    apiKeys: [],
                    payloadBlob: _InternalConstants__WEBPACK_IMPORTED_MODULE_2__.STR_EMPTY,
                    overflow: null,
                    sizeExceed: [],
                    failedEvts: [],
                    batches: [],
                    numEvents: 0,
                    retryCnt: retryCnt,
                    isTeardown: isTeardown,
                    isSync: isSync,
                    isBeacon: isReducedPayload,
                    sendType: sendType,
                    sendReason: sendReason
                };
            };
            _self.appendPayload = function (payload, theBatch, maxEventsPerBatch) {
                var canAddEvents = payload && theBatch && !payload.overflow;
                if (canAddEvents) {
                    (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_3__.doPerf)(perfManager, function () { return "Serializer:appendPayload"; }, function () {
                        var theEvents = theBatch.events();
                        var payloadBlob = payload.payloadBlob;
                        var payloadEvents = payload.numEvents;
                        var eventsAdded = false;
                        var sizeExceeded = [];
                        var failedEvts = [];
                        var isBeaconPayload = payload.isBeacon;
                        var requestMaxSize = isBeaconPayload ? BeaconRequestSizeLimitBytes : RequestSizeLimitBytes;
                        var recordMaxSize = isBeaconPayload ? MaxBeaconRecordSize : MaxRecordSize;
                        var lp = 0;
                        var joinCount = 0;
                        while (lp < theEvents.length) {
                            var theEvent = theEvents[lp];
                            if (theEvent) {
                                if (payloadEvents >= maxEventsPerBatch) {
                                    // Maximum events per payload reached, so don't add any more
                                    payload.overflow = theBatch.split(lp);
                                    break;
                                }
                                var eventBlob = _self.getEventBlob(theEvent);
                                if (eventBlob && eventBlob.length <= recordMaxSize) {
                                    // This event will fit into the payload
                                    var blobLength = eventBlob.length;
                                    var currentSize = payloadBlob.length;
                                    if (currentSize + blobLength > requestMaxSize) {
                                        // Request or batch size exceeded, so don't add any more to the payload
                                        payload.overflow = theBatch.split(lp);
                                        break;
                                    }
                                    if (payloadBlob) {
                                        payloadBlob += "\n";
                                    }
                                    payloadBlob += eventBlob;
                                    joinCount++;
                                    // v8 memory optimization only
                                    if (joinCount > _MAX_STRING_JOINS) {
                                        // this substr() should cause the constructed string to join
                                        (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_4__.strSubstr)(payloadBlob, 0, 1);
                                        joinCount = 0;
                                    }
                                    eventsAdded = true;
                                    payloadEvents++;
                                }
                                else {
                                    if (eventBlob) {
                                        // Single event size exceeded so remove from the batch
                                        sizeExceeded.push(theEvent);
                                    }
                                    else {
                                        failedEvts.push(theEvent);
                                    }
                                    // We also need to remove this event from the existing array, otherwise a notification will be sent
                                    // indicating that it was successfully sent
                                    theEvents.splice(lp, 1);
                                    lp--;
                                }
                            }
                            lp++;
                        }
                        if (sizeExceeded.length > 0) {
                            payload.sizeExceed.push(_EventBatch__WEBPACK_IMPORTED_MODULE_5__.EventBatch.create(theBatch.iKey(), sizeExceeded));
                            // Remove the exceeded events from the batch
                        }
                        if (failedEvts.length > 0) {
                            payload.failedEvts.push(_EventBatch__WEBPACK_IMPORTED_MODULE_5__.EventBatch.create(theBatch.iKey(), failedEvts));
                            // Remove the failed events from the batch
                        }
                        if (eventsAdded) {
                            payload.batches.push(theBatch);
                            payload.payloadBlob = payloadBlob;
                            payload.numEvents = payloadEvents;
                            var apiKey = theBatch.iKey();
                            if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_4__.arrIndexOf)(payload.apiKeys, apiKey) === -1) {
                                payload.apiKeys.push(apiKey);
                            }
                        }
                    }, function () { return ({ payload: payload, theBatch: { iKey: theBatch.iKey(), evts: theBatch.events() }, max: maxEventsPerBatch }); });
                }
                return canAddEvents;
            };
            _self.getEventBlob = function (eventData) {
                try {
                    return (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_3__.doPerf)(perfManager, function () { return "Serializer.getEventBlob"; }, function () {
                        var serializedEvent = {};
                        // Adding as dynamic keys for v8 performance
                        serializedEvent.name = eventData.name;
                        serializedEvent.time = eventData.time;
                        serializedEvent.ver = eventData.ver;
                        serializedEvent.iKey = "o:" + (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_0__.getTenantId)(eventData.iKey);
                        // Assigning local var so usage in part b/c don't throw if there is no ext
                        var serializedExt = {};
                        var _addMetadataCallback;
                        if (!_excludeCsMetaData) {
                            _addMetadataCallback = function (pathKeys, key, value) {
                                _addJSONPropertyMetaData(_getEncodedType, serializedExt, pathKeys, key, value);
                            };
                        }
                        // Part A
                        var eventExt = eventData[strExt];
                        if (eventExt) {
                            // Only assign ext if the event had one (There are tests covering this use case)
                            serializedEvent[strExt] = serializedExt;
                            (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_4__.objForEachKey)(eventExt, function (key, value) {
                                var data = serializedExt[key] = {};
                                // Don't include a metadata callback as we don't currently set metadata Part A fields
                                _processPathKeys(value, data, "ext." + key, true, null, null, true);
                            });
                        }
                        var serializedData = serializedEvent[strData] = {};
                        serializedData.baseType = eventData.baseType;
                        var serializedBaseData = serializedData[strBaseData] = {};
                        // Part B
                        _processPathKeys(eventData.baseData, serializedBaseData, strBaseData, false, [strBaseData], _addMetadataCallback, _processSubKeys);
                        // Part C
                        _processPathKeys(eventData.data, serializedData, strData, false, [], _addMetadataCallback, _processSubKeys);
                        return JSON.stringify(serializedEvent);
                    }, function () { return ({ item: eventData }); });
                }
                catch (e) {
                    return null;
                }
            };
            function _isReservedField(path, name) {
                var result = _isReservedCache[path];
                if (result === undefined) {
                    if (path.length >= 7) {
                        // Do not allow the changing of fields located in the ext.metadata or ext.web extension
                        result = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_4__.strStartsWith)(path, "ext.metadata") || (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_4__.strStartsWith)(path, "ext.web");
                    }
                    _isReservedCache[path] = result;
                }
                return result;
            }
            function _processPathKeys(srcObj, target, thePath, checkReserved, metadataPathKeys, metadataCallback, processSubKeys) {
                (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_4__.objForEachKey)(srcObj, function (key, srcValue) {
                    var prop = null;
                    if (srcValue || (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_0__.isValueAssigned)(srcValue)) {
                        var path = thePath;
                        var name_1 = key;
                        var theMetaPathKeys = metadataPathKeys;
                        var destObj = target;
                        // Handle keys with embedded '.', like "TestObject.testProperty"
                        if (_checkForCompoundkey && !checkReserved && rCheckDot.test(key)) {
                            var subKeys = key.split(".");
                            var keyLen = subKeys.length;
                            if (keyLen > 1) {
                                if (theMetaPathKeys) {
                                    // Create a copy of the meta path keys so we can add the extra ones
                                    theMetaPathKeys = theMetaPathKeys.slice();
                                }
                                for (var lp = 0; lp < keyLen - 1; lp++) {
                                    var subKey = subKeys[lp];
                                    // Add/reuse the sub key object
                                    destObj = destObj[subKey] = destObj[subKey] || {};
                                    path += "." + subKey;
                                    if (theMetaPathKeys) {
                                        theMetaPathKeys.push(subKey);
                                    }
                                }
                                name_1 = subKeys[keyLen - 1];
                            }
                        }
                        var isReserved = checkReserved && _isReservedField(path, name_1);
                        if (!isReserved && _theSanitizer && _theSanitizer.handleField(path, name_1)) {
                            prop = _theSanitizer.value(path, name_1, srcValue, stringifyObjects);
                        }
                        else {
                            prop = (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_0__.sanitizeProperty)(name_1, srcValue, stringifyObjects);
                        }
                        if (prop) {
                            // Set the value
                            var newValue = prop.value;
                            destObj[name_1] = newValue;
                            if (metadataCallback) {
                                metadataCallback(theMetaPathKeys, name_1, prop);
                            }
                            if (processSubKeys && typeof newValue === "object" && !(0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_4__.isArray)(newValue)) {
                                var newPath = theMetaPathKeys;
                                if (newPath) {
                                    newPath = newPath.slice();
                                    newPath.push(name_1);
                                }
                                // Make sure we process sub objects as well (for value sanitization and metadata)
                                _processPathKeys(srcValue, newValue, path + "." + name_1, checkReserved, newPath, metadataCallback, processSubKeys);
                            }
                        }
                    }
                });
            }
        });
    }
// Removed Stub for Serializer.prototype.createPayload.
// Removed Stub for Serializer.prototype.appendPayload.
// Removed Stub for Serializer.prototype.getEventBlob.
// Removed Stub for Serializer.prototype.handleField.
// Removed Stub for Serializer.prototype.getSanitizer.
    // This is a workaround for an IE bug when using dynamicProto() with classes that don't have any
    // non-dynamic functions or static properties/functions when using uglify-js to minify the resulting code.
    Serializer.__ieDyn=1;

    return Serializer;
}());

/**
 * @ignore
 * @param getEncodedType - The function to get the encoded type for the property
 * @param json - The json object to add the metadata to
 * @param propKeys - The property keys to add to the metadata
 * @param name - The name of the property
 * @param propertyValue - The property value
 */
function _addJSONPropertyMetaData(getEncodedType, json, propKeys, name, propertyValue) {
    if (propertyValue && json) {
        var encodedTypeValue = getEncodedType(propertyValue.value, propertyValue.kind, propertyValue.propertyType);
        if (encodedTypeValue > -1) {
            // Add the root metadata
            var metaData = json[metadata];
            if (!metaData) {
                // Sets the root 'f'
                metaData = json[metadata] = { f: {} };
            }
            var metaTarget = metaData[f];
            if (!metaTarget) {
                // This can occur if someone has manually added an ext.metadata object
                // Such as ext.metadata.privLevel and ext.metadata.privTags
                metaTarget = metaData[f] = {};
            }
            // Traverse the metadata path and build each object (contains an 'f' key) -- if required
            if (propKeys) {
                for (var lp = 0; lp < propKeys.length; lp++) {
                    var key = propKeys[lp];
                    if (!metaTarget[key]) {
                        metaTarget[key] = { f: {} };
                    }
                    var newTarget = metaTarget[key][f];
                    if (!newTarget) {
                        // Not expected, but can occur if the metadata context was pre-created as part of the event
                        newTarget = metaTarget[key][f] = {};
                    }
                    metaTarget = newTarget;
                }
            }
            metaTarget = metaTarget[name] = {};
            if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_4__.isArray)(propertyValue.value)) {
                metaTarget["a"] = {
                    t: encodedTypeValue
                };
            }
            else {
                metaTarget["t"] = encodedTypeValue;
            }
        }
    }
}
//# sourceMappingURL=Serializer.js.map

/***/ }),
/* 85 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "KillSwitch": () => (/* binding */ KillSwitch)
/* harmony export */ });
/* harmony import */ var _microsoft_dynamicproto_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(35);
/* harmony import */ var _microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(30);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(79);
/*
 * 1DS JS SDK POST plugin, 4.3.0
 * Copyright (c) Microsoft and contributors. All rights reserved.
 * (Microsoft Internal Only)
 */
/**
* KillSwitch.ts
* @author Abhilash Panwar (abpanwar)
* @copyright Microsoft 2018
*/



var SecToMsMultiplier = 1000;
/**
* Class to stop certain tenants sending events.
*/
var KillSwitch = /** @class */ (function () {
    function KillSwitch() {
        var _killedTokenDictionary = {};
        function _normalizeTenants(values) {
            var result = [];
            if (values) {
                (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_0__.arrForEach)(values, function (value) {
                    result[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_PUSH /* @min:%2epush */]((0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_0__.strTrim)(value));
                });
            }
            return result;
        }
        (0,_microsoft_dynamicproto_js__WEBPACK_IMPORTED_MODULE_2__["default"])(KillSwitch, this, function (_self) {
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_SET_KILL_SWITCH_TENA11 /* @min:%2esetKillSwitchTenants */] = function (killTokens, killDuration) {
                if (killTokens && killDuration) {
                    try {
                        var killedTokens = _normalizeTenants(killTokens[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_SPLIT /* @min:%2esplit */](","));
                        if (killDuration === "this-request-only") {
                            return killedTokens;
                        }
                        var durationMs = parseInt(killDuration, 10) * SecToMsMultiplier;
                        for (var i = 0; i < killedTokens[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LENGTH /* @min:%2elength */]; ++i) {
                            _killedTokenDictionary[killedTokens[i]] = (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_0__.utcNow)() + durationMs;
                        }
                    }
                    catch (ex) {
                        return [];
                    }
                }
                return [];
            };
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_IS_TENANT_KILLED /* @min:%2eisTenantKilled */] = function (tenantToken) {
                var killDictionary = _killedTokenDictionary;
                var name = (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_0__.strTrim)(tenantToken);
                if (killDictionary[name] !== undefined && killDictionary[name] > (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_0__.utcNow)()) {
                    return true;
                }
                delete killDictionary[name];
                return false;
            };
        });
    }
// Removed Stub for KillSwitch.prototype.setKillSwitchTenants.
// Removed Stub for KillSwitch.prototype.isTenantKilled.
    // This is a workaround for an IE bug when using dynamicProto() with classes that don't have any
    // non-dynamic functions or static properties/functions when using uglify-js to minify the resulting code.
    KillSwitch.__ieDyn=1;

    return KillSwitch;
}());

//# sourceMappingURL=KillSwitch.js.map

/***/ }),
/* 86 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ClockSkewManager": () => (/* binding */ ClockSkewManager)
/* harmony export */ });
/* harmony import */ var _microsoft_dynamicproto_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(35);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(79);
/*
 * 1DS JS SDK POST plugin, 4.3.0
 * Copyright (c) Microsoft and contributors. All rights reserved.
 * (Microsoft Internal Only)
 */
/**
* ClockSkewManager.ts
* @author Abhilash Panwar (abpanwar)
* @copyright Microsoft 2018
*/


/**
* Class to manage clock skew correction.
*/
var ClockSkewManager = /** @class */ (function () {
    function ClockSkewManager() {
        var _allowRequestSending = true;
        var _shouldAddClockSkewHeaders = true;
        var _isFirstRequest = true;
        var _clockSkewHeaderValue = "use-collector-delta";
        var _clockSkewSet = false;
        (0,_microsoft_dynamicproto_js__WEBPACK_IMPORTED_MODULE_0__["default"])(ClockSkewManager, this, function (_self) {
            /**
             * Determine if requests can be sent.
             * @returns True if requests can be sent, false otherwise.
             */
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_ALLOW_REQUEST_SENDIN0 /* @min:%2eallowRequestSending */] = function () {
                return _allowRequestSending;
            };
            /**
             * Tells the ClockSkewManager that it should assume that the first request has now been sent,
             * If this method had not yet been called AND the clock Skew had not been set this will set
             * allowRequestSending to false until setClockSet() is called.
             */
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_FIRST_REQUEST_SENT /* @min:%2efirstRequestSent */] = function () {
                if (_isFirstRequest) {
                    _isFirstRequest = false;
                    if (!_clockSkewSet) {
                        // Block sending until we get the first clock Skew
                        _allowRequestSending = false;
                    }
                }
            };
            /**
             * Determine if clock skew headers should be added to the request.
             * @returns True if clock skew headers should be added, false otherwise.
             */
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_SHOULD_ADD_CLOCK_SKE1 /* @min:%2eshouldAddClockSkewHeaders */] = function () {
                return _shouldAddClockSkewHeaders;
            };
            /**
             * Gets the clock skew header value.
             * @returns The clock skew header value.
             */
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_GET_CLOCK_SKEW_HEADE2 /* @min:%2egetClockSkewHeaderValue */] = function () {
                return _clockSkewHeaderValue;
            };
            /**
             * Sets the clock skew header value. Once clock skew is set this method
             * is no-op.
             * @param timeDeltaInMillis - Time delta to be saved as the clock skew header value.
             */
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_SET_CLOCK_SKEW /* @min:%2esetClockSkew */] = function (timeDeltaInMillis) {
                if (!_clockSkewSet) {
                    if (timeDeltaInMillis) {
                        _clockSkewHeaderValue = timeDeltaInMillis;
                        _shouldAddClockSkewHeaders = true;
                        _clockSkewSet = true;
                    }
                    else {
                        _shouldAddClockSkewHeaders = false;
                    }
                    // Unblock sending
                    _allowRequestSending = true;
                }
            };
        });
    }
// Removed Stub for ClockSkewManager.prototype.allowRequestSending.
// Removed Stub for ClockSkewManager.prototype.firstRequestSent.
// Removed Stub for ClockSkewManager.prototype.shouldAddClockSkewHeaders.
// Removed Stub for ClockSkewManager.prototype.getClockSkewHeaderValue.
// Removed Stub for ClockSkewManager.prototype.setClockSkew.
    // This is a workaround for an IE bug when using dynamicProto() with classes that don't have any
    // non-dynamic functions or static properties/functions when using uglify-js to minify the resulting code.
    ClockSkewManager.__ieDyn=1;

    return ClockSkewManager;
}());

//# sourceMappingURL=ClockSkewManager.js.map

/***/ }),
/* 87 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "retryPolicyGetMillisToBackoffForRetry": () => (/* binding */ retryPolicyGetMillisToBackoffForRetry),
/* harmony export */   "retryPolicyShouldRetryForStatus": () => (/* binding */ retryPolicyShouldRetryForStatus)
/* harmony export */ });
/*
 * 1DS JS SDK POST plugin, 4.3.0
 * Copyright (c) Microsoft and contributors. All rights reserved.
 * (Microsoft Internal Only)
 */
/**
* RetryPolicy.ts
* @author Abhilash Panwar (abpanwar)
* @copyright Microsoft 2018
*/
var RandomizationLowerThreshold = 0.8;
var RandomizationUpperThreshold = 1.2;
var BaseBackoff = 3000;
var MaxBackoff = 600000;
/**
 * Determine if the request should be retried for the given status code.
 * The below expression reads that we should only retry for:
 *      - HttpStatusCodes that are smaller than 300.
 *      - HttpStatusCodes greater or equal to 500 (except for 501-NotImplement
 *        and 505-HttpVersionNotSupport).
 *      - HttpStatusCode 408-RequestTimeout.
 *      - HttpStatusCode 429.
 * This is based on Microsoft.WindowsAzure.Storage.RetryPolicies.ExponentialRetry class
 * @param httpStatusCode - The status code returned for the request.
 * @returns True if request should be retried, false otherwise.
 */
function retryPolicyShouldRetryForStatus(httpStatusCode) {
    /* tslint:disable:triple-equals */
    // Disabling triple-equals rule to avoid httpOverrides from failing because they are returning a string value
    return !((httpStatusCode >= 300 && httpStatusCode < 500 && httpStatusCode != 429)
        || (httpStatusCode == 501)
        || (httpStatusCode == 505));
    /* tslint:enable:triple-equals */
}
/**
 * Gets the number of milliseconds to back off before retrying the request. The
 * back off duration is exponentially scaled based on the number of retries already
 * done for the request.
 * @param retriesSoFar - The number of times the request has already been retried.
 * @returns The back off duration for the request before it can be retried.
 */
function retryPolicyGetMillisToBackoffForRetry(retriesSoFar) {
    var waitDuration = 0;
    var minBackoff = BaseBackoff * RandomizationLowerThreshold;
    var maxBackoff = BaseBackoff * RandomizationUpperThreshold;
    var randomBackoff = Math.floor(Math.random() * (maxBackoff - minBackoff)) + minBackoff;
    waitDuration = Math.pow(2, retriesSoFar) * randomBackoff;
    return Math.min(waitDuration, MaxBackoff);
}
//# sourceMappingURL=RetryPolicy.js.map

/***/ }),
/* 88 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.appInsightsClientFactory = void 0;
const applicationinsights_common_1 = __webpack_require__(89);
const util_1 = __webpack_require__(25);
const appInsightsClientFactory = async (key, xhrOverride, replacementOptions) => {
    let appInsightsClient;
    try {
        const basicAISDK = await Promise.resolve().then(() => __importStar(__webpack_require__(118)));
        const extensionConfig = {};
        if (xhrOverride) {
            // Configure the channel to use a XHR Request override since it's not available in node
            const channelConfig = {
                alwaysUseXhrOverride: true,
                httpXHROverride: xhrOverride
            };
            extensionConfig[applicationinsights_common_1.BreezeChannelIdentifier] = channelConfig;
        }
        appInsightsClient = new basicAISDK.ApplicationInsights({
            instrumentationKey: key,
            disableAjaxTracking: true,
            disableExceptionTracking: true,
            disableFetchTracking: true,
            disableCorrelationHeaders: true,
            disableCookiesUsage: true,
            autoTrackPageVisitTime: false,
            emitLineDelimitedJson: false,
            disableInstrumentationKeyValidation: true,
            extensionConfig,
        });
    }
    catch (e) {
        return Promise.reject(e);
    }
    // Sets the appinsights client into a standardized form
    const telemetryClient = {
        logEvent: (eventName, data) => {
            const properties = { ...data?.properties, ...data?.measurements };
            if (replacementOptions?.length) {
                util_1.TelemetryUtil.applyReplacements(properties, replacementOptions);
            }
            appInsightsClient?.track({
                name: eventName,
                data: properties,
                baseType: "EventData",
                baseData: { name: eventName, properties: data?.properties, measurements: data?.measurements }
            });
        },
        flush: async () => {
            appInsightsClient?.flush(false);
        },
        dispose: async () => {
            const unloadPromise = new Promise((resolve) => {
                appInsightsClient?.unload(true, () => {
                    resolve();
                    appInsightsClient = undefined;
                }, 1000);
            });
            return unloadPromise;
        }
    };
    return telemetryClient;
};
exports.appInsightsClientFactory = appInsightsClientFactory;
//# sourceMappingURL=appInsightsClientFactory.js.map

/***/ }),
/* 89 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AnalyticsPluginIdentifier": () => (/* binding */ AnalyticsPluginIdentifier),
/* harmony export */   "BreezeChannelIdentifier": () => (/* binding */ BreezeChannelIdentifier),
/* harmony export */   "ConfigurationManager": () => (/* reexport safe */ _Interfaces_IConfig__WEBPACK_IMPORTED_MODULE_15__.ConfigurationManager),
/* harmony export */   "ConnectionStringParser": () => (/* reexport safe */ _ConnectionStringParser__WEBPACK_IMPORTED_MODULE_2__.ConnectionStringParser),
/* harmony export */   "ContextTagKeys": () => (/* reexport safe */ _Interfaces_Contracts_ContextTagKeys__WEBPACK_IMPORTED_MODULE_16__.ContextTagKeys),
/* harmony export */   "CtxTagKeys": () => (/* reexport safe */ _Interfaces_PartAExtensions__WEBPACK_IMPORTED_MODULE_19__.CtxTagKeys),
/* harmony export */   "DEFAULT_BREEZE_ENDPOINT": () => (/* reexport safe */ _Constants__WEBPACK_IMPORTED_MODULE_4__.DEFAULT_BREEZE_ENDPOINT),
/* harmony export */   "DEFAULT_BREEZE_PATH": () => (/* reexport safe */ _Constants__WEBPACK_IMPORTED_MODULE_4__.DEFAULT_BREEZE_PATH),
/* harmony export */   "Data": () => (/* reexport safe */ _Telemetry_Common_Data__WEBPACK_IMPORTED_MODULE_13__.Data),
/* harmony export */   "DisabledPropertyName": () => (/* reexport safe */ _Constants__WEBPACK_IMPORTED_MODULE_4__.DisabledPropertyName),
/* harmony export */   "DistributedTracingModes": () => (/* reexport safe */ _Enums__WEBPACK_IMPORTED_MODULE_20__.DistributedTracingModes),
/* harmony export */   "Envelope": () => (/* reexport safe */ _Telemetry_Common_Envelope__WEBPACK_IMPORTED_MODULE_5__.Envelope),
/* harmony export */   "Event": () => (/* reexport safe */ _Telemetry_Event__WEBPACK_IMPORTED_MODULE_6__.Event),
/* harmony export */   "EventPersistence": () => (/* reexport safe */ _Enums__WEBPACK_IMPORTED_MODULE_20__.EventPersistence),
/* harmony export */   "Exception": () => (/* reexport safe */ _Telemetry_Exception__WEBPACK_IMPORTED_MODULE_7__.Exception),
/* harmony export */   "Extensions": () => (/* reexport safe */ _Interfaces_PartAExtensions__WEBPACK_IMPORTED_MODULE_19__.Extensions),
/* harmony export */   "HttpMethod": () => (/* reexport safe */ _Constants__WEBPACK_IMPORTED_MODULE_4__.HttpMethod),
/* harmony export */   "Metric": () => (/* reexport safe */ _Telemetry_Metric__WEBPACK_IMPORTED_MODULE_8__.Metric),
/* harmony export */   "PageView": () => (/* reexport safe */ _Telemetry_PageView__WEBPACK_IMPORTED_MODULE_9__.PageView),
/* harmony export */   "PageViewPerformance": () => (/* reexport safe */ _Telemetry_PageViewPerformance__WEBPACK_IMPORTED_MODULE_12__.PageViewPerformance),
/* harmony export */   "ProcessLegacy": () => (/* reexport safe */ _Constants__WEBPACK_IMPORTED_MODULE_4__.ProcessLegacy),
/* harmony export */   "PropertiesPluginIdentifier": () => (/* binding */ PropertiesPluginIdentifier),
/* harmony export */   "RemoteDependencyData": () => (/* reexport safe */ _Telemetry_RemoteDependencyData__WEBPACK_IMPORTED_MODULE_10__.RemoteDependencyData),
/* harmony export */   "RequestHeaders": () => (/* reexport safe */ _RequestResponseHeaders__WEBPACK_IMPORTED_MODULE_3__.RequestHeaders),
/* harmony export */   "SampleRate": () => (/* reexport safe */ _Constants__WEBPACK_IMPORTED_MODULE_4__.SampleRate),
/* harmony export */   "SeverityLevel": () => (/* reexport safe */ _Interfaces_Contracts_SeverityLevel__WEBPACK_IMPORTED_MODULE_14__.SeverityLevel),
/* harmony export */   "TelemetryItemCreator": () => (/* reexport safe */ _TelemetryItemCreator__WEBPACK_IMPORTED_MODULE_18__.TelemetryItemCreator),
/* harmony export */   "ThrottleMgr": () => (/* reexport safe */ _ThrottleMgr__WEBPACK_IMPORTED_MODULE_1__.ThrottleMgr),
/* harmony export */   "Trace": () => (/* reexport safe */ _Telemetry_Trace__WEBPACK_IMPORTED_MODULE_11__.Trace),
/* harmony export */   "correlationIdCanIncludeCorrelationHeader": () => (/* reexport safe */ _Util__WEBPACK_IMPORTED_MODULE_0__.correlationIdCanIncludeCorrelationHeader),
/* harmony export */   "correlationIdGetCorrelationContext": () => (/* reexport safe */ _Util__WEBPACK_IMPORTED_MODULE_0__.correlationIdGetCorrelationContext),
/* harmony export */   "correlationIdGetCorrelationContextValue": () => (/* reexport safe */ _Util__WEBPACK_IMPORTED_MODULE_0__.correlationIdGetCorrelationContextValue),
/* harmony export */   "correlationIdGetPrefix": () => (/* reexport safe */ _Util__WEBPACK_IMPORTED_MODULE_0__.correlationIdGetPrefix),
/* harmony export */   "correlationIdSetPrefix": () => (/* reexport safe */ _Util__WEBPACK_IMPORTED_MODULE_0__.correlationIdSetPrefix),
/* harmony export */   "createDistributedTraceContextFromTrace": () => (/* reexport safe */ _Util__WEBPACK_IMPORTED_MODULE_0__.createDistributedTraceContextFromTrace),
/* harmony export */   "createDomEvent": () => (/* reexport safe */ _DomHelperFuncs__WEBPACK_IMPORTED_MODULE_24__.createDomEvent),
/* harmony export */   "createOfflineListener": () => (/* reexport safe */ _Offline__WEBPACK_IMPORTED_MODULE_27__.createOfflineListener),
/* harmony export */   "createTelemetryItem": () => (/* reexport safe */ _TelemetryItemCreator__WEBPACK_IMPORTED_MODULE_18__.createTelemetryItem),
/* harmony export */   "createTraceParent": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_23__.createTraceParent),
/* harmony export */   "dataSanitizeException": () => (/* reexport safe */ _Telemetry_Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_17__.dataSanitizeException),
/* harmony export */   "dataSanitizeId": () => (/* reexport safe */ _Telemetry_Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_17__.dataSanitizeId),
/* harmony export */   "dataSanitizeInput": () => (/* reexport safe */ _Telemetry_Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_17__.dataSanitizeInput),
/* harmony export */   "dataSanitizeKey": () => (/* reexport safe */ _Telemetry_Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_17__.dataSanitizeKey),
/* harmony export */   "dataSanitizeKeyAndAddUniqueness": () => (/* reexport safe */ _Telemetry_Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_17__.dataSanitizeKeyAndAddUniqueness),
/* harmony export */   "dataSanitizeMeasurements": () => (/* reexport safe */ _Telemetry_Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_17__.dataSanitizeMeasurements),
/* harmony export */   "dataSanitizeMessage": () => (/* reexport safe */ _Telemetry_Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_17__.dataSanitizeMessage),
/* harmony export */   "dataSanitizeProperties": () => (/* reexport safe */ _Telemetry_Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_17__.dataSanitizeProperties),
/* harmony export */   "dataSanitizeString": () => (/* reexport safe */ _Telemetry_Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_17__.dataSanitizeString),
/* harmony export */   "dataSanitizeUrl": () => (/* reexport safe */ _Telemetry_Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_17__.dataSanitizeUrl),
/* harmony export */   "dateTimeUtilsDuration": () => (/* reexport safe */ _Util__WEBPACK_IMPORTED_MODULE_0__.dateTimeUtilsDuration),
/* harmony export */   "dateTimeUtilsNow": () => (/* reexport safe */ _Util__WEBPACK_IMPORTED_MODULE_0__.dateTimeUtilsNow),
/* harmony export */   "dsPadNumber": () => (/* reexport safe */ _Telemetry_Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_17__.dsPadNumber),
/* harmony export */   "findW3cTraceParent": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_23__.findW3cTraceParent),
/* harmony export */   "formatTraceParent": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_23__.formatTraceParent),
/* harmony export */   "getExtensionByName": () => (/* reexport safe */ _HelperFuncs__WEBPACK_IMPORTED_MODULE_21__.getExtensionByName),
/* harmony export */   "isBeaconApiSupported": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_22__.isBeaconsSupported),
/* harmony export */   "isCrossOriginError": () => (/* reexport safe */ _HelperFuncs__WEBPACK_IMPORTED_MODULE_21__.isCrossOriginError),
/* harmony export */   "isInternalApplicationInsightsEndpoint": () => (/* reexport safe */ _Util__WEBPACK_IMPORTED_MODULE_0__.isInternalApplicationInsightsEndpoint),
/* harmony export */   "isSampledFlag": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_23__.isSampledFlag),
/* harmony export */   "isValidSpanId": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_23__.isValidSpanId),
/* harmony export */   "isValidTraceId": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_23__.isValidTraceId),
/* harmony export */   "isValidTraceParent": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_23__.isValidTraceParent),
/* harmony export */   "msToTimeSpan": () => (/* reexport safe */ _HelperFuncs__WEBPACK_IMPORTED_MODULE_21__.msToTimeSpan),
/* harmony export */   "parseConnectionString": () => (/* reexport safe */ _ConnectionStringParser__WEBPACK_IMPORTED_MODULE_2__.parseConnectionString),
/* harmony export */   "parseTraceParent": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_23__.parseTraceParent),
/* harmony export */   "strNotSpecified": () => (/* reexport safe */ _Constants__WEBPACK_IMPORTED_MODULE_4__.strNotSpecified),
/* harmony export */   "stringToBoolOrDefault": () => (/* reexport safe */ _HelperFuncs__WEBPACK_IMPORTED_MODULE_21__.stringToBoolOrDefault),
/* harmony export */   "urlGetAbsoluteUrl": () => (/* reexport safe */ _UrlHelperFuncs__WEBPACK_IMPORTED_MODULE_26__.urlGetAbsoluteUrl),
/* harmony export */   "urlGetCompleteUrl": () => (/* reexport safe */ _UrlHelperFuncs__WEBPACK_IMPORTED_MODULE_26__.urlGetCompleteUrl),
/* harmony export */   "urlGetPathName": () => (/* reexport safe */ _UrlHelperFuncs__WEBPACK_IMPORTED_MODULE_26__.urlGetPathName),
/* harmony export */   "urlParseFullHost": () => (/* reexport safe */ _UrlHelperFuncs__WEBPACK_IMPORTED_MODULE_26__.urlParseFullHost),
/* harmony export */   "urlParseHost": () => (/* reexport safe */ _UrlHelperFuncs__WEBPACK_IMPORTED_MODULE_26__.urlParseHost),
/* harmony export */   "urlParseUrl": () => (/* reexport safe */ _UrlHelperFuncs__WEBPACK_IMPORTED_MODULE_26__.urlParseUrl),
/* harmony export */   "utlCanUseLocalStorage": () => (/* reexport safe */ _StorageHelperFuncs__WEBPACK_IMPORTED_MODULE_25__.utlCanUseLocalStorage),
/* harmony export */   "utlCanUseSessionStorage": () => (/* reexport safe */ _StorageHelperFuncs__WEBPACK_IMPORTED_MODULE_25__.utlCanUseSessionStorage),
/* harmony export */   "utlDisableStorage": () => (/* reexport safe */ _StorageHelperFuncs__WEBPACK_IMPORTED_MODULE_25__.utlDisableStorage),
/* harmony export */   "utlEnableStorage": () => (/* reexport safe */ _StorageHelperFuncs__WEBPACK_IMPORTED_MODULE_25__.utlEnableStorage),
/* harmony export */   "utlGetLocalStorage": () => (/* reexport safe */ _StorageHelperFuncs__WEBPACK_IMPORTED_MODULE_25__.utlGetLocalStorage),
/* harmony export */   "utlGetSessionStorage": () => (/* reexport safe */ _StorageHelperFuncs__WEBPACK_IMPORTED_MODULE_25__.utlGetSessionStorage),
/* harmony export */   "utlGetSessionStorageKeys": () => (/* reexport safe */ _StorageHelperFuncs__WEBPACK_IMPORTED_MODULE_25__.utlGetSessionStorageKeys),
/* harmony export */   "utlRemoveSessionStorage": () => (/* reexport safe */ _StorageHelperFuncs__WEBPACK_IMPORTED_MODULE_25__.utlRemoveSessionStorage),
/* harmony export */   "utlRemoveStorage": () => (/* reexport safe */ _StorageHelperFuncs__WEBPACK_IMPORTED_MODULE_25__.utlRemoveStorage),
/* harmony export */   "utlSetLocalStorage": () => (/* reexport safe */ _StorageHelperFuncs__WEBPACK_IMPORTED_MODULE_25__.utlSetLocalStorage),
/* harmony export */   "utlSetSessionStorage": () => (/* reexport safe */ _StorageHelperFuncs__WEBPACK_IMPORTED_MODULE_25__.utlSetSessionStorage),
/* harmony export */   "utlSetStoragePrefix": () => (/* reexport safe */ _StorageHelperFuncs__WEBPACK_IMPORTED_MODULE_25__.utlSetStoragePrefix)
/* harmony export */ });
/* harmony import */ var _Util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(90);
/* harmony import */ var _ThrottleMgr__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96);
/* harmony import */ var _ConnectionStringParser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(99);
/* harmony import */ var _RequestResponseHeaders__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(94);
/* harmony import */ var _Constants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(91);
/* harmony import */ var _Telemetry_Common_Envelope__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(100);
/* harmony import */ var _Telemetry_Event__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(101);
/* harmony import */ var _Telemetry_Exception__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(102);
/* harmony import */ var _Telemetry_Metric__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(103);
/* harmony import */ var _Telemetry_PageView__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(105);
/* harmony import */ var _Telemetry_RemoteDependencyData__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(107);
/* harmony import */ var _Telemetry_Trace__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(108);
/* harmony import */ var _Telemetry_PageViewPerformance__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(109);
/* harmony import */ var _Telemetry_Common_Data__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(110);
/* harmony import */ var _Interfaces_Contracts_SeverityLevel__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(111);
/* harmony import */ var _Interfaces_IConfig__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(112);
/* harmony import */ var _Interfaces_Contracts_ContextTagKeys__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(113);
/* harmony import */ var _Telemetry_Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(95);
/* harmony import */ var _TelemetryItemCreator__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(114);
/* harmony import */ var _Interfaces_PartAExtensions__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(115);
/* harmony import */ var _Enums__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(98);
/* harmony import */ var _HelperFuncs__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(106);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(44);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(63);
/* harmony import */ var _DomHelperFuncs__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(116);
/* harmony import */ var _StorageHelperFuncs__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(97);
/* harmony import */ var _UrlHelperFuncs__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(93);
/* harmony import */ var _Offline__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(117);
/*
 * Application Insights JavaScript SDK - Common, 3.3.0
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */

// Licensed under the



























var PropertiesPluginIdentifier = "AppInsightsPropertiesPlugin";
var BreezeChannelIdentifier = "AppInsightsChannelPlugin";
var AnalyticsPluginIdentifier = "ApplicationInsightsAnalytics";
//# sourceMappingURL=applicationinsights-common.js.map

/***/ }),
/* 90 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AjaxHelperParseDependencyPath": () => (/* binding */ AjaxHelperParseDependencyPath),
/* harmony export */   "correlationIdCanIncludeCorrelationHeader": () => (/* binding */ correlationIdCanIncludeCorrelationHeader),
/* harmony export */   "correlationIdGetCorrelationContext": () => (/* binding */ correlationIdGetCorrelationContext),
/* harmony export */   "correlationIdGetCorrelationContextValue": () => (/* binding */ correlationIdGetCorrelationContextValue),
/* harmony export */   "correlationIdGetPrefix": () => (/* binding */ correlationIdGetPrefix),
/* harmony export */   "correlationIdSetPrefix": () => (/* binding */ correlationIdSetPrefix),
/* harmony export */   "createDistributedTraceContextFromTrace": () => (/* binding */ createDistributedTraceContextFromTrace),
/* harmony export */   "dateTimeUtilsDuration": () => (/* binding */ dateTimeUtilsDuration),
/* harmony export */   "dateTimeUtilsNow": () => (/* binding */ dateTimeUtilsNow),
/* harmony export */   "isInternalApplicationInsightsEndpoint": () => (/* binding */ isInternalApplicationInsightsEndpoint)
/* harmony export */ });
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(30);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(63);
/* harmony import */ var _Constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(91);
/* harmony import */ var _RequestResponseHeaders__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(94);
/* harmony import */ var _Telemetry_Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(95);
/* harmony import */ var _UrlHelperFuncs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(93);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(92);
/*
 * Application Insights JavaScript SDK - Common, 3.3.0
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */









// listing only non-geo specific locations
var _internalEndpoints = [
    _Constants__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_BREEZE_ENDPOINT + _Constants__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_BREEZE_PATH,
    "https://breeze.aimon.applicationinsights.io" + _Constants__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_BREEZE_PATH,
    "https://dc-int.services.visualstudio.com" + _Constants__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_BREEZE_PATH
];
var _correlationIdPrefix = "cid-v1:";
function isInternalApplicationInsightsEndpoint(endpointUrl) {
    return (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.arrIndexOf)(_internalEndpoints, endpointUrl[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_TO_LOWER_CASE /* @min:%2etoLowerCase */]()) !== -1;
}
function correlationIdSetPrefix(prefix) {
    _correlationIdPrefix = prefix;
}
function correlationIdGetPrefix() {
    return _correlationIdPrefix;
}
/**
 * Checks if a request url is not on a excluded domain list and if it is safe to add correlation headers.
 * Headers are always included if the current domain matches the request domain. If they do not match (CORS),
 * they are regex-ed across correlationHeaderDomains and correlationHeaderExcludedDomains to determine if headers are included.
 * Some environments don't give information on currentHost via window.location.host (e.g. Cordova). In these cases, the user must
 * manually supply domains to include correlation headers on. Else, no headers will be included at all.
 */
function correlationIdCanIncludeCorrelationHeader(config, requestUrl, currentHost) {
    if (!requestUrl || (config && config.disableCorrelationHeaders)) {
        return false;
    }
    if (config && config[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_CORRELATION_HEADER_E0 /* @min:%2ecorrelationHeaderExcludePatterns */]) {
        for (var i = 0; i < config.correlationHeaderExcludePatterns[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_LENGTH /* @min:%2elength */]; i++) {
            if (config[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_CORRELATION_HEADER_E0 /* @min:%2ecorrelationHeaderExcludePatterns */][i].test(requestUrl)) {
                return false;
            }
        }
    }
    var requestHost = (0,_UrlHelperFuncs__WEBPACK_IMPORTED_MODULE_3__.urlParseUrl)(requestUrl).host[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_TO_LOWER_CASE /* @min:%2etoLowerCase */]();
    if (requestHost && ((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.strIndexOf)(requestHost, ":443") !== -1 || (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.strIndexOf)(requestHost, ":80") !== -1)) {
        // [Bug #1260] IE can include the port even for http and https URLs so if present
        // try and parse it to remove if it matches the default protocol port
        requestHost = ((0,_UrlHelperFuncs__WEBPACK_IMPORTED_MODULE_3__.urlParseFullHost)(requestUrl, true) || "")[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_TO_LOWER_CASE /* @min:%2etoLowerCase */]();
    }
    if ((!config || !config.enableCorsCorrelation) && (requestHost && requestHost !== currentHost)) {
        return false;
    }
    var includedDomains = config && config.correlationHeaderDomains;
    if (includedDomains) {
        var matchExists_1;
        (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.arrForEach)(includedDomains, function (domain) {
            var regex = new RegExp(domain.toLowerCase().replace(/\\/g, "\\\\").replace(/\./g, "\\.").replace(/\*/g, ".*"));
            matchExists_1 = matchExists_1 || regex.test(requestHost);
        });
        if (!matchExists_1) {
            return false;
        }
    }
    var excludedDomains = config && config.correlationHeaderExcludedDomains;
    if (!excludedDomains || excludedDomains[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_LENGTH /* @min:%2elength */] === 0) {
        return true;
    }
    for (var i = 0; i < excludedDomains[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_LENGTH /* @min:%2elength */]; i++) {
        var regex = new RegExp(excludedDomains[i].toLowerCase().replace(/\\/g, "\\\\").replace(/\./g, "\\.").replace(/\*/g, ".*"));
        if (regex.test(requestHost)) {
            return false;
        }
    }
    // if we don't know anything about the requestHost, require the user to use included/excludedDomains.
    // Previously we always returned false for a falsy requestHost
    return requestHost && requestHost[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_LENGTH /* @min:%2elength */] > 0;
}
/**
 * Combines target appId and target role name from response header.
 */
function correlationIdGetCorrelationContext(responseHeader) {
    if (responseHeader) {
        var correlationId = correlationIdGetCorrelationContextValue(responseHeader, _RequestResponseHeaders__WEBPACK_IMPORTED_MODULE_4__.RequestHeaders[1]);
        if (correlationId && correlationId !== _correlationIdPrefix) {
            return correlationId;
        }
    }
}
/**
 * Gets key from correlation response header
 */
function correlationIdGetCorrelationContextValue(responseHeader, key) {
    if (responseHeader) {
        var keyValues = responseHeader[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_SPLIT /* @min:%2esplit */](",");
        for (var i = 0; i < keyValues[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_LENGTH /* @min:%2elength */]; ++i) {
            var keyValue = keyValues[i][_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_SPLIT /* @min:%2esplit */]("=");
            if (keyValue[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_LENGTH /* @min:%2elength */] === 2 && keyValue[0] === key) {
                return keyValue[1];
            }
        }
    }
}
function AjaxHelperParseDependencyPath(logger, absoluteUrl, method, commandName) {
    var target, name = commandName, data = commandName;
    if (absoluteUrl && absoluteUrl[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_LENGTH /* @min:%2elength */] > 0) {
        var parsedUrl = (0,_UrlHelperFuncs__WEBPACK_IMPORTED_MODULE_3__.urlParseUrl)(absoluteUrl);
        target = parsedUrl.host;
        if (!name) {
            if (parsedUrl[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_PATHNAME /* @min:%2epathname */] != null) {
                var pathName = (parsedUrl.pathname[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_LENGTH /* @min:%2elength */] === 0) ? "/" : parsedUrl[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_PATHNAME /* @min:%2epathname */];
                if (pathName.charAt(0) !== "/") {
                    pathName = "/" + pathName;
                }
                data = parsedUrl[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_PATHNAME /* @min:%2epathname */];
                name = (0,_Telemetry_Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_5__.dataSanitizeString)(logger, method ? method + " " + pathName : pathName);
            }
            else {
                name = (0,_Telemetry_Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_5__.dataSanitizeString)(logger, absoluteUrl);
            }
        }
    }
    else {
        target = commandName;
        name = commandName;
    }
    return {
        target: target,
        name: name,
        data: data
    };
}
function dateTimeUtilsNow() {
    // returns the window or webworker performance object
    var perf = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.getPerformance)();
    if (perf && perf.now && perf.timing) {
        var now = perf.now() + perf.timing.navigationStart;
        // Known issue with IE where this calculation can be negative, so if it is then ignore and fallback
        if (now > 0) {
            return now;
        }
    }
    return (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.utcNow)();
}
function dateTimeUtilsDuration(start, end) {
    var result = null;
    if (start !== 0 && end !== 0 && !(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(start) && !(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(end)) {
        result = end - start;
    }
    return result;
}
/**
 * Creates a IDistributedTraceContext from an optional telemetryTrace
 * @param telemetryTrace - The telemetryTrace instance that is being wrapped
 * @param parentCtx - An optional parent distributed trace instance, almost always undefined as this scenario is only used in the case of multiple property handlers.
 * @returns A new IDistributedTraceContext instance that is backed by the telemetryTrace or temporary object
 */
function createDistributedTraceContextFromTrace(telemetryTrace, parentCtx) {
    var trace = telemetryTrace || {};
    return {
        getName: function () {
            return trace[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_NAME /* @min:%2ename */];
        },
        setName: function (newValue) {
            parentCtx && parentCtx.setName(newValue);
            trace[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_NAME /* @min:%2ename */] = newValue;
        },
        getTraceId: function () {
            return trace.traceID;
        },
        setTraceId: function (newValue) {
            parentCtx && parentCtx.setTraceId(newValue);
            if ((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_6__.isValidTraceId)(newValue)) {
                trace.traceID = newValue;
            }
        },
        getSpanId: function () {
            return trace.parentID;
        },
        setSpanId: function (newValue) {
            parentCtx && parentCtx.setSpanId(newValue);
            if ((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_6__.isValidSpanId)(newValue)) {
                trace.parentID = newValue;
            }
        },
        getTraceFlags: function () {
            return trace.traceFlags;
        },
        setTraceFlags: function (newTraceFlags) {
            parentCtx && parentCtx.setTraceFlags(newTraceFlags);
            trace.traceFlags = newTraceFlags;
        }
    };
}
//# sourceMappingURL=Util.js.map

/***/ }),
/* 91 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DEFAULT_BREEZE_ENDPOINT": () => (/* binding */ DEFAULT_BREEZE_ENDPOINT),
/* harmony export */   "DEFAULT_BREEZE_PATH": () => (/* binding */ DEFAULT_BREEZE_PATH),
/* harmony export */   "DisabledPropertyName": () => (/* binding */ DisabledPropertyName),
/* harmony export */   "HttpMethod": () => (/* binding */ HttpMethod),
/* harmony export */   "ProcessLegacy": () => (/* binding */ ProcessLegacy),
/* harmony export */   "SampleRate": () => (/* binding */ SampleRate),
/* harmony export */   "strIkey": () => (/* binding */ strIkey),
/* harmony export */   "strNotSpecified": () => (/* binding */ strNotSpecified)
/* harmony export */ });
/*
 * Application Insights JavaScript SDK - Common, 3.3.0
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */


/**
 * This is an internal property used to cause internal (reporting) requests to be ignored from reporting
 * additional telemetry, to handle polyfil implementations ALL urls used with a disabled request will
 * also be ignored for future requests even when this property is not provided.
 * Tagging as Ignore as this is an internal value and is not expected to be used outside of the SDK
 * @ignore
 */
var DisabledPropertyName = "Microsoft_ApplicationInsights_BypassAjaxInstrumentation";
var SampleRate = "sampleRate";
var ProcessLegacy = "ProcessLegacy";
var HttpMethod = "http.method";
var DEFAULT_BREEZE_ENDPOINT = "https://dc.services.visualstudio.com";
var DEFAULT_BREEZE_PATH = "/v2/track";
var strNotSpecified = "not_specified";
var strIkey = "iKey";
//# sourceMappingURL=Constants.js.map

/***/ }),
/* 92 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "_DYN_ASSEMBLY": () => (/* binding */ _DYN_ASSEMBLY),
/* harmony export */   "_DYN_CORRELATION_HEADER_E0": () => (/* binding */ _DYN_CORRELATION_HEADER_E0),
/* harmony export */   "_DYN_COUNT": () => (/* binding */ _DYN_COUNT),
/* harmony export */   "_DYN_DATE": () => (/* binding */ _DYN_DATE),
/* harmony export */   "_DYN_DAYS_OF_MONTH": () => (/* binding */ _DYN_DAYS_OF_MONTH),
/* harmony export */   "_DYN_DISABLED": () => (/* binding */ _DYN_DISABLED),
/* harmony export */   "_DYN_DURATION": () => (/* binding */ _DYN_DURATION),
/* harmony export */   "_DYN_EXCEPTIONS": () => (/* binding */ _DYN_EXCEPTIONS),
/* harmony export */   "_DYN_EXTENSION_CONFIG": () => (/* binding */ _DYN_EXTENSION_CONFIG),
/* harmony export */   "_DYN_FILE_NAME": () => (/* binding */ _DYN_FILE_NAME),
/* harmony export */   "_DYN_GET_UTCDATE": () => (/* binding */ _DYN_GET_UTCDATE),
/* harmony export */   "_DYN_HAS_FULL_STACK": () => (/* binding */ _DYN_HAS_FULL_STACK),
/* harmony export */   "_DYN_INGESTIONENDPOINT": () => (/* binding */ _DYN_INGESTIONENDPOINT),
/* harmony export */   "_DYN_INTERVAL": () => (/* binding */ _DYN_INTERVAL),
/* harmony export */   "_DYN_IS_MANUAL": () => (/* binding */ _DYN_IS_MANUAL),
/* harmony export */   "_DYN_LENGTH": () => (/* binding */ _DYN_LENGTH),
/* harmony export */   "_DYN_LEVEL": () => (/* binding */ _DYN_LEVEL),
/* harmony export */   "_DYN_LINE": () => (/* binding */ _DYN_LINE),
/* harmony export */   "_DYN_MEASUREMENTS": () => (/* binding */ _DYN_MEASUREMENTS),
/* harmony export */   "_DYN_MESSAGE": () => (/* binding */ _DYN_MESSAGE),
/* harmony export */   "_DYN_METHOD": () => (/* binding */ _DYN_METHOD),
/* harmony export */   "_DYN_NAME": () => (/* binding */ _DYN_NAME),
/* harmony export */   "_DYN_PARSED_STACK": () => (/* binding */ _DYN_PARSED_STACK),
/* harmony export */   "_DYN_PATHNAME": () => (/* binding */ _DYN_PATHNAME),
/* harmony export */   "_DYN_PRE_TRIGGER_DATE": () => (/* binding */ _DYN_PRE_TRIGGER_DATE),
/* harmony export */   "_DYN_PROBLEM_GROUP": () => (/* binding */ _DYN_PROBLEM_GROUP),
/* harmony export */   "_DYN_PROPERTIES": () => (/* binding */ _DYN_PROPERTIES),
/* harmony export */   "_DYN_PUSH": () => (/* binding */ _DYN_PUSH),
/* harmony export */   "_DYN_RECEIVED_RESPONSE": () => (/* binding */ _DYN_RECEIVED_RESPONSE),
/* harmony export */   "_DYN_REMOVE_ITEM": () => (/* binding */ _DYN_REMOVE_ITEM),
/* harmony export */   "_DYN_SEVERITY_LEVEL": () => (/* binding */ _DYN_SEVERITY_LEVEL),
/* harmony export */   "_DYN_SIZE_IN_BYTES": () => (/* binding */ _DYN_SIZE_IN_BYTES),
/* harmony export */   "_DYN_SPLIT": () => (/* binding */ _DYN_SPLIT),
/* harmony export */   "_DYN_STRINGIFY": () => (/* binding */ _DYN_STRINGIFY),
/* harmony export */   "_DYN_TO_LOWER_CASE": () => (/* binding */ _DYN_TO_LOWER_CASE),
/* harmony export */   "_DYN_TO_STRING": () => (/* binding */ _DYN_TO_STRING),
/* harmony export */   "_DYN_TYPE_NAME": () => (/* binding */ _DYN_TYPE_NAME),
/* harmony export */   "_DYN__CREATE_FROM_INTERFA1": () => (/* binding */ _DYN__CREATE_FROM_INTERFA1)
/* harmony export */ });
/*
 * Application Insights JavaScript SDK - Common, 3.3.0
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */


// @skip-file-minify
// ##############################################################
// AUTO GENERATED FILE: This file is Auto Generated during build.
// ##############################################################
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// Note: DON'T Export these const from the package as we are still targeting ES3 this will export a mutable variables that someone could change!!!
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
var _DYN_SPLIT = "split"; // Count: 6
var _DYN_LENGTH = "length"; // Count: 41
var _DYN_TO_LOWER_CASE = "toLowerCase"; // Count: 6
var _DYN_INGESTIONENDPOINT = "ingestionendpoint"; // Count: 6
var _DYN_TO_STRING = "toString"; // Count: 9
var _DYN_PUSH = "push"; // Count: 5
var _DYN_REMOVE_ITEM = "removeItem"; // Count: 3
var _DYN_NAME = "name"; // Count: 11
var _DYN_MESSAGE = "message"; // Count: 10
var _DYN_COUNT = "count"; // Count: 8
var _DYN_PRE_TRIGGER_DATE = "preTriggerDate"; // Count: 4
var _DYN_DISABLED = "disabled"; // Count: 3
var _DYN_INTERVAL = "interval"; // Count: 3
var _DYN_DAYS_OF_MONTH = "daysOfMonth"; // Count: 3
var _DYN_DATE = "date"; // Count: 5
var _DYN_GET_UTCDATE = "getUTCDate"; // Count: 3
var _DYN_STRINGIFY = "stringify"; // Count: 4
var _DYN_PATHNAME = "pathname"; // Count: 4
var _DYN_CORRELATION_HEADER_E0 = "correlationHeaderExcludePatterns"; // Count: 2
var _DYN_EXTENSION_CONFIG = "extensionConfig"; // Count: 4
var _DYN_EXCEPTIONS = "exceptions"; // Count: 6
var _DYN_PARSED_STACK = "parsedStack"; // Count: 13
var _DYN_PROPERTIES = "properties"; // Count: 9
var _DYN_MEASUREMENTS = "measurements"; // Count: 9
var _DYN_SIZE_IN_BYTES = "sizeInBytes"; // Count: 11
var _DYN_TYPE_NAME = "typeName"; // Count: 11
var _DYN_SEVERITY_LEVEL = "severityLevel"; // Count: 5
var _DYN_PROBLEM_GROUP = "problemGroup"; // Count: 3
var _DYN_IS_MANUAL = "isManual"; // Count: 3
var _DYN__CREATE_FROM_INTERFA1 = "CreateFromInterface"; // Count: 2
var _DYN_ASSEMBLY = "assembly"; // Count: 7
var _DYN_FILE_NAME = "fileName"; // Count: 8
var _DYN_HAS_FULL_STACK = "hasFullStack"; // Count: 6
var _DYN_LEVEL = "level"; // Count: 5
var _DYN_METHOD = "method"; // Count: 7
var _DYN_LINE = "line"; // Count: 6
var _DYN_DURATION = "duration"; // Count: 4
var _DYN_RECEIVED_RESPONSE = "receivedResponse"; // Count: 2
//# sourceMappingURL=__DynamicConstants.js.map

/***/ }),
/* 93 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "urlGetAbsoluteUrl": () => (/* binding */ urlGetAbsoluteUrl),
/* harmony export */   "urlGetCompleteUrl": () => (/* binding */ urlGetCompleteUrl),
/* harmony export */   "urlGetPathName": () => (/* binding */ urlGetPathName),
/* harmony export */   "urlParseFullHost": () => (/* binding */ urlParseFullHost),
/* harmony export */   "urlParseHost": () => (/* binding */ urlParseHost),
/* harmony export */   "urlParseUrl": () => (/* binding */ urlParseUrl)
/* harmony export */ });
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(30);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(92);
/*
 * Application Insights JavaScript SDK - Common, 3.3.0
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */




var _document = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.getDocument)() || {};
var _htmlAnchorIdx = 0;
// Use an array of temporary values as it's possible for multiple calls to parseUrl() will be called with different URLs
// Using a cache size of 5 for now as it current depth usage is at least 2, so adding a minor buffer to handle future updates
var _htmlAnchorElement = [null, null, null, null, null];
function urlParseUrl(url) {
    var anchorIdx = _htmlAnchorIdx;
    var anchorCache = _htmlAnchorElement;
    var tempAnchor = anchorCache[anchorIdx];
    if (!_document.createElement) {
        // Always create the temp instance if createElement is not available
        tempAnchor = { host: urlParseHost(url, true) };
    }
    else if (!anchorCache[anchorIdx]) {
        // Create and cache the unattached anchor instance
        tempAnchor = anchorCache[anchorIdx] = _document.createElement("a");
    }
    tempAnchor.href = url;
    // Move the cache index forward
    anchorIdx++;
    if (anchorIdx >= anchorCache[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LENGTH /* @min:%2elength */]) {
        anchorIdx = 0;
    }
    _htmlAnchorIdx = anchorIdx;
    return tempAnchor;
}
function urlGetAbsoluteUrl(url) {
    var result;
    var a = urlParseUrl(url);
    if (a) {
        result = a.href;
    }
    return result;
}
function urlGetPathName(url) {
    var result;
    var a = urlParseUrl(url);
    if (a) {
        result = a[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_PATHNAME /* @min:%2epathname */];
    }
    return result;
}
function urlGetCompleteUrl(method, absoluteUrl) {
    if (method) {
        return method.toUpperCase() + " " + absoluteUrl;
    }
    return absoluteUrl;
}
// Fallback method to grab host from url if document.createElement method is not available
function urlParseHost(url, inclPort) {
    var fullHost = urlParseFullHost(url, inclPort) || "";
    if (fullHost) {
        var match = fullHost.match(/(www\d{0,5}\.)?([^\/:]{1,256})(:\d{1,20})?/i);
        if (match != null && match[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LENGTH /* @min:%2elength */] > 3 && (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.isString)(match[2]) && match[2][_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LENGTH /* @min:%2elength */] > 0) {
            return match[2] + (match[3] || "");
        }
    }
    return fullHost;
}
function urlParseFullHost(url, inclPort) {
    var result = null;
    if (url) {
        var match = url.match(/(\w{1,150}):\/\/([^\/:]{1,256})(:\d{1,20})?/i);
        if (match != null && match[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LENGTH /* @min:%2elength */] > 2 && (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.isString)(match[2]) && match[2][_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LENGTH /* @min:%2elength */] > 0) {
            result = match[2] || "";
            if (inclPort && match[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LENGTH /* @min:%2elength */] > 2) {
                var protocol = (match[1] || "")[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_TO_LOWER_CASE /* @min:%2etoLowerCase */]();
                var port = match[3] || "";
                // IE includes the standard port so pass it off if it's the same as the protocol
                if (protocol === "http" && port === ":80") {
                    port = "";
                }
                else if (protocol === "https" && port === ":443") {
                    port = "";
                }
                result += port;
            }
        }
    }
    return result;
}
//# sourceMappingURL=UrlHelperFuncs.js.map

/***/ }),
/* 94 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RequestHeaders": () => (/* binding */ RequestHeaders)
/* harmony export */ });
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(29);
/*
 * Application Insights JavaScript SDK - Common, 3.3.0
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */



var RequestHeaders = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.createValueMap)({
    requestContextHeader: [0 /* eRequestHeaders.requestContextHeader */, "Request-Context"],
    requestContextTargetKey: [1 /* eRequestHeaders.requestContextTargetKey */, "appId"],
    requestContextAppIdFormat: [2 /* eRequestHeaders.requestContextAppIdFormat */, "appId=cid-v1:"],
    requestIdHeader: [3 /* eRequestHeaders.requestIdHeader */, "Request-Id"],
    traceParentHeader: [4 /* eRequestHeaders.traceParentHeader */, "traceparent"],
    traceStateHeader: [5 /* eRequestHeaders.traceStateHeader */, "tracestate"],
    sdkContextHeader: [6 /* eRequestHeaders.sdkContextHeader */, "Sdk-Context"],
    sdkContextHeaderAppIdRequest: [7 /* eRequestHeaders.sdkContextHeaderAppIdRequest */, "appId"],
    requestContextHeaderLowerCase: [8 /* eRequestHeaders.requestContextHeaderLowerCase */, "request-context"]
});
//# sourceMappingURL=RequestResponseHeaders.js.map

/***/ }),
/* 95 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "dataSanitizeException": () => (/* binding */ dataSanitizeException),
/* harmony export */   "dataSanitizeId": () => (/* binding */ dataSanitizeId),
/* harmony export */   "dataSanitizeInput": () => (/* binding */ dataSanitizeInput),
/* harmony export */   "dataSanitizeKey": () => (/* binding */ dataSanitizeKey),
/* harmony export */   "dataSanitizeKeyAndAddUniqueness": () => (/* binding */ dataSanitizeKeyAndAddUniqueness),
/* harmony export */   "dataSanitizeMeasurements": () => (/* binding */ dataSanitizeMeasurements),
/* harmony export */   "dataSanitizeMessage": () => (/* binding */ dataSanitizeMessage),
/* harmony export */   "dataSanitizeProperties": () => (/* binding */ dataSanitizeProperties),
/* harmony export */   "dataSanitizeString": () => (/* binding */ dataSanitizeString),
/* harmony export */   "dataSanitizeUrl": () => (/* binding */ dataSanitizeUrl),
/* harmony export */   "dsPadNumber": () => (/* binding */ dsPadNumber)
/* harmony export */ });
/* harmony import */ var _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(30);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(50);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(44);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(92);
/*
 * Application Insights JavaScript SDK - Common, 3.3.0
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */





function dataSanitizeKeyAndAddUniqueness(logger, key, map) {
    var origLength = key[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_LENGTH /* @min:%2elength */];
    var field = dataSanitizeKey(logger, key);
    // validation truncated the length.  We need to add uniqueness
    if (field[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_LENGTH /* @min:%2elength */] !== origLength) {
        var i = 0;
        var uniqueField = field;
        while (map[uniqueField] !== undefined) {
            i++;
            uniqueField = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.strSubstring)(field, 0, 150 /* DataSanitizerValues.MAX_NAME_LENGTH */ - 3) + dsPadNumber(i);
        }
        field = uniqueField;
    }
    return field;
}
function dataSanitizeKey(logger, name) {
    var nameTrunc;
    if (name) {
        // Remove any leading or trailing whitespace
        name = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.strTrim)((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.asString)(name));
        // truncate the string to 150 chars
        if (name[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_LENGTH /* @min:%2elength */] > 150 /* DataSanitizerValues.MAX_NAME_LENGTH */) {
            nameTrunc = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.strSubstring)(name, 0, 150 /* DataSanitizerValues.MAX_NAME_LENGTH */);
            (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__._throwInternal)(logger, 2 /* eLoggingSeverity.WARNING */, 57 /* _eInternalMessageId.NameTooLong */, "name is too long.  It has been truncated to " + 150 /* DataSanitizerValues.MAX_NAME_LENGTH */ + " characters.", { name: name }, true);
        }
    }
    return nameTrunc || name;
}
function dataSanitizeString(logger, value, maxLength) {
    if (maxLength === void 0) { maxLength = 1024 /* DataSanitizerValues.MAX_STRING_LENGTH */; }
    var valueTrunc;
    if (value) {
        maxLength = maxLength ? maxLength : 1024 /* DataSanitizerValues.MAX_STRING_LENGTH */; // in case default parameters dont work
        value = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.strTrim)((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.asString)(value));
        if (value[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_LENGTH /* @min:%2elength */] > maxLength) {
            valueTrunc = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.strSubstring)(value, 0, maxLength);
            (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__._throwInternal)(logger, 2 /* eLoggingSeverity.WARNING */, 61 /* _eInternalMessageId.StringValueTooLong */, "string value is too long. It has been truncated to " + maxLength + " characters.", { value: value }, true);
        }
    }
    return valueTrunc || value;
}
function dataSanitizeUrl(logger, url) {
    return dataSanitizeInput(logger, url, 2048 /* DataSanitizerValues.MAX_URL_LENGTH */, 66 /* _eInternalMessageId.UrlTooLong */);
}
function dataSanitizeMessage(logger, message) {
    var messageTrunc;
    if (message) {
        if (message[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_LENGTH /* @min:%2elength */] > 32768 /* DataSanitizerValues.MAX_MESSAGE_LENGTH */) {
            messageTrunc = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.strSubstring)(message, 0, 32768 /* DataSanitizerValues.MAX_MESSAGE_LENGTH */);
            (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__._throwInternal)(logger, 2 /* eLoggingSeverity.WARNING */, 56 /* _eInternalMessageId.MessageTruncated */, "message is too long, it has been truncated to " + 32768 /* DataSanitizerValues.MAX_MESSAGE_LENGTH */ + " characters.", { message: message }, true);
        }
    }
    return messageTrunc || message;
}
function dataSanitizeException(logger, exception) {
    var exceptionTrunc;
    if (exception) {
        // Make surte its a string
        var value = "" + exception;
        if (value[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_LENGTH /* @min:%2elength */] > 32768 /* DataSanitizerValues.MAX_EXCEPTION_LENGTH */) {
            exceptionTrunc = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.strSubstring)(value, 0, 32768 /* DataSanitizerValues.MAX_EXCEPTION_LENGTH */);
            (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__._throwInternal)(logger, 2 /* eLoggingSeverity.WARNING */, 52 /* _eInternalMessageId.ExceptionTruncated */, "exception is too long, it has been truncated to " + 32768 /* DataSanitizerValues.MAX_EXCEPTION_LENGTH */ + " characters.", { exception: exception }, true);
        }
    }
    return exceptionTrunc || exception;
}
function dataSanitizeProperties(logger, properties) {
    if (properties) {
        var tempProps_1 = {};
        (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.objForEachKey)(properties, function (prop, value) {
            if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.isObject)(value) && (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_3__.hasJSON)()) {
                // Stringify any part C properties
                try {
                    value = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_3__.getJSON)()[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_STRINGIFY /* @min:%2estringify */](value);
                }
                catch (e) {
                    (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__._throwInternal)(logger, 2 /* eLoggingSeverity.WARNING */, 49 /* _eInternalMessageId.CannotSerializeObjectNonSerializable */, "custom property is not valid", { exception: e }, true);
                }
            }
            value = dataSanitizeString(logger, value, 8192 /* DataSanitizerValues.MAX_PROPERTY_LENGTH */);
            prop = dataSanitizeKeyAndAddUniqueness(logger, prop, tempProps_1);
            tempProps_1[prop] = value;
        });
        properties = tempProps_1;
    }
    return properties;
}
function dataSanitizeMeasurements(logger, measurements) {
    if (measurements) {
        var tempMeasurements_1 = {};
        (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.objForEachKey)(measurements, function (measure, value) {
            measure = dataSanitizeKeyAndAddUniqueness(logger, measure, tempMeasurements_1);
            tempMeasurements_1[measure] = value;
        });
        measurements = tempMeasurements_1;
    }
    return measurements;
}
function dataSanitizeId(logger, id) {
    return id ? dataSanitizeInput(logger, id, 128 /* DataSanitizerValues.MAX_ID_LENGTH */, 69 /* _eInternalMessageId.IdTooLong */)[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_TO_STRING /* @min:%2etoString */]() : id;
}
function dataSanitizeInput(logger, input, maxLength, _msgId) {
    var inputTrunc;
    if (input) {
        input = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.strTrim)((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.asString)(input));
        if (input[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_LENGTH /* @min:%2elength */] > maxLength) {
            inputTrunc = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.strSubstring)(input, 0, maxLength);
            (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__._throwInternal)(logger, 2 /* eLoggingSeverity.WARNING */, _msgId, "input is too long, it has been truncated to " + maxLength + " characters.", { data: input }, true);
        }
    }
    return inputTrunc || input;
}
function dsPadNumber(num) {
    var s = "00" + num;
    return (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.strSubstr)(s, s[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_LENGTH /* @min:%2elength */] - 3);
}
//# sourceMappingURL=DataSanitizer.js.map

/***/ }),
/* 96 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ThrottleMgr": () => (/* binding */ ThrottleMgr)
/* harmony export */ });
/* harmony import */ var _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(30);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(50);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(45);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(40);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(43);
/* harmony import */ var _StorageHelperFuncs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(97);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(92);
/*
 * Application Insights JavaScript SDK - Common, 3.3.0
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */




var THROTTLE_STORAGE_PREFIX = "appInsightsThrottle";
var ThrottleMgr = /** @class */ (function () {
    function ThrottleMgr(core, namePrefix) {
        var _self = this;
        var _canUseLocalStorage;
        var _logger;
        var _config;
        var _localStorageObj;
        var _isTriggered; //_isTriggered is to make sure that we only trigger throttle once a day
        var _namePrefix;
        var _queue;
        var _isReady = false;
        var _isSpecificDaysGiven = false;
        _initConfig();
        // Special internal method to allow the unit tests and DebugPlugin to hook embedded objects
        _self["_getDbgPlgTargets"] = function () {
            return [_queue];
        };
        _self.getConfig = function () {
            return _config;
        };
        /**
         * Check if it is the correct day to send message.
         * If _isTriggered is true, even if canThrottle returns true, message will not be sent,
         * because we only allow triggering sendMessage() once a day.
         * @returns if the current date is the valid date to send message
         */
        _self.canThrottle = function (msgId) {
            var localObj = _getLocalStorageObjByKey(msgId);
            var cfg = _getCfgByKey(msgId);
            return _canThrottle(cfg, _canUseLocalStorage, localObj);
        };
        /**
         * Check if throttle is triggered on current day(UTC)
         * if canThrottle returns false, isTriggered will return false
         * @returns if throttle is triggered on current day(UTC)
         */
        _self.isTriggered = function (msgId) {
            return _isTrigger(msgId);
        };
        /**
         * Before isReady set to true, all message will be stored in queue.
         * Message will only be sent out after isReady set to true.
         * Initial and default value: false
         * @returns isReady state
         */
        _self.isReady = function () {
            return _isReady;
        };
        /**
         * Flush all message with given message key in queue with isReady state set to true.
         * @returns if message queue is flushed
         */
        _self.flush = function (msgId) {
            try {
                var queue = _getQueueByKey(msgId);
                if (queue && queue[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_LENGTH /* @min:%2elength */] > 0) {
                    var items = queue.slice(0);
                    _queue[msgId] = [];
                    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.arrForEach)(items, function (item) {
                        _flushMessage(item.msgID, item[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_MESSAGE /* @min:%2emessage */], item.severity, false);
                    });
                    return true;
                }
            }
            catch (err) {
                // eslint-disable-next-line no-empty
            }
            return false;
        };
        /**
         * Flush all message in queue with isReady state set to true.
         * @returns if message queue is flushed
         */
        _self.flushAll = function () {
            try {
                if (_queue) {
                    var result_1 = true;
                    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.objForEachKey)(_queue, function (key) {
                        var isFlushed = _self.flush(parseInt(key));
                        result_1 = result_1 && isFlushed;
                    });
                    return result_1;
                }
            }
            catch (err) {
                // eslint-disable-next-line no-empty
            }
            return false;
        };
        /**
         * Set isReady State
         * if isReady set to true, message queue will be flushed automatically.
         * @param isReady isReady State
         * @pa
         * @returns if message queue is flushed
         */
        _self.onReadyState = function (isReady, flushAll) {
            if (flushAll === void 0) { flushAll = true; }
            _isReady = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(isReady) ? true : isReady;
            if (_isReady && flushAll) {
                return _self.flushAll();
            }
            return null;
        };
        _self.sendMessage = function (msgID, message, severity) {
            return _flushMessage(msgID, message, severity, true);
        };
        function _flushMessage(msgID, message, severity, saveUnsentMsg) {
            if (_isReady) {
                var isSampledIn = _canSampledIn(msgID);
                if (!isSampledIn) {
                    return;
                }
                var cfg = _getCfgByKey(msgID);
                var localStorageObj = _getLocalStorageObjByKey(msgID);
                var canThrottle = _canThrottle(cfg, _canUseLocalStorage, localStorageObj);
                var throttled = false;
                var number = 0;
                var isTriggered = _isTrigger(msgID);
                try {
                    if (canThrottle && !isTriggered) {
                        number = Math.min(cfg.limit.maxSendNumber, localStorageObj[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_COUNT /* @min:%2ecount */] + 1);
                        localStorageObj[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_COUNT /* @min:%2ecount */] = 0;
                        throttled = true;
                        _isTriggered[msgID] = true;
                        localStorageObj[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_PRE_TRIGGER_DATE /* @min:%2epreTriggerDate */] = new Date();
                    }
                    else {
                        _isTriggered[msgID] = canThrottle;
                        localStorageObj[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_COUNT /* @min:%2ecount */] += 1;
                    }
                    var localStorageName = _getLocalStorageName(msgID);
                    _resetLocalStorage(_logger, localStorageName, localStorageObj);
                    for (var i = 0; i < number; i++) {
                        _sendMessage(msgID, _logger, message, severity);
                    }
                }
                catch (e) {
                    // eslint-disable-next-line no-empty
                }
                return {
                    isThrottled: throttled,
                    throttleNum: number
                };
            }
            else {
                if (!!saveUnsentMsg) {
                    var queue = _getQueueByKey(msgID);
                    queue[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_PUSH /* @min:%2epush */]({
                        msgID: msgID,
                        message: message,
                        severity: severity
                    });
                }
            }
            return null;
        }
        function _initConfig() {
            _logger = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__.safeGetLogger)(core);
            _isTriggered = {};
            _localStorageObj = {};
            _queue = {};
            _config = {};
            _setCfgByKey(109 /* _eInternalMessageId.DefaultThrottleMsgKey */);
            _namePrefix = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_3__.isNotNullOrUndefined)(namePrefix) ? namePrefix : "";
            core.addUnloadHook((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_4__.onConfigChange)(core.config, function (details) {
                var coreConfig = details.cfg;
                _canUseLocalStorage = (0,_StorageHelperFuncs__WEBPACK_IMPORTED_MODULE_5__.utlCanUseLocalStorage)();
                var configMgr = coreConfig.throttleMgrCfg || {};
                (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.objForEachKey)(configMgr, function (key, cfg) {
                    _setCfgByKey(parseInt(key), cfg);
                });
            }));
        }
        function _getCfgByKey(msgID) {
            return _config[msgID] || _config[109 /* _eInternalMessageId.DefaultThrottleMsgKey */];
        }
        function _setCfgByKey(msgID, config) {
            var _a, _b;
            try {
                var cfg = config || {};
                var curCfg = {};
                curCfg[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_DISABLED /* @min:%2edisabled */] = !!cfg[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_DISABLED /* @min:%2edisabled */];
                var configInterval = cfg[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_INTERVAL /* @min:%2einterval */] || {};
                _isSpecificDaysGiven = (configInterval === null || configInterval === void 0 ? void 0 : configInterval.daysOfMonth) && (configInterval === null || configInterval === void 0 ? void 0 : configInterval.daysOfMonth[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_LENGTH /* @min:%2elength */]) > 0;
                curCfg[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_INTERVAL /* @min:%2einterval */] = _getIntervalConfig(configInterval);
                var limit = {
                    samplingRate: ((_a = cfg.limit) === null || _a === void 0 ? void 0 : _a.samplingRate) || 100,
                    // dafault: every time sent only 1 event
                    maxSendNumber: ((_b = cfg.limit) === null || _b === void 0 ? void 0 : _b.maxSendNumber) || 1
                };
                curCfg.limit = limit;
                _config[msgID] = curCfg;
            }
            catch (e) {
                // eslint-disable-next-line no-empty
            }
        }
        function _getIntervalConfig(interval) {
            interval = interval || {};
            var monthInterval = interval === null || interval === void 0 ? void 0 : interval.monthInterval;
            var dayInterval = interval === null || interval === void 0 ? void 0 : interval.dayInterval;
            // default: send data every 3 month each year
            if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(monthInterval) && (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(dayInterval)) {
                interval.monthInterval = 3;
                if (!_isSpecificDaysGiven) {
                    // default: send data on 28th
                    interval[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_DAYS_OF_MONTH /* @min:%2edaysOfMonth */] = [28];
                    _isSpecificDaysGiven = true;
                }
            }
            interval = {
                // dafault: sent every three months
                monthInterval: interval === null || interval === void 0 ? void 0 : interval.monthInterval,
                dayInterval: interval === null || interval === void 0 ? void 0 : interval.dayInterval,
                daysOfMonth: interval === null || interval === void 0 ? void 0 : interval.daysOfMonth
            };
            return interval;
        }
        function _canThrottle(config, canUseLocalStorage, localStorageObj) {
            if (config && !config[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_DISABLED /* @min:%2edisabled */] && canUseLocalStorage && (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_3__.isNotNullOrUndefined)(localStorageObj)) {
                var curDate = _getThrottleDate();
                var date = localStorageObj[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_DATE /* @min:%2edate */];
                var interval = config[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_INTERVAL /* @min:%2einterval */];
                var monthCheck = 1;
                if (interval === null || interval === void 0 ? void 0 : interval.monthInterval) {
                    var monthExpand = (curDate.getUTCFullYear() - date.getUTCFullYear()) * 12 + curDate.getUTCMonth() - date.getUTCMonth();
                    monthCheck = _checkInterval(interval.monthInterval, 0, monthExpand);
                }
                var dayCheck = 1;
                if (_isSpecificDaysGiven) {
                    dayCheck = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.arrIndexOf)(interval[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_DAYS_OF_MONTH /* @min:%2edaysOfMonth */], curDate[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_GET_UTCDATE /* @min:%2egetUTCDate */]());
                }
                else if (interval === null || interval === void 0 ? void 0 : interval.dayInterval) {
                    var daySpan = Math.floor((curDate.getTime() - date.getTime()) / 86400000);
                    dayCheck = _checkInterval(interval.dayInterval, 0, daySpan);
                }
                return monthCheck >= 0 && dayCheck >= 0;
            }
            return false;
        }
        function _getLocalStorageName(msgKey, prefix) {
            var fix = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_3__.isNotNullOrUndefined)(prefix) ? prefix : "";
            if (msgKey) {
                return THROTTLE_STORAGE_PREFIX + fix + "-" + msgKey;
            }
            return null;
        }
        // returns if throttle is triggered on current Date
        function _isTriggeredOnCurDate(preTriggerDate) {
            try {
                if (preTriggerDate) {
                    var curDate = new Date();
                    return preTriggerDate.getUTCFullYear() === curDate.getUTCFullYear() &&
                        preTriggerDate.getUTCMonth() === curDate.getUTCMonth() &&
                        preTriggerDate[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_GET_UTCDATE /* @min:%2egetUTCDate */]() === curDate[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_GET_UTCDATE /* @min:%2egetUTCDate */]();
                }
            }
            catch (e) {
                // eslint-disable-next-line no-empty
            }
            return false;
        }
        // transfer local storage string value to object that identifies start date, current count and preTriggerDate
        function _getLocalStorageObj(value, logger, storageName) {
            try {
                var storageObj = {
                    date: _getThrottleDate(),
                    count: 0
                };
                if (value) {
                    var obj = JSON.parse(value);
                    var curObj = {
                        date: _getThrottleDate(obj[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_DATE /* @min:%2edate */]) || storageObj[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_DATE /* @min:%2edate */],
                        count: obj[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_COUNT /* @min:%2ecount */] || storageObj[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_COUNT /* @min:%2ecount */],
                        preTriggerDate: obj.preTriggerDate ? _getThrottleDate(obj[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_PRE_TRIGGER_DATE /* @min:%2epreTriggerDate */]) : undefined
                    };
                    return curObj;
                }
                else {
                    _resetLocalStorage(logger, storageName, storageObj);
                    return storageObj;
                }
            }
            catch (e) {
                // eslint-disable-next-line no-empty
            }
            return null;
        }
        // if datestr is not defined, current date will be returned
        function _getThrottleDate(dateStr) {
            // if new Date() can't be created through the provided dateStr, null will be returned.
            try {
                if (dateStr) {
                    var date = new Date(dateStr);
                    //make sure it is a valid Date Object
                    if (!isNaN(date.getDate())) {
                        return date;
                    }
                }
                else {
                    return new Date();
                }
            }
            catch (e) {
                // eslint-disable-next-line no-empty
            }
            return null;
        }
        function _resetLocalStorage(logger, storageName, obj) {
            try {
                return (0,_StorageHelperFuncs__WEBPACK_IMPORTED_MODULE_5__.utlSetLocalStorage)(logger, storageName, (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.strTrim)(JSON[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_STRINGIFY /* @min:%2estringify */](obj)));
            }
            catch (e) {
                // eslint-disable-next-line no-empty
            }
            return false;
        }
        function _checkInterval(interval, start, current) {
            if (interval <= 0) {
                return 1;
            }
            // count from start year
            return (current >= start) && (current - start) % interval == 0 ? Math.floor((current - start) / interval) + 1 : -1;
        }
        function _sendMessage(msgID, logger, message, severity) {
            (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__._throwInternal)(logger, severity || 1 /* eLoggingSeverity.CRITICAL */, msgID, message);
        }
        // NOTE: config.limit.samplingRate is set to 4 decimal places,
        // so config.limit.samplingRate = 1 means 0.0001%
        function _canSampledIn(msgID) {
            try {
                var cfg = _getCfgByKey(msgID);
                return (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_6__.randomValue)(1000000) <= cfg.limit.samplingRate;
            }
            catch (e) {
                // eslint-disable-next-line no-empty
            }
            return false;
        }
        function _getLocalStorageObjByKey(key) {
            try {
                var curObj = _localStorageObj[key];
                if (!curObj) {
                    var localStorageName = _getLocalStorageName(key, _namePrefix);
                    curObj = _getLocalStorageObj((0,_StorageHelperFuncs__WEBPACK_IMPORTED_MODULE_5__.utlGetLocalStorage)(_logger, localStorageName), _logger, localStorageName);
                    _localStorageObj[key] = curObj;
                }
                return _localStorageObj[key];
            }
            catch (e) {
                // eslint-disable-next-line no-empty
            }
            return null;
        }
        function _isTrigger(key) {
            var isTrigger = _isTriggered[key];
            if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(isTrigger)) {
                isTrigger = false;
                var localStorageObj = _getLocalStorageObjByKey(key);
                if (localStorageObj) {
                    isTrigger = _isTriggeredOnCurDate(localStorageObj[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_PRE_TRIGGER_DATE /* @min:%2epreTriggerDate */]);
                }
                _isTriggered[key] = isTrigger;
            }
            return _isTriggered[key];
        }
        function _getQueueByKey(key) {
            _queue = _queue || {};
            if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(_queue[key])) {
                _queue[key] = [];
            }
            return _queue[key];
        }
    }
    return ThrottleMgr;
}());

//# sourceMappingURL=ThrottleMgr.js.map

/***/ }),
/* 97 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "utlCanUseLocalStorage": () => (/* binding */ utlCanUseLocalStorage),
/* harmony export */   "utlCanUseSessionStorage": () => (/* binding */ utlCanUseSessionStorage),
/* harmony export */   "utlDisableStorage": () => (/* binding */ utlDisableStorage),
/* harmony export */   "utlEnableStorage": () => (/* binding */ utlEnableStorage),
/* harmony export */   "utlGetLocalStorage": () => (/* binding */ utlGetLocalStorage),
/* harmony export */   "utlGetSessionStorage": () => (/* binding */ utlGetSessionStorage),
/* harmony export */   "utlGetSessionStorageKeys": () => (/* binding */ utlGetSessionStorageKeys),
/* harmony export */   "utlRemoveSessionStorage": () => (/* binding */ utlRemoveSessionStorage),
/* harmony export */   "utlRemoveStorage": () => (/* binding */ utlRemoveStorage),
/* harmony export */   "utlSetLocalStorage": () => (/* binding */ utlSetLocalStorage),
/* harmony export */   "utlSetSessionStorage": () => (/* binding */ utlSetSessionStorage),
/* harmony export */   "utlSetStoragePrefix": () => (/* binding */ utlSetStoragePrefix)
/* harmony export */ });
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(30);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(50);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(45);
/* harmony import */ var _Enums__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(98);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(92);
/*
 * Application Insights JavaScript SDK - Common, 3.3.0
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */





var _canUseLocalStorage = undefined;
var _canUseSessionStorage = undefined;
var _storagePrefix = "";
/**
 * Gets the localStorage object if available
 * @return {Storage} - Returns the storage object if available else returns null
 */
function _getLocalStorageObject() {
    if (utlCanUseLocalStorage()) {
        return _getVerifiedStorageObject(_Enums__WEBPACK_IMPORTED_MODULE_0__.StorageType.LocalStorage);
    }
    return null;
}
/**
 * Tests storage object (localStorage or sessionStorage) to verify that it is usable
 * More details here: https://mathiasbynens.be/notes/localstorage-pattern
 * @param storageType - Type of storage
 * @return {Storage} Returns storage object verified that it is usable
 */
function _getVerifiedStorageObject(storageType) {
    try {
        if ((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.getGlobal)())) {
            return null;
        }
        var uid = (new Date)[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_TO_STRING /* @min:%2etoString */]();
        var storage = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.getInst)(storageType === _Enums__WEBPACK_IMPORTED_MODULE_0__.StorageType.LocalStorage ? "localStorage" : "sessionStorage");
        var name_1 = _storagePrefix + uid;
        storage.setItem(name_1, uid);
        var fail = storage.getItem(name_1) !== uid;
        storage[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_REMOVE_ITEM /* @min:%2eremoveItem */](name_1);
        if (!fail) {
            return storage;
        }
    }
    catch (exception) {
        // eslint-disable-next-line no-empty
    }
    return null;
}
/**
 * Gets the sessionStorage object if available
 * @return {Storage} - Returns the storage object if available else returns null
 */
function _getSessionStorageObject() {
    if (utlCanUseSessionStorage()) {
        return _getVerifiedStorageObject(_Enums__WEBPACK_IMPORTED_MODULE_0__.StorageType.SessionStorage);
    }
    return null;
}
/**
 * Disables the global SDK usage of local or session storage if available
 */
function utlDisableStorage() {
    _canUseLocalStorage = false;
    _canUseSessionStorage = false;
}
function utlSetStoragePrefix(storagePrefix) {
    _storagePrefix = storagePrefix || "";
}
/**
 * Re-enables the global SDK usage of local or session storage if available
 */
function utlEnableStorage() {
    _canUseLocalStorage = utlCanUseLocalStorage(true);
    _canUseSessionStorage = utlCanUseSessionStorage(true);
}
/**
 * Returns whether LocalStorage can be used, if the reset parameter is passed a true this will override
 * any previous disable calls.
 * @param reset - Should the usage be reset and determined only based on whether LocalStorage is available
 */
function utlCanUseLocalStorage(reset) {
    if (reset || _canUseLocalStorage === undefined) {
        _canUseLocalStorage = !!_getVerifiedStorageObject(_Enums__WEBPACK_IMPORTED_MODULE_0__.StorageType.LocalStorage);
    }
    return _canUseLocalStorage;
}
function utlGetLocalStorage(logger, name) {
    var storage = _getLocalStorageObject();
    if (storage !== null) {
        try {
            return storage.getItem(name);
        }
        catch (e) {
            _canUseLocalStorage = false;
            (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_3__._throwInternal)(logger, 2 /* eLoggingSeverity.WARNING */, 1 /* _eInternalMessageId.BrowserCannotReadLocalStorage */, "Browser failed read of local storage. " + (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_4__.getExceptionName)(e), { exception: (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.dumpObj)(e) });
        }
    }
    return null;
}
function utlSetLocalStorage(logger, name, data) {
    var storage = _getLocalStorageObject();
    if (storage !== null) {
        try {
            storage.setItem(name, data);
            return true;
        }
        catch (e) {
            _canUseLocalStorage = false;
            (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_3__._throwInternal)(logger, 2 /* eLoggingSeverity.WARNING */, 3 /* _eInternalMessageId.BrowserCannotWriteLocalStorage */, "Browser failed write to local storage. " + (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_4__.getExceptionName)(e), { exception: (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.dumpObj)(e) });
        }
    }
    return false;
}
function utlRemoveStorage(logger, name) {
    var storage = _getLocalStorageObject();
    if (storage !== null) {
        try {
            storage[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_REMOVE_ITEM /* @min:%2eremoveItem */](name);
            return true;
        }
        catch (e) {
            _canUseLocalStorage = false;
            (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_3__._throwInternal)(logger, 2 /* eLoggingSeverity.WARNING */, 5 /* _eInternalMessageId.BrowserFailedRemovalFromLocalStorage */, "Browser failed removal of local storage item. " + (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_4__.getExceptionName)(e), { exception: (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.dumpObj)(e) });
        }
    }
    return false;
}
function utlCanUseSessionStorage(reset) {
    if (reset || _canUseSessionStorage === undefined) {
        _canUseSessionStorage = !!_getVerifiedStorageObject(_Enums__WEBPACK_IMPORTED_MODULE_0__.StorageType.SessionStorage);
    }
    return _canUseSessionStorage;
}
function utlGetSessionStorageKeys() {
    var keys = [];
    if (utlCanUseSessionStorage()) {
        (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.objForEachKey)((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.getInst)("sessionStorage"), function (key) {
            keys[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_PUSH /* @min:%2epush */](key);
        });
    }
    return keys;
}
function utlGetSessionStorage(logger, name) {
    var storage = _getSessionStorageObject();
    if (storage !== null) {
        try {
            return storage.getItem(name);
        }
        catch (e) {
            _canUseSessionStorage = false;
            (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_3__._throwInternal)(logger, 2 /* eLoggingSeverity.WARNING */, 2 /* _eInternalMessageId.BrowserCannotReadSessionStorage */, "Browser failed read of session storage. " + (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_4__.getExceptionName)(e), { exception: (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.dumpObj)(e) });
        }
    }
    return null;
}
function utlSetSessionStorage(logger, name, data) {
    var storage = _getSessionStorageObject();
    if (storage !== null) {
        try {
            storage.setItem(name, data);
            return true;
        }
        catch (e) {
            _canUseSessionStorage = false;
            (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_3__._throwInternal)(logger, 2 /* eLoggingSeverity.WARNING */, 4 /* _eInternalMessageId.BrowserCannotWriteSessionStorage */, "Browser failed write to session storage. " + (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_4__.getExceptionName)(e), { exception: (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.dumpObj)(e) });
        }
    }
    return false;
}
function utlRemoveSessionStorage(logger, name) {
    var storage = _getSessionStorageObject();
    if (storage !== null) {
        try {
            storage[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_REMOVE_ITEM /* @min:%2eremoveItem */](name);
            return true;
        }
        catch (e) {
            _canUseSessionStorage = false;
            (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_3__._throwInternal)(logger, 2 /* eLoggingSeverity.WARNING */, 6 /* _eInternalMessageId.BrowserFailedRemovalFromSessionStorage */, "Browser failed removal of session storage item. " + (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_4__.getExceptionName)(e), { exception: (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.dumpObj)(e) });
        }
    }
    return false;
}
//# sourceMappingURL=StorageHelperFuncs.js.map

/***/ }),
/* 98 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DistributedTracingModes": () => (/* binding */ DistributedTracingModes),
/* harmony export */   "EventPersistence": () => (/* binding */ EventPersistence),
/* harmony export */   "StorageType": () => (/* binding */ StorageType)
/* harmony export */ });
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(29);
/*
 * Application Insights JavaScript SDK - Common, 3.3.0
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */



var StorageType = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.createEnumStyle)({
    LocalStorage: 0 /* eStorageType.LocalStorage */,
    SessionStorage: 1 /* eStorageType.SessionStorage */
});
var DistributedTracingModes = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.createEnumStyle)({
    AI: 0 /* eDistributedTracingModes.AI */,
    AI_AND_W3C: 1 /* eDistributedTracingModes.AI_AND_W3C */,
    W3C: 2 /* eDistributedTracingModes.W3C */
});
/**
 * The EventPersistence contains a set of values that specify the event's persistence.
 */
var EventPersistence = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.createEnumStyle)({
    /**
     * Normal persistence.
     */
    Normal: 1 /* EventPersistenceValue.Normal */,
    /**
     * Critical persistence.
     */
    Critical: 2 /* EventPersistenceValue.Critical */
});
//# sourceMappingURL=Enums.js.map

/***/ }),
/* 99 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ConnectionStringParser": () => (/* binding */ ConnectionStringParser),
/* harmony export */   "parseConnectionString": () => (/* binding */ parseConnectionString)
/* harmony export */ });
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(30);
/* harmony import */ var _Constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(91);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(92);
/*
 * Application Insights JavaScript SDK - Common, 3.3.0
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */





var _FIELDS_SEPARATOR = ";";
var _FIELD_KEY_VALUE_SEPARATOR = "=";
function parseConnectionString(connectionString) {
    if (!connectionString) {
        return {};
    }
    var kvPairs = connectionString[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_SPLIT /* @min:%2esplit */](_FIELDS_SEPARATOR);
    var result = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.arrReduce)(kvPairs, function (fields, kv) {
        var kvParts = kv[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_SPLIT /* @min:%2esplit */](_FIELD_KEY_VALUE_SEPARATOR);
        if (kvParts[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_LENGTH /* @min:%2elength */] === 2) { // only save fields with valid formats
            var key = kvParts[0][_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_TO_LOWER_CASE /* @min:%2etoLowerCase */]();
            var value = kvParts[1];
            fields[key] = value;
        }
        return fields;
    }, {});
    if ((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.objKeys)(result)[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_LENGTH /* @min:%2elength */] > 0) {
        // this is a valid connection string, so parse the results
        if (result.endpointsuffix) {
            // apply the default endpoints
            var locationPrefix = result.location ? result.location + "." : "";
            result[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_INGESTIONENDPOINT /* @min:%2eingestionendpoint */] = result[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_INGESTIONENDPOINT /* @min:%2eingestionendpoint */] || ("https://" + locationPrefix + "dc." + result.endpointsuffix);
        }
        // apply user override endpoint or the default endpoints
        result[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_INGESTIONENDPOINT /* @min:%2eingestionendpoint */] = result[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_INGESTIONENDPOINT /* @min:%2eingestionendpoint */] || _Constants__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_BREEZE_ENDPOINT;
        if ((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.strEndsWith)(result[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_INGESTIONENDPOINT /* @min:%2eingestionendpoint */], "/")) {
            result[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_INGESTIONENDPOINT /* @min:%2eingestionendpoint */] = result[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_INGESTIONENDPOINT /* @min:%2eingestionendpoint */].slice(0, -1);
        }
    }
    return result;
}
var ConnectionStringParser = {
    parse: parseConnectionString
};
//# sourceMappingURL=ConnectionStringParser.js.map

/***/ }),
/* 100 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Envelope": () => (/* binding */ Envelope)
/* harmony export */ });
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(45);
/* harmony import */ var _Constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(91);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(92);
/* harmony import */ var _DataSanitizer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(95);
/*
 * Application Insights JavaScript SDK - Common, 3.3.0
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */






var Envelope = /** @class */ (function () {
    /**
     * Constructs a new instance of telemetry data.
     */
    function Envelope(logger, data, name) {
        var _this = this;
        var _self = this;
        _self.ver = 1;
        _self.sampleRate = 100.0;
        _self.tags = {};
        _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_NAME /* @min:%2ename */] = (0,_DataSanitizer__WEBPACK_IMPORTED_MODULE_1__.dataSanitizeString)(logger, name) || _Constants__WEBPACK_IMPORTED_MODULE_2__.strNotSpecified;
        _self.data = data;
        _self.time = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_3__.toISOString)(new Date());
        _self.aiDataContract = {
            time: 1 /* FieldType.Required */,
            iKey: 1 /* FieldType.Required */,
            name: 1 /* FieldType.Required */,
            sampleRate: function () {
                return (_this.sampleRate === 100) ? 4 /* FieldType.Hidden */ : 1 /* FieldType.Required */;
            },
            tags: 1 /* FieldType.Required */,
            data: 1 /* FieldType.Required */
        };
    }
    return Envelope;
}());

//# sourceMappingURL=Envelope.js.map

/***/ }),
/* 101 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Event": () => (/* binding */ Event)
/* harmony export */ });
/* harmony import */ var _Constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(91);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(92);
/* harmony import */ var _Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(95);
/*
 * Application Insights JavaScript SDK - Common, 3.3.0
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */





var Event = /** @class */ (function () {
    /**
     * Constructs a new instance of the EventTelemetry object
     */
    function Event(logger, name, properties, measurements) {
        this.aiDataContract = {
            ver: 1 /* FieldType.Required */,
            name: 1 /* FieldType.Required */,
            properties: 0 /* FieldType.Default */,
            measurements: 0 /* FieldType.Default */
        };
        var _self = this;
        _self.ver = 2;
        _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_NAME /* @min:%2ename */] = (0,_Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_1__.dataSanitizeString)(logger, name) || _Constants__WEBPACK_IMPORTED_MODULE_2__.strNotSpecified;
        _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_PROPERTIES /* @min:%2eproperties */] = (0,_Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_1__.dataSanitizeProperties)(logger, properties);
        _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_MEASUREMENTS /* @min:%2emeasurements */] = (0,_Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_1__.dataSanitizeMeasurements)(logger, measurements);
    }
    Event.envelopeType = "Microsoft.ApplicationInsights.{0}.Event";
    Event.dataType = "EventData";
    return Event;
}());

//# sourceMappingURL=Event.js.map

/***/ }),
/* 102 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Exception": () => (/* binding */ Exception),
/* harmony export */   "_ExceptionDetails": () => (/* binding */ _ExceptionDetails),
/* harmony export */   "_StackFrame": () => (/* binding */ _StackFrame),
/* harmony export */   "_formatErrorCode": () => (/* binding */ _formatErrorCode)
/* harmony export */ });
/* harmony import */ var _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(33);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(30);
/* harmony import */ var _Constants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(91);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(92);
/* harmony import */ var _Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(95);
/*
 * Application Insights JavaScript SDK - Common, 3.3.0
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */








var NoMethod = "<no_method>";
var strError = "error";
var strStack = "stack";
var strStackDetails = "stackDetails";
var strErrorSrc = "errorSrc";
var strMessage = "message";
var strDescription = "description";
function _stringify(value, convertToString) {
    var result = value;
    if (result && !(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.isString)(result)) {
        if (JSON && JSON[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_STRINGIFY /* @min:%2estringify */]) {
            result = JSON[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_STRINGIFY /* @min:%2estringify */](value);
            if (convertToString && (!result || result === "{}")) {
                if ((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.isFunction)(value[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_TO_STRING /* @min:%2etoString */])) {
                    result = value[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_TO_STRING /* @min:%2etoString */]();
                }
                else {
                    result = "" + value;
                }
            }
        }
        else {
            result = "" + value + " - (Missing JSON.stringify)";
        }
    }
    return result || "";
}
function _formatMessage(theEvent, errorType) {
    var evtMessage = theEvent;
    if (theEvent) {
        if (evtMessage && !(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.isString)(evtMessage)) {
            evtMessage = theEvent[strMessage] || theEvent[strDescription] || evtMessage;
        }
        // Make sure the message is a string
        if (evtMessage && !(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.isString)(evtMessage)) {
            // tslint:disable-next-line: prefer-conditional-expression
            evtMessage = _stringify(evtMessage, true);
        }
        if (theEvent["filename"]) {
            // Looks like an event object with filename
            evtMessage = evtMessage + " @" + (theEvent["filename"] || "") + ":" + (theEvent["lineno"] || "?") + ":" + (theEvent["colno"] || "?");
        }
    }
    // Automatically add the error type to the message if it does already appear to be present
    if (errorType && errorType !== "String" && errorType !== "Object" && errorType !== "Error" && (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.strIndexOf)(evtMessage || "", errorType) === -1) {
        evtMessage = errorType + ": " + evtMessage;
    }
    return evtMessage || "";
}
function _isExceptionDetailsInternal(value) {
    try {
        if ((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.isObject)(value)) {
            return "hasFullStack" in value && "typeName" in value;
        }
    }
    catch (e) {
        // This can happen with some native browser objects, but should not happen for the type we are checking for
    }
    return false;
}
function _isExceptionInternal(value) {
    try {
        if ((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.isObject)(value)) {
            return ("ver" in value && "exceptions" in value && "properties" in value);
        }
    }
    catch (e) {
        // This can happen with some native browser objects, but should not happen for the type we are checking for
    }
    return false;
}
function _isStackDetails(details) {
    return details && details.src && (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.isString)(details.src) && details.obj && (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.isArray)(details.obj);
}
function _convertStackObj(errorStack) {
    var src = errorStack || "";
    if (!(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.isString)(src)) {
        if ((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.isString)(src[strStack])) {
            src = src[strStack];
        }
        else {
            src = "" + src;
        }
    }
    var items = src[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_SPLIT /* @min:%2esplit */]("\n");
    return {
        src: src,
        obj: items
    };
}
function _getOperaStack(errorMessage) {
    var stack = [];
    var lines = errorMessage[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_SPLIT /* @min:%2esplit */]("\n");
    for (var lp = 0; lp < lines[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LENGTH /* @min:%2elength */]; lp++) {
        var entry = lines[lp];
        if (lines[lp + 1]) {
            entry += "@" + lines[lp + 1];
            lp++;
        }
        stack[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_PUSH /* @min:%2epush */](entry);
    }
    return {
        src: errorMessage,
        obj: stack
    };
}
function _getStackFromErrorObj(errorObj) {
    var details = null;
    if (errorObj) {
        try {
            /* Using bracket notation is support older browsers (IE 7/8 -- dont remember the version) that throw when using dot
            notation for undefined objects and we don't want to loose the error from being reported */
            if (errorObj[strStack]) {
                // Chrome/Firefox
                details = _convertStackObj(errorObj[strStack]);
            }
            else if (errorObj[strError] && errorObj[strError][strStack]) {
                // Edge error event provides the stack and error object
                details = _convertStackObj(errorObj[strError][strStack]);
            }
            else if (errorObj["exception"] && errorObj.exception[strStack]) {
                details = _convertStackObj(errorObj.exception[strStack]);
            }
            else if (_isStackDetails(errorObj)) {
                details = errorObj;
            }
            else if (_isStackDetails(errorObj[strStackDetails])) {
                details = errorObj[strStackDetails];
            }
            else if ((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.getWindow)() && (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.getWindow)()["opera"] && errorObj[strMessage]) {
                // Opera
                details = _getOperaStack(errorObj[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_MESSAGE /* @min:%2emessage */]);
            }
            else if (errorObj["reason"] && errorObj.reason[strStack]) {
                // UnhandledPromiseRejection
                details = _convertStackObj(errorObj.reason[strStack]);
            }
            else if ((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.isString)(errorObj)) {
                details = _convertStackObj(errorObj);
            }
            else {
                var evtMessage = errorObj[strMessage] || errorObj[strDescription] || "";
                if ((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.isString)(errorObj[strErrorSrc])) {
                    if (evtMessage) {
                        evtMessage += "\n";
                    }
                    evtMessage += " from " + errorObj[strErrorSrc];
                }
                if (evtMessage) {
                    details = _convertStackObj(evtMessage);
                }
            }
        }
        catch (e) {
            // something unexpected happened so to avoid failing to report any error lets swallow the exception
            // and fallback to the callee/caller method
            details = _convertStackObj(e);
        }
    }
    return details || {
        src: "",
        obj: null
    };
}
function _formatStackTrace(stackDetails) {
    var stack = "";
    if (stackDetails) {
        if (stackDetails.obj) {
            (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.arrForEach)(stackDetails.obj, function (entry) {
                stack += entry + "\n";
            });
        }
        else {
            stack = stackDetails.src || "";
        }
    }
    return stack;
}
function _parseStack(stack) {
    var parsedStack;
    var frames = stack.obj;
    if (frames && frames[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LENGTH /* @min:%2elength */] > 0) {
        parsedStack = [];
        var level_1 = 0;
        var totalSizeInBytes_1 = 0;
        (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.arrForEach)(frames, function (frame) {
            var theFrame = frame[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_TO_STRING /* @min:%2etoString */]();
            if (_StackFrame.regex.test(theFrame)) {
                var parsedFrame = new _StackFrame(theFrame, level_1++);
                totalSizeInBytes_1 += parsedFrame[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_SIZE_IN_BYTES /* @min:%2esizeInBytes */];
                parsedStack[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_PUSH /* @min:%2epush */](parsedFrame);
            }
        });
        // DP Constraint - exception parsed stack must be < 32KB
        // remove frames from the middle to meet the threshold
        var exceptionParsedStackThreshold = 32 * 1024;
        if (totalSizeInBytes_1 > exceptionParsedStackThreshold) {
            var left = 0;
            var right = parsedStack[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LENGTH /* @min:%2elength */] - 1;
            var size = 0;
            var acceptedLeft = left;
            var acceptedRight = right;
            while (left < right) {
                // check size
                var lSize = parsedStack[left][_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_SIZE_IN_BYTES /* @min:%2esizeInBytes */];
                var rSize = parsedStack[right][_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_SIZE_IN_BYTES /* @min:%2esizeInBytes */];
                size += lSize + rSize;
                if (size > exceptionParsedStackThreshold) {
                    // remove extra frames from the middle
                    var howMany = acceptedRight - acceptedLeft + 1;
                    parsedStack.splice(acceptedLeft, howMany);
                    break;
                }
                // update pointers
                acceptedLeft = left;
                acceptedRight = right;
                left++;
                right--;
            }
        }
    }
    return parsedStack;
}
function _getErrorType(errorType) {
    // Gets the Error Type by passing the constructor (used to get the true type of native error object).
    var typeName = "";
    if (errorType) {
        typeName = errorType.typeName || errorType[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_NAME /* @min:%2ename */] || "";
        if (!typeName) {
            try {
                var funcNameRegex = /function (.{1,200})\(/;
                var results = (funcNameRegex).exec((errorType).constructor[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_TO_STRING /* @min:%2etoString */]());
                typeName = (results && results[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LENGTH /* @min:%2elength */] > 1) ? results[1] : "";
            }
            catch (e) {
                // eslint-disable-next-line no-empty -- Ignoring any failures as nothing we can do
            }
        }
    }
    return typeName;
}
/**
 * Formats the provided errorObj for display and reporting, it may be a String, Object, integer or undefined depending on the browser.
 * @param errorObj - The supplied errorObj
 */
function _formatErrorCode(errorObj) {
    if (errorObj) {
        try {
            if (!(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.isString)(errorObj)) {
                var errorType = _getErrorType(errorObj);
                var result = _stringify(errorObj, false);
                if (!result || result === "{}") {
                    if (errorObj[strError]) {
                        // Looks like an MS Error Event
                        errorObj = errorObj[strError];
                        errorType = _getErrorType(errorObj);
                    }
                    result = _stringify(errorObj, true);
                }
                if ((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.strIndexOf)(result, errorType) !== 0 && errorType !== "String") {
                    return errorType + ":" + result;
                }
                return result;
            }
        }
        catch (e) {
            // eslint-disable-next-line no-empty -- Ignoring any failures as nothing we can do
        }
    }
    // Fallback to just letting the object format itself into a string
    return "" + (errorObj || "");
}
var Exception = /** @class */ (function () {
    /**
     * Constructs a new instance of the ExceptionTelemetry object
     */
    function Exception(logger, exception, properties, measurements, severityLevel, id) {
        this.aiDataContract = {
            ver: 1 /* FieldType.Required */,
            exceptions: 1 /* FieldType.Required */,
            severityLevel: 0 /* FieldType.Default */,
            properties: 0 /* FieldType.Default */,
            measurements: 0 /* FieldType.Default */
        };
        var _self = this;
        _self.ver = 2; // TODO: handle the CS"4.0" ==> breeze 2 conversion in a better way
        if (!_isExceptionInternal(exception)) {
            if (!properties) {
                properties = {};
            }
            if (id) {
                properties.id = id;
            }
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_EXCEPTIONS /* @min:%2eexceptions */] = [new _ExceptionDetails(logger, exception, properties)];
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_PROPERTIES /* @min:%2eproperties */] = (0,_Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_2__.dataSanitizeProperties)(logger, properties);
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_MEASUREMENTS /* @min:%2emeasurements */] = (0,_Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_2__.dataSanitizeMeasurements)(logger, measurements);
            if (severityLevel) {
                _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_SEVERITY_LEVEL /* @min:%2eseverityLevel */] = severityLevel;
            }
            if (id) {
                _self.id = id;
            }
        }
        else {
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_EXCEPTIONS /* @min:%2eexceptions */] = exception[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_EXCEPTIONS /* @min:%2eexceptions */] || [];
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_PROPERTIES /* @min:%2eproperties */] = exception[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_PROPERTIES /* @min:%2eproperties */];
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_MEASUREMENTS /* @min:%2emeasurements */] = exception[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_MEASUREMENTS /* @min:%2emeasurements */];
            if (exception[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_SEVERITY_LEVEL /* @min:%2eseverityLevel */]) {
                _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_SEVERITY_LEVEL /* @min:%2eseverityLevel */] = exception[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_SEVERITY_LEVEL /* @min:%2eseverityLevel */];
            }
            if (exception.id) {
                _self.id = exception.id;
                exception[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_PROPERTIES /* @min:%2eproperties */].id = exception.id;
            }
            if (exception[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_PROBLEM_GROUP /* @min:%2eproblemGroup */]) {
                _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_PROBLEM_GROUP /* @min:%2eproblemGroup */] = exception[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_PROBLEM_GROUP /* @min:%2eproblemGroup */];
            }
            // bool/int types, use isNullOrUndefined
            if (!(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(exception[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_IS_MANUAL /* @min:%2eisManual */])) {
                _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_IS_MANUAL /* @min:%2eisManual */] = exception[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_IS_MANUAL /* @min:%2eisManual */];
            }
        }
    }
    Exception.CreateAutoException = function (message, url, lineNumber, columnNumber, error, evt, stack, errorSrc) {
        var _a;
        var errorType = _getErrorType(error || evt || message);
        return _a = {},
            _a[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_MESSAGE /* @min:message */] = _formatMessage(message, errorType),
            _a.url = url,
            _a.lineNumber = lineNumber,
            _a.columnNumber = columnNumber,
            _a.error = _formatErrorCode(error || evt || message),
            _a.evt = _formatErrorCode(evt || message),
            _a[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_TYPE_NAME /* @min:typeName */] = errorType,
            _a.stackDetails = _getStackFromErrorObj(stack || error || evt),
            _a.errorSrc = errorSrc,
            _a;
    };
    Exception.CreateFromInterface = function (logger, exception, properties, measurements) {
        var exceptions = exception[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_EXCEPTIONS /* @min:%2eexceptions */]
            && (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.arrMap)(exception[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_EXCEPTIONS /* @min:%2eexceptions */], function (ex) { return _ExceptionDetails[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN__CREATE_FROM_INTERFA1 /* @min:%2eCreateFromInterface */](logger, ex); });
        var exceptionData = new Exception(logger, (0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_3__.__assignFn)((0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_3__.__assignFn)({}, exception), { exceptions: exceptions }), properties, measurements);
        return exceptionData;
    };
    Exception.prototype.toInterface = function () {
        var _a;
        var _b = this, exceptions = _b.exceptions, properties = _b.properties, measurements = _b.measurements, severityLevel = _b.severityLevel, problemGroup = _b.problemGroup, id = _b.id, isManual = _b.isManual;
        var exceptionDetailsInterface = exceptions instanceof Array
            && (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.arrMap)(exceptions, function (exception) { return exception.toInterface(); })
            || undefined;
        return _a = {
                ver: "4.0"
            },
            _a[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_EXCEPTIONS /* @min:exceptions */] = exceptionDetailsInterface,
            _a.severityLevel = severityLevel,
            _a.properties = properties,
            _a.measurements = measurements,
            _a.problemGroup = problemGroup,
            _a.id = id,
            _a.isManual = isManual,
            _a;
    };
    /**
     * Creates a simple exception with 1 stack frame. Useful for manual constracting of exception.
     */
    Exception.CreateSimpleException = function (message, typeName, assembly, fileName, details, line) {
        var _a;
        return {
            exceptions: [
                (_a = {},
                    _a[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_HAS_FULL_STACK /* @min:hasFullStack */] = true,
                    _a.message = message,
                    _a.stack = details,
                    _a.typeName = typeName,
                    _a)
            ]
        };
    };
    Exception.envelopeType = "Microsoft.ApplicationInsights.{0}.Exception";
    Exception.dataType = "ExceptionData";
    Exception.formatError = _formatErrorCode;
    return Exception;
}());

var _ExceptionDetails = /** @class */ (function () {
    function _ExceptionDetails(logger, exception, properties) {
        this.aiDataContract = {
            id: 0 /* FieldType.Default */,
            outerId: 0 /* FieldType.Default */,
            typeName: 1 /* FieldType.Required */,
            message: 1 /* FieldType.Required */,
            hasFullStack: 0 /* FieldType.Default */,
            stack: 0 /* FieldType.Default */,
            parsedStack: 2 /* FieldType.Array */
        };
        var _self = this;
        if (!_isExceptionDetailsInternal(exception)) {
            var error = exception;
            var evt = error && error.evt;
            if (!(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.isError)(error)) {
                error = error[strError] || evt || error;
            }
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_TYPE_NAME /* @min:%2etypeName */] = (0,_Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_2__.dataSanitizeString)(logger, _getErrorType(error)) || _Constants__WEBPACK_IMPORTED_MODULE_4__.strNotSpecified;
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_MESSAGE /* @min:%2emessage */] = (0,_Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_2__.dataSanitizeMessage)(logger, _formatMessage(exception || error, _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_TYPE_NAME /* @min:%2etypeName */])) || _Constants__WEBPACK_IMPORTED_MODULE_4__.strNotSpecified;
            var stack = exception[strStackDetails] || _getStackFromErrorObj(exception);
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_PARSED_STACK /* @min:%2eparsedStack */] = _parseStack(stack);
            // after parsedStack is inited, iterate over each frame object, sanitize its assembly field
            if ((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.isArray)(_self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_PARSED_STACK /* @min:%2eparsedStack */])) {
                (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.arrMap)(_self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_PARSED_STACK /* @min:%2eparsedStack */], function (frame) {
                    frame[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_ASSEMBLY /* @min:%2eassembly */] = (0,_Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_2__.dataSanitizeString)(logger, frame[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_ASSEMBLY /* @min:%2eassembly */]);
                    frame[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_FILE_NAME /* @min:%2efileName */] = (0,_Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_2__.dataSanitizeString)(logger, frame[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_FILE_NAME /* @min:%2efileName */]);
                });
            }
            _self[strStack] = (0,_Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_2__.dataSanitizeException)(logger, _formatStackTrace(stack));
            _self.hasFullStack = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.isArray)(_self.parsedStack) && _self.parsedStack[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LENGTH /* @min:%2elength */] > 0;
            if (properties) {
                properties[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_TYPE_NAME /* @min:%2etypeName */] = properties[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_TYPE_NAME /* @min:%2etypeName */] || _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_TYPE_NAME /* @min:%2etypeName */];
            }
        }
        else {
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_TYPE_NAME /* @min:%2etypeName */] = exception[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_TYPE_NAME /* @min:%2etypeName */];
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_MESSAGE /* @min:%2emessage */] = exception[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_MESSAGE /* @min:%2emessage */];
            _self[strStack] = exception[strStack];
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_PARSED_STACK /* @min:%2eparsedStack */] = exception[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_PARSED_STACK /* @min:%2eparsedStack */] || [];
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_HAS_FULL_STACK /* @min:%2ehasFullStack */] = exception[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_HAS_FULL_STACK /* @min:%2ehasFullStack */];
        }
    }
    _ExceptionDetails.prototype.toInterface = function () {
        var _a;
        var _self = this;
        var parsedStack = _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_PARSED_STACK /* @min:%2eparsedStack */] instanceof Array
            && (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.arrMap)(_self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_PARSED_STACK /* @min:%2eparsedStack */], function (frame) { return frame.toInterface(); });
        var exceptionDetailsInterface = (_a = {
                id: _self.id,
                outerId: _self.outerId,
                typeName: _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_TYPE_NAME /* @min:%2etypeName */],
                message: _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_MESSAGE /* @min:%2emessage */],
                hasFullStack: _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_HAS_FULL_STACK /* @min:%2ehasFullStack */],
                stack: _self[strStack]
            },
            _a[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_PARSED_STACK /* @min:parsedStack */] = parsedStack || undefined,
            _a);
        return exceptionDetailsInterface;
    };
    _ExceptionDetails.CreateFromInterface = function (logger, exception) {
        var parsedStack = (exception[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_PARSED_STACK /* @min:%2eparsedStack */] instanceof Array
            && (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.arrMap)(exception[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_PARSED_STACK /* @min:%2eparsedStack */], function (frame) { return _StackFrame[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN__CREATE_FROM_INTERFA1 /* @min:%2eCreateFromInterface */](frame); }))
            || exception[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_PARSED_STACK /* @min:%2eparsedStack */];
        var exceptionDetails = new _ExceptionDetails(logger, (0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_3__.__assignFn)((0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_3__.__assignFn)({}, exception), { parsedStack: parsedStack }));
        return exceptionDetails;
    };
    return _ExceptionDetails;
}());

var _StackFrame = /** @class */ (function () {
    function _StackFrame(sourceFrame, level) {
        this.aiDataContract = {
            level: 1 /* FieldType.Required */,
            method: 1 /* FieldType.Required */,
            assembly: 0 /* FieldType.Default */,
            fileName: 0 /* FieldType.Default */,
            line: 0 /* FieldType.Default */
        };
        var _self = this;
        _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_SIZE_IN_BYTES /* @min:%2esizeInBytes */] = 0;
        // Not converting this to isString() as typescript uses this logic to "understand" the different
        // types for the 2 different code paths
        if (typeof sourceFrame === "string") {
            var frame = sourceFrame;
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LEVEL /* @min:%2elevel */] = level;
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_METHOD /* @min:%2emethod */] = NoMethod;
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_ASSEMBLY /* @min:%2eassembly */] = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.strTrim)(frame);
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_FILE_NAME /* @min:%2efileName */] = "";
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LINE /* @min:%2eline */] = 0;
            var matches = frame.match(_StackFrame.regex);
            if (matches && matches[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LENGTH /* @min:%2elength */] >= 5) {
                _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_METHOD /* @min:%2emethod */] = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.strTrim)(matches[2]) || _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_METHOD /* @min:%2emethod */];
                _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_FILE_NAME /* @min:%2efileName */] = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.strTrim)(matches[4]);
                _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LINE /* @min:%2eline */] = parseInt(matches[5]) || 0;
            }
        }
        else {
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LEVEL /* @min:%2elevel */] = sourceFrame[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LEVEL /* @min:%2elevel */];
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_METHOD /* @min:%2emethod */] = sourceFrame[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_METHOD /* @min:%2emethod */];
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_ASSEMBLY /* @min:%2eassembly */] = sourceFrame[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_ASSEMBLY /* @min:%2eassembly */];
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_FILE_NAME /* @min:%2efileName */] = sourceFrame[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_FILE_NAME /* @min:%2efileName */];
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LINE /* @min:%2eline */] = sourceFrame[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LINE /* @min:%2eline */];
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_SIZE_IN_BYTES /* @min:%2esizeInBytes */] = 0;
        }
        _self.sizeInBytes += _self.method[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LENGTH /* @min:%2elength */];
        _self.sizeInBytes += _self.fileName[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LENGTH /* @min:%2elength */];
        _self.sizeInBytes += _self.assembly[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LENGTH /* @min:%2elength */];
        // todo: these might need to be removed depending on how the back-end settles on their size calculation
        _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_SIZE_IN_BYTES /* @min:%2esizeInBytes */] += _StackFrame.baseSize;
        _self.sizeInBytes += _self.level.toString()[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LENGTH /* @min:%2elength */];
        _self.sizeInBytes += _self.line.toString()[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LENGTH /* @min:%2elength */];
    }
    _StackFrame.CreateFromInterface = function (frame) {
        return new _StackFrame(frame, null /* level is available in frame interface */);
    };
    _StackFrame.prototype.toInterface = function () {
        var _self = this;
        return {
            level: _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LEVEL /* @min:%2elevel */],
            method: _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_METHOD /* @min:%2emethod */],
            assembly: _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_ASSEMBLY /* @min:%2eassembly */],
            fileName: _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_FILE_NAME /* @min:%2efileName */],
            line: _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LINE /* @min:%2eline */]
        };
    };
    // regex to match stack frames from ie/chrome/ff
    // methodName=$2, fileName=$4, lineNo=$5, column=$6
    _StackFrame.regex = /^([\s]+at)?[\s]{0,50}([^\@\()]+?)[\s]{0,50}(\@|\()([^\(\n]+):([0-9]+):([0-9]+)(\)?)$/;
    _StackFrame.baseSize = 58; // '{"method":"","level":,"assembly":"","fileName":"","line":}'.length
    return _StackFrame;
}());

//# sourceMappingURL=Exception.js.map

/***/ }),
/* 103 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Metric": () => (/* binding */ Metric)
/* harmony export */ });
/* harmony import */ var _Constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(91);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(92);
/* harmony import */ var _Common_DataPoint__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(104);
/* harmony import */ var _Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(95);
/*
 * Application Insights JavaScript SDK - Common, 3.3.0
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */






var Metric = /** @class */ (function () {
    /**
     * Constructs a new instance of the MetricTelemetry object
     */
    function Metric(logger, name, value, count, min, max, stdDev, properties, measurements) {
        this.aiDataContract = {
            ver: 1 /* FieldType.Required */,
            metrics: 1 /* FieldType.Required */,
            properties: 0 /* FieldType.Default */
        };
        var _self = this;
        _self.ver = 2;
        var dataPoint = new _Common_DataPoint__WEBPACK_IMPORTED_MODULE_0__.DataPoint();
        dataPoint[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_COUNT /* @min:%2ecount */] = count > 0 ? count : undefined;
        dataPoint.max = isNaN(max) || max === null ? undefined : max;
        dataPoint.min = isNaN(min) || min === null ? undefined : min;
        dataPoint[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_NAME /* @min:%2ename */] = (0,_Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_2__.dataSanitizeString)(logger, name) || _Constants__WEBPACK_IMPORTED_MODULE_3__.strNotSpecified;
        dataPoint.value = value;
        dataPoint.stdDev = isNaN(stdDev) || stdDev === null ? undefined : stdDev;
        _self.metrics = [dataPoint];
        _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_PROPERTIES /* @min:%2eproperties */] = (0,_Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_2__.dataSanitizeProperties)(logger, properties);
        _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_MEASUREMENTS /* @min:%2emeasurements */] = (0,_Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_2__.dataSanitizeMeasurements)(logger, measurements);
    }
    Metric.envelopeType = "Microsoft.ApplicationInsights.{0}.Metric";
    Metric.dataType = "MetricData";
    return Metric;
}());

//# sourceMappingURL=Metric.js.map

/***/ }),
/* 104 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DataPoint": () => (/* binding */ DataPoint)
/* harmony export */ });
/*
 * Application Insights JavaScript SDK - Common, 3.3.0
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */


var DataPoint = /** @class */ (function () {
    function DataPoint() {
        /**
         * The data contract for serializing this object.
         */
        this.aiDataContract = {
            name: 1 /* FieldType.Required */,
            kind: 0 /* FieldType.Default */,
            value: 1 /* FieldType.Required */,
            count: 0 /* FieldType.Default */,
            min: 0 /* FieldType.Default */,
            max: 0 /* FieldType.Default */,
            stdDev: 0 /* FieldType.Default */
        };
        /**
         * Metric type. Single measurement or the aggregated value.
         */
        this.kind = 0 /* DataPointType.Measurement */;
    }
    return DataPoint;
}());

//# sourceMappingURL=DataPoint.js.map

/***/ }),
/* 105 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PageView": () => (/* binding */ PageView)
/* harmony export */ });
/* harmony import */ var _Constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(91);
/* harmony import */ var _HelperFuncs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(106);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(92);
/* harmony import */ var _Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(95);
/*
 * Application Insights JavaScript SDK - Common, 3.3.0
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */






var PageView = /** @class */ (function () {
    /**
     * Constructs a new instance of the PageEventTelemetry object
     */
    function PageView(logger, name, url, durationMs, properties, measurements, id) {
        this.aiDataContract = {
            ver: 1 /* FieldType.Required */,
            name: 0 /* FieldType.Default */,
            url: 0 /* FieldType.Default */,
            duration: 0 /* FieldType.Default */,
            properties: 0 /* FieldType.Default */,
            measurements: 0 /* FieldType.Default */,
            id: 0 /* FieldType.Default */
        };
        var _self = this;
        _self.ver = 2;
        _self.id = (0,_Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_0__.dataSanitizeId)(logger, id);
        _self.url = (0,_Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_0__.dataSanitizeUrl)(logger, url);
        _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_NAME /* @min:%2ename */] = (0,_Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_0__.dataSanitizeString)(logger, name) || _Constants__WEBPACK_IMPORTED_MODULE_2__.strNotSpecified;
        if (!isNaN(durationMs)) {
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_DURATION /* @min:%2eduration */] = (0,_HelperFuncs__WEBPACK_IMPORTED_MODULE_3__.msToTimeSpan)(durationMs);
        }
        _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_PROPERTIES /* @min:%2eproperties */] = (0,_Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_0__.dataSanitizeProperties)(logger, properties);
        _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_MEASUREMENTS /* @min:%2emeasurements */] = (0,_Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_0__.dataSanitizeMeasurements)(logger, measurements);
    }
    PageView.envelopeType = "Microsoft.ApplicationInsights.{0}.Pageview";
    PageView.dataType = "PageviewData";
    return PageView;
}());

//# sourceMappingURL=PageView.js.map

/***/ }),
/* 106 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getExtensionByName": () => (/* binding */ getExtensionByName),
/* harmony export */   "isCrossOriginError": () => (/* binding */ isCrossOriginError),
/* harmony export */   "msToTimeSpan": () => (/* binding */ msToTimeSpan),
/* harmony export */   "stringToBoolOrDefault": () => (/* binding */ stringToBoolOrDefault)
/* harmony export */ });
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(30);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(92);
/*
 * Application Insights JavaScript SDK - Common, 3.3.0
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */




var strEmpty = "";
function stringToBoolOrDefault(str, defaultValue) {
    if (defaultValue === void 0) { defaultValue = false; }
    if (str === undefined || str === null) {
        return defaultValue;
    }
    return str.toString()[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_TO_LOWER_CASE /* @min:%2etoLowerCase */]() === "true";
}
/**
 * Convert ms to c# time span format
 */
function msToTimeSpan(totalms) {
    if (isNaN(totalms) || totalms < 0) {
        totalms = 0;
    }
    totalms = Math.round(totalms);
    var ms = strEmpty + totalms % 1000;
    var sec = strEmpty + Math.floor(totalms / 1000) % 60;
    var min = strEmpty + Math.floor(totalms / (1000 * 60)) % 60;
    var hour = strEmpty + Math.floor(totalms / (1000 * 60 * 60)) % 24;
    var days = Math.floor(totalms / (1000 * 60 * 60 * 24));
    ms = ms[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_LENGTH /* @min:%2elength */] === 1 ? "00" + ms : ms[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_LENGTH /* @min:%2elength */] === 2 ? "0" + ms : ms;
    sec = sec[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_LENGTH /* @min:%2elength */] < 2 ? "0" + sec : sec;
    min = min[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_LENGTH /* @min:%2elength */] < 2 ? "0" + min : min;
    hour = hour[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_LENGTH /* @min:%2elength */] < 2 ? "0" + hour : hour;
    return (days > 0 ? days + "." : strEmpty) + hour + ":" + min + ":" + sec + "." + ms;
}
function getExtensionByName(extensions, identifier) {
    var extension = null;
    (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.arrForEach)(extensions, function (value) {
        if (value.identifier === identifier) {
            extension = value;
            return -1;
        }
    });
    return extension;
}
function isCrossOriginError(message, url, lineNumber, columnNumber, error) {
    return !error && (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.isString)(message) && (message === "Script error." || message === "Script error");
}
//# sourceMappingURL=HelperFuncs.js.map

/***/ }),
/* 107 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RemoteDependencyData": () => (/* binding */ RemoteDependencyData)
/* harmony export */ });
/* harmony import */ var _HelperFuncs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(106);
/* harmony import */ var _Util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(90);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(92);
/* harmony import */ var _Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(95);
/*
 * Application Insights JavaScript SDK - Common, 3.3.0
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */






var RemoteDependencyData = /** @class */ (function () {
    /**
     * Constructs a new instance of the RemoteDependencyData object
     */
    function RemoteDependencyData(logger, id, absoluteUrl, commandName, value, success, resultCode, method, requestAPI, correlationContext, properties, measurements) {
        if (requestAPI === void 0) { requestAPI = "Ajax"; }
        this.aiDataContract = {
            id: 1 /* FieldType.Required */,
            ver: 1 /* FieldType.Required */,
            name: 0 /* FieldType.Default */,
            resultCode: 0 /* FieldType.Default */,
            duration: 0 /* FieldType.Default */,
            success: 0 /* FieldType.Default */,
            data: 0 /* FieldType.Default */,
            target: 0 /* FieldType.Default */,
            type: 0 /* FieldType.Default */,
            properties: 0 /* FieldType.Default */,
            measurements: 0 /* FieldType.Default */,
            kind: 0 /* FieldType.Default */,
            value: 0 /* FieldType.Default */,
            count: 0 /* FieldType.Default */,
            min: 0 /* FieldType.Default */,
            max: 0 /* FieldType.Default */,
            stdDev: 0 /* FieldType.Default */,
            dependencyKind: 0 /* FieldType.Default */,
            dependencySource: 0 /* FieldType.Default */,
            commandName: 0 /* FieldType.Default */,
            dependencyTypeName: 0 /* FieldType.Default */
        };
        var _self = this;
        _self.ver = 2;
        _self.id = id;
        _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_DURATION /* @min:%2eduration */] = (0,_HelperFuncs__WEBPACK_IMPORTED_MODULE_1__.msToTimeSpan)(value);
        _self.success = success;
        _self.resultCode = resultCode + "";
        _self.type = (0,_Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_2__.dataSanitizeString)(logger, requestAPI);
        var dependencyFields = (0,_Util__WEBPACK_IMPORTED_MODULE_3__.AjaxHelperParseDependencyPath)(logger, absoluteUrl, method, commandName);
        _self.data = (0,_Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_2__.dataSanitizeUrl)(logger, commandName) || dependencyFields.data; // get a value from hosturl if commandName not available
        _self.target = (0,_Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_2__.dataSanitizeString)(logger, dependencyFields.target);
        if (correlationContext) {
            _self.target = "".concat(_self.target, " | ").concat(correlationContext);
        }
        _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_NAME /* @min:%2ename */] = (0,_Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_2__.dataSanitizeString)(logger, dependencyFields[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_NAME /* @min:%2ename */]);
        _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_PROPERTIES /* @min:%2eproperties */] = (0,_Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_2__.dataSanitizeProperties)(logger, properties);
        _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_MEASUREMENTS /* @min:%2emeasurements */] = (0,_Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_2__.dataSanitizeMeasurements)(logger, measurements);
    }
    RemoteDependencyData.envelopeType = "Microsoft.ApplicationInsights.{0}.RemoteDependency";
    RemoteDependencyData.dataType = "RemoteDependencyData";
    return RemoteDependencyData;
}());

//# sourceMappingURL=RemoteDependencyData.js.map

/***/ }),
/* 108 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Trace": () => (/* binding */ Trace)
/* harmony export */ });
/* harmony import */ var _Constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(91);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(92);
/* harmony import */ var _Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(95);
/*
 * Application Insights JavaScript SDK - Common, 3.3.0
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */





var Trace = /** @class */ (function () {
    /**
     * Constructs a new instance of the TraceTelemetry object
     */
    function Trace(logger, message, severityLevel, properties, measurements) {
        this.aiDataContract = {
            ver: 1 /* FieldType.Required */,
            message: 1 /* FieldType.Required */,
            severityLevel: 0 /* FieldType.Default */,
            properties: 0 /* FieldType.Default */
        };
        var _self = this;
        _self.ver = 2;
        message = message || _Constants__WEBPACK_IMPORTED_MODULE_0__.strNotSpecified;
        _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_MESSAGE /* @min:%2emessage */] = (0,_Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_2__.dataSanitizeMessage)(logger, message);
        _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_PROPERTIES /* @min:%2eproperties */] = (0,_Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_2__.dataSanitizeProperties)(logger, properties);
        _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_MEASUREMENTS /* @min:%2emeasurements */] = (0,_Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_2__.dataSanitizeMeasurements)(logger, measurements);
        if (severityLevel) {
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_SEVERITY_LEVEL /* @min:%2eseverityLevel */] = severityLevel;
        }
    }
    Trace.envelopeType = "Microsoft.ApplicationInsights.{0}.Message";
    Trace.dataType = "MessageData";
    return Trace;
}());

//# sourceMappingURL=Trace.js.map

/***/ }),
/* 109 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PageViewPerformance": () => (/* binding */ PageViewPerformance)
/* harmony export */ });
/* harmony import */ var _Constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(91);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(92);
/* harmony import */ var _Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(95);
/*
 * Application Insights JavaScript SDK - Common, 3.3.0
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */





var PageViewPerformance = /** @class */ (function () {
    /**
     * Constructs a new instance of the PageEventTelemetry object
     */
    function PageViewPerformance(logger, name, url, unused, properties, measurements, cs4BaseData) {
        this.aiDataContract = {
            ver: 1 /* FieldType.Required */,
            name: 0 /* FieldType.Default */,
            url: 0 /* FieldType.Default */,
            duration: 0 /* FieldType.Default */,
            perfTotal: 0 /* FieldType.Default */,
            networkConnect: 0 /* FieldType.Default */,
            sentRequest: 0 /* FieldType.Default */,
            receivedResponse: 0 /* FieldType.Default */,
            domProcessing: 0 /* FieldType.Default */,
            properties: 0 /* FieldType.Default */,
            measurements: 0 /* FieldType.Default */
        };
        var _self = this;
        _self.ver = 2;
        _self.url = (0,_Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_0__.dataSanitizeUrl)(logger, url);
        _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_NAME /* @min:%2ename */] = (0,_Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_0__.dataSanitizeString)(logger, name) || _Constants__WEBPACK_IMPORTED_MODULE_2__.strNotSpecified;
        _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_PROPERTIES /* @min:%2eproperties */] = (0,_Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_0__.dataSanitizeProperties)(logger, properties);
        _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_MEASUREMENTS /* @min:%2emeasurements */] = (0,_Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_0__.dataSanitizeMeasurements)(logger, measurements);
        if (cs4BaseData) {
            _self.domProcessing = cs4BaseData.domProcessing;
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_DURATION /* @min:%2eduration */] = cs4BaseData[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_DURATION /* @min:%2eduration */];
            _self.networkConnect = cs4BaseData.networkConnect;
            _self.perfTotal = cs4BaseData.perfTotal;
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_RECEIVED_RESPONSE /* @min:%2ereceivedResponse */] = cs4BaseData[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_RECEIVED_RESPONSE /* @min:%2ereceivedResponse */];
            _self.sentRequest = cs4BaseData.sentRequest;
        }
    }
    PageViewPerformance.envelopeType = "Microsoft.ApplicationInsights.{0}.PageviewPerformance";
    PageViewPerformance.dataType = "PageviewPerformanceData";
    return PageViewPerformance;
}());

//# sourceMappingURL=PageViewPerformance.js.map

/***/ }),
/* 110 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Data": () => (/* binding */ Data)
/* harmony export */ });
/*
 * Application Insights JavaScript SDK - Common, 3.3.0
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */


var Data = /** @class */ (function () {
    /**
     * Constructs a new instance of telemetry data.
     */
    function Data(baseType, data) {
        /**
         * The data contract for serializing this object.
         */
        this.aiDataContract = {
            baseType: 1 /* FieldType.Required */,
            baseData: 1 /* FieldType.Required */
        };
        this.baseType = baseType;
        this.baseData = data;
    }
    return Data;
}());

//# sourceMappingURL=Data.js.map

/***/ }),
/* 111 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SeverityLevel": () => (/* binding */ SeverityLevel)
/* harmony export */ });
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(29);
/*
 * Application Insights JavaScript SDK - Common, 3.3.0
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */



/**
 * Defines the level of severity for the event.
 */
var SeverityLevel = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.createEnumStyle)({
    Verbose: 0 /* eSeverityLevel.Verbose */,
    Information: 1 /* eSeverityLevel.Information */,
    Warning: 2 /* eSeverityLevel.Warning */,
    Error: 3 /* eSeverityLevel.Error */,
    Critical: 4 /* eSeverityLevel.Critical */
});
//# sourceMappingURL=SeverityLevel.js.map

/***/ }),
/* 112 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ConfigurationManager": () => (/* binding */ ConfigurationManager)
/* harmony export */ });
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(30);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(92);
/*
 * Application Insights JavaScript SDK - Common, 3.3.0
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */




var ConfigurationManager = /** @class */ (function () {
    function ConfigurationManager() {
    }
    ConfigurationManager.getConfig = function (config, field, identifier, defaultValue) {
        if (defaultValue === void 0) { defaultValue = false; }
        var configValue;
        if (identifier && config[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_EXTENSION_CONFIG /* @min:%2eextensionConfig */] && config[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_EXTENSION_CONFIG /* @min:%2eextensionConfig */][identifier] && !(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(config[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_EXTENSION_CONFIG /* @min:%2eextensionConfig */][identifier][field])) {
            configValue = config[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_EXTENSION_CONFIG /* @min:%2eextensionConfig */][identifier][field];
        }
        else {
            configValue = config[field];
        }
        return !(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(configValue) ? configValue : defaultValue;
    };
    return ConfigurationManager;
}());

//# sourceMappingURL=IConfig.js.map

/***/ }),
/* 113 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ContextTagKeys": () => (/* binding */ ContextTagKeys)
/* harmony export */ });
/* harmony import */ var _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(33);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(45);
/*
 * Application Insights JavaScript SDK - Common, 3.3.0
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */




function _aiNameFunc(baseName) {
    var aiName = "ai." + baseName + ".";
    return function (name) {
        return aiName + name;
    };
}
var _aiApplication = _aiNameFunc("application");
var _aiDevice = _aiNameFunc("device");
var _aiLocation = _aiNameFunc("location");
var _aiOperation = _aiNameFunc("operation");
var _aiSession = _aiNameFunc("session");
var _aiUser = _aiNameFunc("user");
var _aiCloud = _aiNameFunc("cloud");
var _aiInternal = _aiNameFunc("internal");
var ContextTagKeys = /** @class */ (function (_super) {
    (0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_0__.__extendsFn)(ContextTagKeys, _super);
    function ContextTagKeys() {
        return _super.call(this) || this;
    }
    return ContextTagKeys;
}((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.createClassFromInterface)({
    applicationVersion: _aiApplication("ver"),
    applicationBuild: _aiApplication("build"),
    applicationTypeId: _aiApplication("typeId"),
    applicationId: _aiApplication("applicationId"),
    applicationLayer: _aiApplication("layer"),
    deviceId: _aiDevice("id"),
    deviceIp: _aiDevice("ip"),
    deviceLanguage: _aiDevice("language"),
    deviceLocale: _aiDevice("locale"),
    deviceModel: _aiDevice("model"),
    deviceFriendlyName: _aiDevice("friendlyName"),
    deviceNetwork: _aiDevice("network"),
    deviceNetworkName: _aiDevice("networkName"),
    deviceOEMName: _aiDevice("oemName"),
    deviceOS: _aiDevice("os"),
    deviceOSVersion: _aiDevice("osVersion"),
    deviceRoleInstance: _aiDevice("roleInstance"),
    deviceRoleName: _aiDevice("roleName"),
    deviceScreenResolution: _aiDevice("screenResolution"),
    deviceType: _aiDevice("type"),
    deviceMachineName: _aiDevice("machineName"),
    deviceVMName: _aiDevice("vmName"),
    deviceBrowser: _aiDevice("browser"),
    deviceBrowserVersion: _aiDevice("browserVersion"),
    locationIp: _aiLocation("ip"),
    locationCountry: _aiLocation("country"),
    locationProvince: _aiLocation("province"),
    locationCity: _aiLocation("city"),
    operationId: _aiOperation("id"),
    operationName: _aiOperation("name"),
    operationParentId: _aiOperation("parentId"),
    operationRootId: _aiOperation("rootId"),
    operationSyntheticSource: _aiOperation("syntheticSource"),
    operationCorrelationVector: _aiOperation("correlationVector"),
    sessionId: _aiSession("id"),
    sessionIsFirst: _aiSession("isFirst"),
    sessionIsNew: _aiSession("isNew"),
    userAccountAcquisitionDate: _aiUser("accountAcquisitionDate"),
    userAccountId: _aiUser("accountId"),
    userAgent: _aiUser("userAgent"),
    userId: _aiUser("id"),
    userStoreRegion: _aiUser("storeRegion"),
    userAuthUserId: _aiUser("authUserId"),
    userAnonymousUserAcquisitionDate: _aiUser("anonUserAcquisitionDate"),
    userAuthenticatedUserAcquisitionDate: _aiUser("authUserAcquisitionDate"),
    cloudName: _aiCloud("name"),
    cloudRole: _aiCloud("role"),
    cloudRoleVer: _aiCloud("roleVer"),
    cloudRoleInstance: _aiCloud("roleInstance"),
    cloudEnvironment: _aiCloud("environment"),
    cloudLocation: _aiCloud("location"),
    cloudDeploymentUnit: _aiCloud("deploymentUnit"),
    internalNodeName: _aiInternal("nodeName"),
    internalSdkVersion: _aiInternal("sdkVersion"),
    internalAgentVersion: _aiInternal("agentVersion"),
    internalSnippet: _aiInternal("snippet"),
    internalSdkSrc: _aiInternal("sdkSrc")
})));

//# sourceMappingURL=ContextTagKeys.js.map

/***/ }),
/* 114 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TelemetryItemCreator": () => (/* binding */ TelemetryItemCreator),
/* harmony export */   "createTelemetryItem": () => (/* binding */ createTelemetryItem)
/* harmony export */ });
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(30);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(45);
/* harmony import */ var _Constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(91);
/* harmony import */ var _Telemetry_Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(95);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(92);
/*
 * Application Insights JavaScript SDK - Common, 3.3.0
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */






/**
 * Create a telemetry item that the 1DS channel understands
 * @param item - domain specific properties; part B
 * @param baseType - telemetry item type. ie PageViewData
 * @param envelopeName - name of the envelope. ie Microsoft.ApplicationInsights.<instrumentation key>.PageView
 * @param customProperties - user defined custom properties; part C
 * @param systemProperties - system properties that are added to the context; part A
 * @returns ITelemetryItem that is sent to channel
 */
function createTelemetryItem(item, baseType, envelopeName, logger, customProperties, systemProperties) {
    var _a;
    envelopeName = (0,_Telemetry_Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_0__.dataSanitizeString)(logger, envelopeName) || _Constants__WEBPACK_IMPORTED_MODULE_1__.strNotSpecified;
    if ((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__.isNullOrUndefined)(item) ||
        (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__.isNullOrUndefined)(baseType) ||
        (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__.isNullOrUndefined)(envelopeName)) {
        (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__.throwError)("Input doesn't contain all required fields");
    }
    var iKey = "";
    if (item[_Constants__WEBPACK_IMPORTED_MODULE_1__.strIkey]) {
        iKey = item[_Constants__WEBPACK_IMPORTED_MODULE_1__.strIkey];
        delete item[_Constants__WEBPACK_IMPORTED_MODULE_1__.strIkey];
    }
    var telemetryItem = (_a = {},
        _a[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_NAME /* @min:name */] = envelopeName,
        _a.time = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_4__.toISOString)(new Date()),
        _a.iKey = iKey,
        _a.ext = systemProperties ? systemProperties : {},
        _a.tags = [],
        _a.data = {},
        _a.baseType = baseType,
        _a.baseData = item // Part B
    ,
        _a);
    // Part C
    if (!(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__.isNullOrUndefined)(customProperties)) {
        (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__.objForEachKey)(customProperties, function (prop, value) {
            telemetryItem.data[prop] = value;
        });
    }
    return telemetryItem;
}
var TelemetryItemCreator = /** @class */ (function () {
    function TelemetryItemCreator() {
    }
    /**
     * Create a telemetry item that the 1DS channel understands
     * @param item - domain specific properties; part B
     * @param baseType - telemetry item type. ie PageViewData
     * @param envelopeName - name of the envelope. ie Microsoft.ApplicationInsights.<instrumentation key>.PageView
     * @param customProperties - user defined custom properties; part C
     * @param systemProperties - system properties that are added to the context; part A
     * @returns ITelemetryItem that is sent to channel
     */
    TelemetryItemCreator.create = createTelemetryItem;
    return TelemetryItemCreator;
}());

//# sourceMappingURL=TelemetryItemCreator.js.map

/***/ }),
/* 115 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CtxTagKeys": () => (/* binding */ CtxTagKeys),
/* harmony export */   "Extensions": () => (/* binding */ Extensions)
/* harmony export */ });
/* harmony import */ var _Contracts_ContextTagKeys__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(113);
/*
 * Application Insights JavaScript SDK - Common, 3.3.0
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */

var Extensions = {
    UserExt: "user",
    DeviceExt: "device",
    TraceExt: "trace",
    WebExt: "web",
    AppExt: "app",
    OSExt: "os",
    SessionExt: "ses",
    SDKExt: "sdk"
};
var CtxTagKeys = new _Contracts_ContextTagKeys__WEBPACK_IMPORTED_MODULE_0__.ContextTagKeys();
//# sourceMappingURL=PartAExtensions.js.map

/***/ }),
/* 116 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createDomEvent": () => (/* binding */ createDomEvent)
/* harmony export */ });
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(30);
/*
 * Application Insights JavaScript SDK - Common, 3.3.0
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */



function createDomEvent(eventName) {
    var event = null;
    if ((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.isFunction)(Event)) { // Use Event constructor when available
        event = new Event(eventName);
    }
    else { // Event has no constructor in IE
        var doc = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.getDocument)();
        if (doc && doc.createEvent) {
            event = doc.createEvent("Event");
            event.initEvent(eventName, true, true);
        }
    }
    return event;
}
//# sourceMappingURL=DomHelperFuncs.js.map

/***/ }),
/* 117 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createOfflineListener": () => (/* binding */ createOfflineListener)
/* harmony export */ });
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(73);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(30);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(42);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(92);
/*
 * Application Insights JavaScript SDK - Common, 3.3.0
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */


function _disableEvents(target, evtNamespace) {
    (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.eventOff)(target, null, null, evtNamespace);
}
/**
 * Create a new OfflineListener instance to monitor browser online / offline events
 * @param parentEvtNamespace - The parent event namespace to append to any specific events for this instance
 */
function createOfflineListener(parentEvtNamespace) {
    var _document = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.getDocument)();
    var _navigator = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.getNavigator)(); // Gets the window.navigator or workerNavigator depending on the global
    var _isListening = false;
    var listenerList = [];
    // Set the initial state
    // rState is changed by the browser, both via events and when we check the navigator.onLine property
    var rState = 1 /* eOfflineValue.Online */;
    if (_navigator && !(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(_navigator.onLine) && !_navigator.onLine) { // navigator.onLine is undefined in react-native
        rState = 2 /* eOfflineValue.Offline */;
    }
    // ustate is changed by the user calling setOnlineState
    var uState = 0 /* eOfflineValue.Unknown */;
    // current state would be updated each time rState or uState is changed
    // it is a resolved value of rState and uState
    var _currentState = calCurrentState();
    var _evtNamespace = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.mergeEvtNamespace)((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__.createUniqueNamespace)("OfflineListener"), parentEvtNamespace);
    try {
        if (_enableEvents((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.getWindow)())) {
            _isListening = true;
        }
        if (_document) {
            // Also attach to the document.body or document
            var target = _document.body || _document;
            if (target.ononline) {
                if (_enableEvents(target)) {
                    _isListening = true;
                }
            }
        }
    }
    catch (e) {
        // this makes react-native less angry
        _isListening = false;
    }
    function _enableEvents(target) {
        var enabled = false;
        if (target) {
            enabled = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.eventOn)(target, "online", _setOnline, _evtNamespace);
            if (enabled) {
                (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.eventOn)(target, "offline", _setOffline, _evtNamespace);
            }
        }
        return enabled;
    }
    function _isOnline() {
        return _currentState;
    }
    function calCurrentState() {
        if (uState === 2 /* eOfflineValue.Offline */ || rState === 2 /* eOfflineValue.Offline */) {
            return false;
        }
        return true; // if both unknown, then we assume the network is good
    }
    function listnerNoticeCheck() {
        // we were offline and are now online or we were online and now offline
        var newState = calCurrentState();
        if (_currentState !== newState) {
            _currentState = newState; // use the resolved state to update
            // send all the callbacks with the current state
            (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.arrForEach)(listenerList, function (callback) {
                var offlineState = {
                    isOnline: _currentState,
                    rState: rState,
                    uState: uState
                };
                try {
                    callback(offlineState);
                }
                catch (e) {
                    // Do nothing, just making sure we run all of the callbacks
                }
            });
        }
    }
    function setOnlineState(newState) {
        uState = newState;
        listnerNoticeCheck();
    }
    function _setOnline() {
        rState = 1 /* eOfflineValue.Online */;
        listnerNoticeCheck();
    }
    function _setOffline() {
        rState = 2 /* eOfflineValue.Offline */;
        listnerNoticeCheck();
    }
    function _unload() {
        var win = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.getWindow)();
        if (win && _isListening) {
            _disableEvents(win, _evtNamespace);
            if (_document) {
                // Also attach to the document.body or document
                var target = _document.body || _document;
                if (!(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.isUndefined)(target.ononline)) {
                    _disableEvents(target, _evtNamespace);
                }
            }
            _isListening = false;
        }
    }
    function addListener(callback) {
        listenerList[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_PUSH /* @min:%2epush */](callback);
        // Define rm as an instance of IUnloadHook
        return {
            rm: function () {
                var index = listenerList.indexOf(callback);
                if (index > -1) {
                    return listenerList.splice(index, 1);
                }
                else {
                    return;
                }
            }
        };
    }
    return {
        isOnline: _isOnline,
        isListening: function () { return _isListening; },
        unload: _unload,
        addListener: addListener,
        setOnlineState: setOnlineState
    };
}
//# sourceMappingURL=Offline.js.map

/***/ }),
/* 118 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AppInsightsCore": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.AppInsightsCore),
/* harmony export */   "ApplicationInsights": () => (/* binding */ ApplicationInsights),
/* harmony export */   "Sender": () => (/* reexport safe */ _microsoft_applicationinsights_channel_js__WEBPACK_IMPORTED_MODULE_10__.Sender),
/* harmony export */   "SeverityLevel": () => (/* reexport safe */ _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_11__.SeverityLevel),
/* harmony export */   "arrForEach": () => (/* reexport safe */ _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_2__.arrForEach),
/* harmony export */   "isNullOrUndefined": () => (/* reexport safe */ _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_2__.isNullOrUndefined),
/* harmony export */   "proxyFunctions": () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_5__.proxyFunctions),
/* harmony export */   "throwError": () => (/* reexport safe */ _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_2__.throwError)
/* harmony export */ });
/* harmony import */ var _microsoft_dynamicproto_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(35);
/* harmony import */ var _microsoft_applicationinsights_channel_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(120);
/* harmony import */ var _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(99);
/* harmony import */ var _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(91);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(59);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(54);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(45);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(40);
/* harmony import */ var _nevware21_ts_async__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(56);
/* harmony import */ var _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(30);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(119);
/* harmony import */ var _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(111);
/*
 * Application Insights JavaScript Web SDK - Basic, 3.3.0
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */









var defaultConfigValues = {
    diagnosticLogInterval: (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.cfgDfValidate)(_chkDiagLevel, 10000)
};
function _chkDiagLevel(value) {
    // Make sure we have a value > 0
    return value && value > 0;
}
/**
 * @export
 * @class ApplicationInsights
 */
var ApplicationInsights = /** @class */ (function () {
    /**
     * Creates an instance of ApplicationInsights.
     * @param config
     * @memberof ApplicationInsights
     */
    function ApplicationInsights(config) {
        var core = new _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.AppInsightsCore();
        var _config;
        // initialize the queue and config in case they are undefined
        if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_2__.isNullOrUndefined)(config) ||
            ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_2__.isNullOrUndefined)(config[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_INSTRUMENTATION_KEY /* @min:%2einstrumentationKey */]) && (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_2__.isNullOrUndefined)(config[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_CONNECTION_STRING /* @min:%2econnectionString */]))) {
            (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_2__.throwError)("Invalid input configuration");
        }
        (0,_microsoft_dynamicproto_js__WEBPACK_IMPORTED_MODULE_4__["default"])(ApplicationInsights, this, function (_self) {
            // Define _self.config
            (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_2__.objDefine)(_self, "config", {
                g: function () { return _config; }
            });
            _initialize();
            _self.initialize = _initialize;
            _self.track = _track;
            (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_5__.proxyFunctions)(_self, core, [
                "flush",
                "pollInternalLogs",
                "stopPollingInternalLogs",
                "unload",
                "getPlugin",
                "addPlugin",
                "evtNamespace",
                "addUnloadCb",
                "onCfgChange"
            ]);
            function _initialize() {
                var cfgHandler = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_6__.createDynamicConfig)(config || {}, defaultConfigValues);
                _config = cfgHandler.cfg;
                core.addUnloadHook((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_6__.onConfigChange)(cfgHandler, function () {
                    var configCs = _config[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_CONNECTION_STRING /* @min:%2econnectionString */];
                    if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_2__.isPromiseLike)(configCs)) {
                        var ikeyPromise = (0,_nevware21_ts_async__WEBPACK_IMPORTED_MODULE_7__.createAsyncPromise)(function (resolve, reject) {
                            (0,_nevware21_ts_async__WEBPACK_IMPORTED_MODULE_7__.doAwaitResponse)(configCs, function (res) {
                                var curCs = res.value;
                                var ikey = _config[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_INSTRUMENTATION_KEY /* @min:%2einstrumentationKey */];
                                if (!res.rejected && curCs) {
                                    // replace cs with resolved values in case of circular promises
                                    _config[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_CONNECTION_STRING /* @min:%2econnectionString */] = curCs;
                                    var resolvedCs = (0,_microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_8__.parseConnectionString)(curCs);
                                    ikey = resolvedCs[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_INSTRUMENTATIONKEY0 /* @min:%2einstrumentationkey */] || ikey;
                                }
                                resolve(ikey);
                            });
                        });
                        var urlPromise = (0,_nevware21_ts_async__WEBPACK_IMPORTED_MODULE_7__.createAsyncPromise)(function (resolve, reject) {
                            (0,_nevware21_ts_async__WEBPACK_IMPORTED_MODULE_7__.doAwaitResponse)(configCs, function (res) {
                                var curCs = res.value;
                                var url = _config[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_ENDPOINT_URL /* @min:%2eendpointUrl */];
                                if (!res.rejected && curCs) {
                                    var resolvedCs = (0,_microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_8__.parseConnectionString)(curCs);
                                    var ingest = resolvedCs[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_INGESTIONENDPOINT /* @min:%2eingestionendpoint */];
                                    url = ingest ? ingest + _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_9__.DEFAULT_BREEZE_PATH : url;
                                }
                                resolve(url);
                            });
                        });
                        _config[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_INSTRUMENTATION_KEY /* @min:%2einstrumentationKey */] = ikeyPromise;
                        _config[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_ENDPOINT_URL /* @min:%2eendpointUrl */] = _config[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_USER_OVERRIDE_ENDPOI1 /* @min:%2euserOverrideEndpointUrl */] || urlPromise;
                    }
                    if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_2__.isString)(configCs)) {
                        var cs = (0,_microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_8__.parseConnectionString)(configCs);
                        var ingest = cs[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_INGESTIONENDPOINT /* @min:%2eingestionendpoint */];
                        _config[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_ENDPOINT_URL /* @min:%2eendpointUrl */] = _config[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_USER_OVERRIDE_ENDPOI1 /* @min:%2euserOverrideEndpointUrl */] ? _config[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_USER_OVERRIDE_ENDPOI1 /* @min:%2euserOverrideEndpointUrl */] : (ingest + _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_9__.DEFAULT_BREEZE_PATH); // only add /v2/track when from connectionstring
                        _config[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_INSTRUMENTATION_KEY /* @min:%2einstrumentationKey */] = cs[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_INSTRUMENTATIONKEY0 /* @min:%2einstrumentationkey */] || _config[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_INSTRUMENTATION_KEY /* @min:%2einstrumentationKey */];
                    }
                    // userOverrideEndpointUrl have the highest priority
                    _config[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_ENDPOINT_URL /* @min:%2eendpointUrl */] = _config[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_USER_OVERRIDE_ENDPOI1 /* @min:%2euserOverrideEndpointUrl */] ? _config[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_USER_OVERRIDE_ENDPOI1 /* @min:%2euserOverrideEndpointUrl */] : _config[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_ENDPOINT_URL /* @min:%2eendpointUrl */];
                }));
                // initialize core
                core.initialize(_config, [new _microsoft_applicationinsights_channel_js__WEBPACK_IMPORTED_MODULE_10__.Sender()]);
            }
        });
        function _track(item) {
            if (item) {
                // to pass sender.processTelemetry()
                item.baseData = item.baseData || {};
                item.baseType = item.baseType || "EventData";
            }
            core.track(item);
        }
    }
// Removed Stub for ApplicationInsights.prototype.initialize.
// Removed Stub for ApplicationInsights.prototype.track.
// Removed Stub for ApplicationInsights.prototype.flush.
// Removed Stub for ApplicationInsights.prototype.pollInternalLogs.
// Removed Stub for ApplicationInsights.prototype.stopPollingInternalLogs.
// Removed Stub for ApplicationInsights.prototype.unload.
// Removed Stub for ApplicationInsights.prototype.getPlugin.
// Removed Stub for ApplicationInsights.prototype.addPlugin.
// Removed Stub for ApplicationInsights.prototype.evtNamespace.
// Removed Stub for ApplicationInsights.prototype.addUnloadCb.
// Removed Stub for ApplicationInsights.prototype.onCfgChange.
    // This is a workaround for an IE bug when using dynamicProto() with classes that don't have any
    // non-dynamic functions or static properties/functions when using uglify-js to minify the resulting code.
    ApplicationInsights.__ieDyn=1;

    return ApplicationInsights;
}());




//# sourceMappingURL=index.js.map

/***/ }),
/* 119 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "_DYN_CONNECTION_STRING": () => (/* binding */ _DYN_CONNECTION_STRING),
/* harmony export */   "_DYN_ENDPOINT_URL": () => (/* binding */ _DYN_ENDPOINT_URL),
/* harmony export */   "_DYN_INGESTIONENDPOINT": () => (/* binding */ _DYN_INGESTIONENDPOINT),
/* harmony export */   "_DYN_INSTRUMENTATIONKEY0": () => (/* binding */ _DYN_INSTRUMENTATIONKEY0),
/* harmony export */   "_DYN_INSTRUMENTATION_KEY": () => (/* binding */ _DYN_INSTRUMENTATION_KEY),
/* harmony export */   "_DYN_USER_OVERRIDE_ENDPOI1": () => (/* binding */ _DYN_USER_OVERRIDE_ENDPOI1)
/* harmony export */ });
/*
 * Application Insights JavaScript Web SDK - Basic, 3.3.0
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */


// @skip-file-minify
// ##############################################################
// AUTO GENERATED FILE: This file is Auto Generated during build.
// ##############################################################
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// Note: DON'T Export these const from the package as we are still targeting ES3 this will export a mutable variables that someone could change!!!
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
var _DYN_INSTRUMENTATION_KEY = "instrumentationKey"; // Count: 5
var _DYN_CONNECTION_STRING = "connectionString"; // Count: 3
var _DYN_INSTRUMENTATIONKEY0 = "instrumentationkey"; // Count: 2
var _DYN_ENDPOINT_URL = "endpointUrl"; // Count: 5
var _DYN_INGESTIONENDPOINT = "ingestionendpoint"; // Count: 2
var _DYN_USER_OVERRIDE_ENDPOI1 = "userOverrideEndpointUrl"; // Count: 5
//# sourceMappingURL=__DynamicConstants.js.map

/***/ }),
/* 120 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Sender": () => (/* binding */ Sender)
/* harmony export */ });
/* harmony import */ var _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(33);
/* harmony import */ var _microsoft_dynamicproto_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(35);
/* harmony import */ var _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(91);
/* harmony import */ var _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(101);
/* harmony import */ var _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(108);
/* harmony import */ var _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(105);
/* harmony import */ var _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(109);
/* harmony import */ var _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(102);
/* harmony import */ var _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(103);
/* harmony import */ var _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(107);
/* harmony import */ var _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(89);
/* harmony import */ var _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(117);
/* harmony import */ var _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(97);
/* harmony import */ var _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(90);
/* harmony import */ var _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(94);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(59);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(50);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(45);
/* harmony import */ var _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(30);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(73);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(42);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(40);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(61);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(55);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(44);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(74);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(60);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(75);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(65);
/* harmony import */ var _EnvelopeCreator__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(122);
/* harmony import */ var _SendBuffer__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(125);
/* harmony import */ var _Serializer__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(124);
/* harmony import */ var _TelemetryProcessors_Sample__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(126);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(121);
/*
 * Application Insights JavaScript SDK - Channel, 3.3.0
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */
var _a, _b;










var UNDEFINED_VALUE = undefined;
var EMPTY_STR = "";
var FetchSyncRequestSizeLimitBytes = 65000; // approx 64kb (the current Edge, Firefox and Chrome max limit)
function _getResponseText(xhr) {
    try {
        return xhr.responseText;
    }
    catch (e) {
        // Best effort, as XHR may throw while XDR wont so just ignore
    }
    return null;
}
function isOverrideFn(httpXHROverride) {
    return httpXHROverride && httpXHROverride.sendPOST;
}
var defaultAppInsightsChannelConfig = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objDeepFreeze)((_a = {
        // Use the default value (handles empty string in the configuration)
        endpointUrl: (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.cfgDfValidate)(_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isTruthy, _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_BREEZE_ENDPOINT + _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_BREEZE_PATH)
    },
    _a[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_EMIT_LINE_DELIMITED_0 /* @min:emitLineDelimitedJson */] = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.cfgDfBoolean)(),
    _a[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_MAX_BATCH_INTERVAL /* @min:maxBatchInterval */] = 15000,
    _a[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_MAX_BATCH_SIZE_IN_BY1 /* @min:maxBatchSizeInBytes */] = 102400,
    _a.disableTelemetry = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.cfgDfBoolean)(),
    _a[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_ENABLE_SESSION_STORA5 /* @min:enableSessionStorageBuffer */] = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.cfgDfBoolean)(true),
    _a.isRetryDisabled = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.cfgDfBoolean)(),
    _a[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_IS_BEACON_API_DISABL3 /* @min:isBeaconApiDisabled */] = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.cfgDfBoolean)(true),
    _a[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_DISABLE_SEND_BEACON_7 /* @min:disableSendBeaconSplit */] = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.cfgDfBoolean)(true),
    _a[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_DISABLE_XHR /* @min:disableXhr */] = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.cfgDfBoolean)(),
    _a[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_ONUNLOAD_DISABLE_FET6 /* @min:onunloadDisableFetch */] = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.cfgDfBoolean)(),
    _a[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_ONUNLOAD_DISABLE_BEA2 /* @min:onunloadDisableBeacon */] = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.cfgDfBoolean)(),
    _a[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_INSTRUMENTATION_KEY /* @min:instrumentationKey */] = UNDEFINED_VALUE,
    _a.namePrefix = UNDEFINED_VALUE,
    _a.samplingPercentage = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.cfgDfValidate)(_chkSampling, 100),
    _a[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_CUSTOM_HEADERS /* @min:customHeaders */] = UNDEFINED_VALUE,
    _a[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_CONVERT_UNDEFINED /* @min:convertUndefined */] = UNDEFINED_VALUE,
    _a[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_EVENTS_LIMIT_IN_MEM /* @min:eventsLimitInMem */] = 10000,
    _a[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_BUFFER_OVERRIDE /* @min:bufferOverride */] = false,
    _a.httpXHROverride = { isVal: isOverrideFn, v: UNDEFINED_VALUE },
    _a[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_ALWAYS_USE_XHR_OVERR4 /* @min:alwaysUseXhrOverride */] = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.cfgDfBoolean)(),
    _a.transports = UNDEFINED_VALUE,
    _a.retryCodes = UNDEFINED_VALUE,
    _a.maxRetryCnt = { isVal: _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isNumber, v: 10 },
    _a));
function _chkSampling(value) {
    return !isNaN(value) && value > 0 && value <= 100;
}
var EnvelopeTypeCreator = (_b = {},
    _b[_microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_4__.Event.dataType] = _EnvelopeCreator__WEBPACK_IMPORTED_MODULE_5__.EventEnvelopeCreator,
    _b[_microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_6__.Trace.dataType] = _EnvelopeCreator__WEBPACK_IMPORTED_MODULE_5__.TraceEnvelopeCreator,
    _b[_microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_7__.PageView.dataType] = _EnvelopeCreator__WEBPACK_IMPORTED_MODULE_5__.PageViewEnvelopeCreator,
    _b[_microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_8__.PageViewPerformance.dataType] = _EnvelopeCreator__WEBPACK_IMPORTED_MODULE_5__.PageViewPerformanceEnvelopeCreator,
    _b[_microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_9__.Exception.dataType] = _EnvelopeCreator__WEBPACK_IMPORTED_MODULE_5__.ExceptionEnvelopeCreator,
    _b[_microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_10__.Metric.dataType] = _EnvelopeCreator__WEBPACK_IMPORTED_MODULE_5__.MetricEnvelopeCreator,
    _b[_microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_11__.RemoteDependencyData.dataType] = _EnvelopeCreator__WEBPACK_IMPORTED_MODULE_5__.DependencyEnvelopeCreator,
    _b);
var Sender = /** @class */ (function (_super) {
    (0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_12__.__extendsFn)(Sender, _super);
    function Sender() {
        var _this = _super.call(this) || this;
        _this.priority = 1001;
        _this.identifier = _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_13__.BreezeChannelIdentifier;
        // Don't set the defaults here, set them in the _initDefaults() as this is also called during unload
        var _consecutiveErrors; // How many times in a row a retryable error condition has occurred.
        var _retryAt; // The time to retry at in milliseconds from 1970/01/01 (this makes the timer calculation easy).
        var _lastSend; // The time of the last send operation.
        var _paused; // Flag indicating that the sending should be paused
        var _timeoutHandle; // Handle to the timer for delayed sending of batches of data.
        var _serializer;
        var _stamp_specific_redirects;
        var _headers;
        var _syncFetchPayload = 0; // Keep track of the outstanding sync fetch payload total (as sync fetch has limits)
        var _syncUnloadSender; // The identified sender to use for the synchronous unload stage
        var _offlineListener;
        var _evtNamespace;
        var _endpointUrl;
        var _orgEndpointUrl;
        var _maxBatchSizeInBytes;
        var _beaconSupported;
        var _beaconOnUnloadSupported;
        var _beaconNormalSupported;
        var _customHeaders;
        var _disableTelemetry;
        var _instrumentationKey;
        var _convertUndefined;
        var _isRetryDisabled;
        var _maxBatchInterval;
        var _sessionStorageUsed;
        var _bufferOverrideUsed;
        var _namePrefix;
        var _enableSendPromise;
        var _alwaysUseCustomSend;
        var _disableXhr;
        var _fetchKeepAlive;
        var _xhrSend;
        var _fallbackSend;
        var _disableBeaconSplit;
        var _sendPostMgr;
        var _retryCodes;
        (0,_microsoft_dynamicproto_js__WEBPACK_IMPORTED_MODULE_14__["default"])(Sender, _this, function (_self, _base) {
            _initDefaults();
            _self.pause = function () {
                _clearScheduledTimer();
                _paused = true;
            };
            _self.resume = function () {
                if (_paused) {
                    _paused = false;
                    _retryAt = null;
                    // flush if we have exceeded the max-size already
                    _checkMaxSize();
                    _setupTimer();
                }
            };
            _self.flush = function (isAsync, callBack, sendReason) {
                if (isAsync === void 0) { isAsync = true; }
                if (!_paused) {
                    // Clear the normal schedule timer as we are going to try and flush ASAP
                    _clearScheduledTimer();
                    try {
                        return _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_TRIGGER_SEND /* @min:%2etriggerSend */](isAsync, null, sendReason || 1 /* SendRequestReason.ManualFlush */);
                    }
                    catch (e) {
                        (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_15__._throwInternal)(_self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_DIAG_LOG /* @min:%2ediagLog */](), 1 /* eLoggingSeverity.CRITICAL */, 22 /* _eInternalMessageId.FlushFailed */, "flush failed, telemetry will not be collected: " + (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_16__.getExceptionName)(e), { exception: (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.dumpObj)(e) });
                    }
                }
            };
            _self.onunloadFlush = function () {
                if (!_paused) {
                    if (_beaconSupported || _alwaysUseCustomSend) {
                        try {
                            return _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_TRIGGER_SEND /* @min:%2etriggerSend */](true, _doUnloadSend, 2 /* SendRequestReason.Unload */);
                        }
                        catch (e) {
                            (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_15__._throwInternal)(_self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_DIAG_LOG /* @min:%2ediagLog */](), 1 /* eLoggingSeverity.CRITICAL */, 20 /* _eInternalMessageId.FailedToSendQueuedTelemetry */, "failed to flush with beacon sender on page unload, telemetry will not be collected: " + (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_16__.getExceptionName)(e), { exception: (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.dumpObj)(e) });
                        }
                    }
                    else {
                        _self.flush(false);
                    }
                }
            };
            _self.addHeader = function (name, value) {
                _headers[name] = value;
            };
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_INITIALIZE /* @min:%2einitialize */] = function (config, core, extensions, pluginChain) {
                if (_self.isInitialized()) {
                    (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_15__._throwInternal)(_self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_DIAG_LOG /* @min:%2ediagLog */](), 1 /* eLoggingSeverity.CRITICAL */, 28 /* _eInternalMessageId.SenderNotInitialized */, "Sender is already initialized");
                }
                _base[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_INITIALIZE /* @min:%2einitialize */](config, core, extensions, pluginChain);
                var identifier = _self.identifier;
                _serializer = new _Serializer__WEBPACK_IMPORTED_MODULE_17__.Serializer(core.logger);
                _consecutiveErrors = 0;
                _retryAt = null;
                _lastSend = 0;
                _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN__SENDER /* @min:%2e_sender */] = null;
                _stamp_specific_redirects = 0;
                var diagLog = _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_DIAG_LOG /* @min:%2ediagLog */]();
                _evtNamespace = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_18__.mergeEvtNamespace)((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_19__.createUniqueNamespace)("Sender"), core.evtNamespace && core.evtNamespace());
                _offlineListener = (0,_microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_20__.createOfflineListener)(_evtNamespace);
                // This function will be re-called whenever any referenced configuration is changed
                _self._addHook((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_21__.onConfigChange)(config, function (details) {
                    var config = details.cfg;
                    if (config.storagePrefix) {
                        (0,_microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_22__.utlSetStoragePrefix)(config.storagePrefix);
                    }
                    var ctx = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_23__.createProcessTelemetryContext)(null, config, core);
                    var senderConfig = ctx.getExtCfg(identifier, defaultAppInsightsChannelConfig);
                    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objDefine)(_self, "_senderConfig", {
                        g: function () {
                            return senderConfig;
                        }
                    });
                    // or is not string
                    if (core.activeStatus() === _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_24__.ActiveStatus.PENDING) {
                        // waiting for core promises to be resolved
                        // NOTE: if active status is set to pending, stop sending, clear timer here
                        _self.pause();
                    }
                    else if (core.activeStatus() === _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_24__.ActiveStatus.ACTIVE) {
                        // core status changed from pending to other status
                        _self.resume();
                    }
                    // Only update the endpoint if the original config !== the current config
                    // This is so any redirect endpointUrl is not overwritten
                    if (_orgEndpointUrl !== senderConfig.endpointUrl) {
                        if (_orgEndpointUrl) {
                            // TODO: add doc to remind users to flush before changing endpoint, otherwise all unsent payload will be sent to new endpoint
                        }
                        _endpointUrl = _orgEndpointUrl = senderConfig.endpointUrl;
                    }
                    if (_customHeaders && _customHeaders !== senderConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_CUSTOM_HEADERS /* @min:%2ecustomHeaders */]) {
                        // Removing any previously defined custom headers as they have changed
                        (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrForEach)(_customHeaders, function (customHeader) {
                            delete _headers[customHeader.header];
                        });
                    }
                    _maxBatchSizeInBytes = senderConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_MAX_BATCH_SIZE_IN_BY1 /* @min:%2emaxBatchSizeInBytes */];
                    _beaconSupported = (senderConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_ONUNLOAD_DISABLE_BEA2 /* @min:%2eonunloadDisableBeacon */] === false || senderConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_IS_BEACON_API_DISABL3 /* @min:%2eisBeaconApiDisabled */] === false) && (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_25__.isBeaconsSupported)();
                    _beaconOnUnloadSupported = senderConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_ONUNLOAD_DISABLE_BEA2 /* @min:%2eonunloadDisableBeacon */] === false && (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_25__.isBeaconsSupported)();
                    _beaconNormalSupported = senderConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_IS_BEACON_API_DISABL3 /* @min:%2eisBeaconApiDisabled */] === false && (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_25__.isBeaconsSupported)();
                    _alwaysUseCustomSend = senderConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_ALWAYS_USE_XHR_OVERR4 /* @min:%2ealwaysUseXhrOverride */];
                    _disableXhr = !!senderConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_DISABLE_XHR /* @min:%2edisableXhr */];
                    _retryCodes = senderConfig.retryCodes;
                    var bufferOverride = senderConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_BUFFER_OVERRIDE /* @min:%2ebufferOverride */];
                    var canUseSessionStorage = !!senderConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_ENABLE_SESSION_STORA5 /* @min:%2eenableSessionStorageBuffer */] &&
                        (!!bufferOverride || (0,_microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_22__.utlCanUseSessionStorage)());
                    var namePrefix = senderConfig.namePrefix;
                    //Note: emitLineDelimitedJson and eventsLimitInMem is directly accessed via config in senderBuffer
                    //Therefore, if canUseSessionStorage is not changed, we do not need to re initialize a new one
                    var shouldUpdate = (canUseSessionStorage !== _sessionStorageUsed)
                        || (canUseSessionStorage && (_namePrefix !== namePrefix)) // prefixName is only used in session storage
                        || (canUseSessionStorage && (_bufferOverrideUsed !== bufferOverride));
                    if (_self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN__BUFFER /* @min:%2e_buffer */]) {
                        // case1 (Pre and Now enableSessionStorageBuffer settings are same)
                        // if namePrefix changes, transfer current buffer to new buffer
                        // else no action needed
                        //case2 (Pre and Now enableSessionStorageBuffer settings are changed)
                        // transfer current buffer to new buffer
                        if (shouldUpdate) {
                            try {
                                _self._buffer = _self._buffer[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_CREATE_NEW /* @min:%2ecreateNew */](diagLog, senderConfig, canUseSessionStorage);
                            }
                            catch (e) {
                                (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_15__._throwInternal)(_self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_DIAG_LOG /* @min:%2ediagLog */](), 1 /* eLoggingSeverity.CRITICAL */, 12 /* _eInternalMessageId.FailedAddingTelemetryToBuffer */, "failed to transfer telemetry to different buffer storage, telemetry will be lost: " + (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_16__.getExceptionName)(e), { exception: (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.dumpObj)(e) });
                            }
                        }
                        _checkMaxSize();
                    }
                    else {
                        _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN__BUFFER /* @min:%2e_buffer */] = canUseSessionStorage
                            ? new _SendBuffer__WEBPACK_IMPORTED_MODULE_26__.SessionStorageSendBuffer(diagLog, senderConfig) : new _SendBuffer__WEBPACK_IMPORTED_MODULE_26__.ArraySendBuffer(diagLog, senderConfig);
                    }
                    _namePrefix = namePrefix;
                    _sessionStorageUsed = canUseSessionStorage;
                    _bufferOverrideUsed = bufferOverride;
                    _fetchKeepAlive = !senderConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_ONUNLOAD_DISABLE_FET6 /* @min:%2eonunloadDisableFetch */] && (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_25__.isFetchSupported)(true);
                    _disableBeaconSplit = !!senderConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_DISABLE_SEND_BEACON_7 /* @min:%2edisableSendBeaconSplit */];
                    _self._sample = new _TelemetryProcessors_Sample__WEBPACK_IMPORTED_MODULE_27__.Sample(senderConfig.samplingPercentage, diagLog);
                    _instrumentationKey = senderConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_INSTRUMENTATION_KEY /* @min:%2einstrumentationKey */];
                    if (!_validateInstrumentationKey(_instrumentationKey, config)) {
                        (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_15__._throwInternal)(diagLog, 1 /* eLoggingSeverity.CRITICAL */, 100 /* _eInternalMessageId.InvalidInstrumentationKey */, "Invalid Instrumentation key " + _instrumentationKey);
                    }
                    _customHeaders = senderConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_CUSTOM_HEADERS /* @min:%2ecustomHeaders */];
                    if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isString)(_endpointUrl) && !(0,_microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_28__.isInternalApplicationInsightsEndpoint)(_endpointUrl) && _customHeaders && _customHeaders[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LENGTH /* @min:%2elength */] > 0) {
                        (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrForEach)(_customHeaders, function (customHeader) {
                            _this.addHeader(customHeader.header, customHeader.value);
                        });
                    }
                    else {
                        _customHeaders = null;
                    }
                    _enableSendPromise = senderConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_ENABLE_SEND_PROMISE /* @min:%2eenableSendPromise */];
                    var sendPostConfig = _getSendPostMgrConfig();
                    // only init it once
                    if (!_sendPostMgr) {
                        _sendPostMgr = new _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_29__.SenderPostManager();
                        _sendPostMgr[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_INITIALIZE /* @min:%2einitialize */](sendPostConfig, diagLog);
                    }
                    else {
                        _sendPostMgr.SetConfig(sendPostConfig);
                    }
                    var customInterface = senderConfig.httpXHROverride;
                    var httpInterface = null;
                    var syncInterface = null;
                    // User requested transport(s) values > Beacon > Fetch > XHR
                    // Beacon would be filtered out if user has set disableBeaconApi to true at _getSenderInterface
                    var theTransports = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_16__.prependTransports)([3 /* TransportType.Beacon */, 1 /* TransportType.Xhr */, 2 /* TransportType.Fetch */], senderConfig.transports);
                    httpInterface = _sendPostMgr && _sendPostMgr[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_GET_SENDER_INST /* @min:%2egetSenderInst */](theTransports, false);
                    var xhrInterface = _sendPostMgr && _sendPostMgr.getFallbackInst();
                    _xhrSend = function (payload, isAsync) {
                        return _doSend(xhrInterface, payload, isAsync);
                    };
                    _fallbackSend = function (payload, isAsync) {
                        return _doSend(xhrInterface, payload, isAsync, false);
                    };
                    httpInterface = _alwaysUseCustomSend ? customInterface : (httpInterface || customInterface || xhrInterface);
                    _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN__SENDER /* @min:%2e_sender */] = function (payload, isAsync) {
                        return _doSend(httpInterface, payload, isAsync);
                    };
                    if (_fetchKeepAlive) {
                        // Try and use the fetch with keepalive
                        _syncUnloadSender = _fetchKeepAliveSender;
                    }
                    var syncTransports = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_16__.prependTransports)([3 /* TransportType.Beacon */, 1 /* TransportType.Xhr */], senderConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_UNLOAD_TRANSPORTS /* @min:%2eunloadTransports */]);
                    if (!_fetchKeepAlive) {
                        // remove fetch from theTransports
                        syncTransports = syncTransports.filter(function (transport) { return transport !== 2 /* TransportType.Fetch */; });
                    }
                    syncInterface = _sendPostMgr && _sendPostMgr[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_GET_SENDER_INST /* @min:%2egetSenderInst */](syncTransports, true);
                    syncInterface = _alwaysUseCustomSend ? customInterface : (syncInterface || customInterface);
                    if ((_alwaysUseCustomSend || senderConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_UNLOAD_TRANSPORTS /* @min:%2eunloadTransports */] || !_syncUnloadSender) && syncInterface) {
                        _syncUnloadSender = function (payload, isAsync) {
                            return _doSend(syncInterface, payload, isAsync);
                        };
                    }
                    if (!_syncUnloadSender) {
                        _syncUnloadSender = _xhrSend;
                    }
                    _disableTelemetry = senderConfig.disableTelemetry;
                    _convertUndefined = senderConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_CONVERT_UNDEFINED /* @min:%2econvertUndefined */] || UNDEFINED_VALUE;
                    _isRetryDisabled = senderConfig.isRetryDisabled;
                    _maxBatchInterval = senderConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_MAX_BATCH_INTERVAL /* @min:%2emaxBatchInterval */];
                }));
            };
            _self.processTelemetry = function (telemetryItem, itemCtx) {
                var _a;
                itemCtx = _self._getTelCtx(itemCtx);
                var diagLogger = itemCtx[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_DIAG_LOG /* @min:%2ediagLog */]();
                try {
                    var isValidate = _validate(telemetryItem, diagLogger);
                    if (!isValidate) {
                        return;
                    }
                    var aiEnvelope = _getEnvelope(telemetryItem, diagLogger);
                    if (!aiEnvelope) {
                        return;
                    }
                    // check if the incoming payload is too large, truncate if necessary
                    var payload = _serializer[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_SERIALIZE /* @min:%2eserialize */](aiEnvelope);
                    // flush if we would exceed the max-size limit by adding this item
                    var buffer = _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN__BUFFER /* @min:%2e_buffer */];
                    _checkMaxSize(payload);
                    var payloadItem = (_a = {},
                        _a[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_ITEM /* @min:item */] = payload,
                        _a.cnt = 0 // inital cnt will always be 0
                    ,
                        _a);
                    // enqueue the payload
                    buffer[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_ENQUEUE /* @min:%2eenqueue */](payloadItem);
                    // ensure an invocation timeout is set
                    _setupTimer();
                }
                catch (e) {
                    (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_15__._throwInternal)(diagLogger, 2 /* eLoggingSeverity.WARNING */, 12 /* _eInternalMessageId.FailedAddingTelemetryToBuffer */, "Failed adding telemetry to the sender's buffer, some telemetry will be lost: " + (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_16__.getExceptionName)(e), { exception: (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.dumpObj)(e) });
                }
                // hand off the telemetry item to the next plugin
                _self.processNext(telemetryItem, itemCtx);
            };
            _self.isCompletelyIdle = function () {
                return !_paused && _syncFetchPayload === 0 && _self._buffer[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_COUNT /* @min:%2ecount */]() === 0;
            };
            /**
             * xhr state changes
             */
            _self._xhrReadyStateChange = function (xhr, payload, countOfItemsInPayload) {
                // since version 3.2.0, this function is no-op
                if (_isStringArr(payload)) {
                    return;
                }
                return _xhrReadyStateChange(xhr, payload, countOfItemsInPayload);
            };
            /**
             * Immediately send buffered data
             * @param async - {boolean} - Indicates if the events should be sent asynchronously
             * @param forcedSender - {SenderFunction} - Indicates the forcedSender, undefined if not passed
             */
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_TRIGGER_SEND /* @min:%2etriggerSend */] = function (async, forcedSender, sendReason) {
                if (async === void 0) { async = true; }
                var result;
                if (!_paused) {
                    try {
                        var buffer = _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN__BUFFER /* @min:%2e_buffer */];
                        // Send data only if disableTelemetry is false
                        if (!_disableTelemetry) {
                            if (buffer[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_COUNT /* @min:%2ecount */]() > 0) {
                                var payload = buffer.getItems();
                                _notifySendRequest(sendReason || 0 /* SendRequestReason.Undefined */, async);
                                // invoke send
                                if (forcedSender) {
                                    result = forcedSender.call(_self, payload, async);
                                }
                                else {
                                    result = _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN__SENDER /* @min:%2e_sender */](payload, async);
                                }
                            }
                            // update lastSend time to enable throttling
                            _lastSend = +new Date;
                        }
                        else {
                            buffer[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_CLEAR /* @min:%2eclear */]();
                        }
                        _clearScheduledTimer();
                    }
                    catch (e) {
                        /* Ignore this error for IE under v10 */
                        var ieVer = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_25__.getIEVersion)();
                        if (!ieVer || ieVer > 9) {
                            (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_15__._throwInternal)(_self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_DIAG_LOG /* @min:%2ediagLog */](), 1 /* eLoggingSeverity.CRITICAL */, 40 /* _eInternalMessageId.TransmissionFailed */, "Telemetry transmission failed, some telemetry will be lost: " + (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_16__.getExceptionName)(e), { exception: (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.dumpObj)(e) });
                        }
                    }
                }
                return result;
            };
            _self.getOfflineSupport = function () {
                var _a;
                return _a = {
                        getUrl: function () {
                            return _endpointUrl;
                        },
                        createPayload: _createPayload
                    },
                    _a[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_SERIALIZE /* @min:serialize */] = _serialize,
                    _a.batch = _batch,
                    _a.shouldProcess = function (evt) {
                        return !!_validate(evt);
                    },
                    _a;
            };
            _self._doTeardown = function (unloadCtx, unloadState) {
                _self.onunloadFlush();
                (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_30__.runTargetUnload)(_offlineListener, false);
                _initDefaults();
            };
            /**
             * error handler
             */
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN__ON_ERROR /* @min:%2e_onError */] = function (payload, message, event) {
                // since version 3.1.3, string[] is no-op
                if (_isStringArr(payload)) {
                    return;
                }
                return _onError(payload, message, event);
            };
            /**
             * partial success handler
             */
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN__ON_PARTIAL_SUCCESS /* @min:%2e_onPartialSuccess */] = function (payload, results) {
                // since version 3.1.3, string[] is no-op
                if (_isStringArr(payload)) {
                    return;
                }
                return _onPartialSuccess(payload, results);
            };
            /**
             * success handler
             */
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN__ON_SUCCESS /* @min:%2e_onSuccess */] = function (payload, countOfItemsInPayload) {
                // since version 3.1.3, string[] is no-op
                if (_isStringArr(payload)) {
                    return;
                }
                return _onSuccess(payload, countOfItemsInPayload);
                //_self._buffer && _self._buffer.clearSent(payload);
            };
            /**
             * xdr state changes
             */
            _self._xdrOnLoad = function (xdr, payload) {
                // since version 3.1.3, string[] is no-op
                if (_isStringArr(payload)) {
                    return;
                }
                return _xdrOnLoad(xdr, payload);
            };
            function _xdrOnLoad(xdr, payload) {
                var responseText = _getResponseText(xdr);
                if (xdr && (responseText + "" === "200" || responseText === "")) {
                    _consecutiveErrors = 0;
                    _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN__ON_SUCCESS /* @min:%2e_onSuccess */](payload, 0);
                }
                else {
                    var results = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_31__.parseResponse)(responseText);
                    if (results && results[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_ITEMS_RECEIVED /* @min:%2eitemsReceived */] && results[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_ITEMS_RECEIVED /* @min:%2eitemsReceived */] > results[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_ITEMS_ACCEPTED /* @min:%2eitemsAccepted */]
                        && !_isRetryDisabled) {
                        _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN__ON_PARTIAL_SUCCESS /* @min:%2e_onPartialSuccess */](payload, results);
                    }
                    else {
                        _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN__ON_ERROR /* @min:%2e_onError */](payload, (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_16__.formatErrorMessageXdr)(xdr));
                    }
                }
            }
            function _getSendPostMgrConfig() {
                var _a;
                try {
                    var onCompleteFuncs = {
                        xdrOnComplete: function (xdr, oncomplete, payload) {
                            var data = _getPayloadArr(payload);
                            if (!data) {
                                return;
                            }
                            return _xdrOnLoad(xdr, data);
                        },
                        fetchOnComplete: function (response, onComplete, resValue, payload) {
                            var data = _getPayloadArr(payload);
                            if (!data) {
                                return;
                            }
                            return _checkResponsStatus(response.status, data, response.url, data[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LENGTH /* @min:%2elength */], response.statusText, resValue || "");
                        },
                        xhrOnComplete: function (request, oncomplete, payload) {
                            var data = _getPayloadArr(payload);
                            if (!data) {
                                return;
                            }
                            return _xhrReadyStateChange(request, data, data[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LENGTH /* @min:%2elength */]);
                        },
                        beaconOnRetry: function (data, onComplete, canSend) {
                            return _onBeaconRetry(data, onComplete, canSend);
                        }
                    };
                    var config = (_a = {},
                        _a[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_ENABLE_SEND_PROMISE /* @min:enableSendPromise */] = _enableSendPromise,
                        _a.isOneDs = false,
                        _a.disableCredentials = false,
                        _a[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_DISABLE_XHR /* @min:disableXhr */] = _disableXhr,
                        _a.disableBeacon = !_beaconNormalSupported,
                        _a.disableBeaconSync = !_beaconOnUnloadSupported,
                        _a.senderOnCompleteCallBack = onCompleteFuncs,
                        _a);
                    return config;
                }
                catch (e) {
                    // eslint-disable-next-line no-empty
                }
                return null;
            }
            /**
             * xhr state changes
             */
            function _xhrReadyStateChange(xhr, payload, countOfItemsInPayload) {
                if (xhr.readyState === 4) {
                    _checkResponsStatus(xhr.status, payload, xhr.responseURL, countOfItemsInPayload, (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_16__.formatErrorMessageXhr)(xhr), _getResponseText(xhr) || xhr.response);
                }
            }
            /**
             * error handler
             */
            function _onError(payload, message, event) {
                (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_15__._throwInternal)(_self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_DIAG_LOG /* @min:%2ediagLog */](), 2 /* eLoggingSeverity.WARNING */, 26 /* _eInternalMessageId.OnError */, "Failed to send telemetry.", { message: message });
                _self._buffer && _self._buffer[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_CLEAR_SENT /* @min:%2eclearSent */](payload);
            }
            /**
             * partial success handler
             */
            function _onPartialSuccess(payload, results) {
                var failed = [];
                var retry = [];
                // Iterate through the reversed array of errors so that splicing doesn't have invalid indexes after the first item.
                var errors = results.errors.reverse();
                for (var _i = 0, errors_1 = errors; _i < errors_1.length; _i++) {
                    var error = errors_1[_i];
                    var extracted = payload.splice(error.index, 1)[0];
                    if (_isRetriable(error.statusCode)) {
                        retry[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_PUSH /* @min:%2epush */](extracted);
                    }
                    else {
                        // All other errors, including: 402 (Monthly quota exceeded) and 439 (Too many requests and refresh cache).
                        failed[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_PUSH /* @min:%2epush */](extracted);
                    }
                }
                if (payload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LENGTH /* @min:%2elength */] > 0) {
                    _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN__ON_SUCCESS /* @min:%2e_onSuccess */](payload, results[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_ITEMS_ACCEPTED /* @min:%2eitemsAccepted */]);
                }
                if (failed[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LENGTH /* @min:%2elength */] > 0) {
                    _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN__ON_ERROR /* @min:%2e_onError */](failed, (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_16__.formatErrorMessageXhr)(null, ["partial success", results[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_ITEMS_ACCEPTED /* @min:%2eitemsAccepted */], "of", results.itemsReceived].join(" ")));
                }
                if (retry[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LENGTH /* @min:%2elength */] > 0) {
                    _resendPayload(retry);
                    (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_15__._throwInternal)(_self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_DIAG_LOG /* @min:%2ediagLog */](), 2 /* eLoggingSeverity.WARNING */, 40 /* _eInternalMessageId.TransmissionFailed */, "Partial success. " +
                        "Delivered: " + payload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LENGTH /* @min:%2elength */] + ", Failed: " + failed[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LENGTH /* @min:%2elength */] +
                        ". Will retry to send " + retry[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LENGTH /* @min:%2elength */] + " our of " + results[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_ITEMS_RECEIVED /* @min:%2eitemsReceived */] + " items");
                }
            }
            /**
             * success handler
             */
            function _onSuccess(payload, countOfItemsInPayload) {
                _self._buffer && _self._buffer[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_CLEAR_SENT /* @min:%2eclearSent */](payload);
            }
            function _getPayloadArr(payload) {
                try {
                    if (payload) {
                        var internalPayload = payload;
                        var arr = internalPayload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_ORI_PAYLOAD /* @min:%2eoriPayload */];
                        if (arr && arr[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LENGTH /* @min:%2elength */]) {
                            return arr;
                        }
                        return null;
                    }
                }
                catch (e) {
                    // eslint-disable-next-line no-empty
                }
                return null;
            }
            function _validate(telemetryItem, diagLogger) {
                if (_disableTelemetry) {
                    // Do not send/save data
                    return false;
                }
                // validate input
                if (!telemetryItem) {
                    diagLogger && (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_15__._throwInternal)(diagLogger, 1 /* eLoggingSeverity.CRITICAL */, 7 /* _eInternalMessageId.CannotSendEmptyTelemetry */, "Cannot send empty telemetry");
                    return false;
                }
                // validate event
                if (telemetryItem.baseData && !telemetryItem[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_BASE_TYPE /* @min:%2ebaseType */]) {
                    diagLogger && (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_15__._throwInternal)(diagLogger, 1 /* eLoggingSeverity.CRITICAL */, 70 /* _eInternalMessageId.InvalidEvent */, "Cannot send telemetry without baseData and baseType");
                    return false;
                }
                if (!telemetryItem[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_BASE_TYPE /* @min:%2ebaseType */]) {
                    // Default
                    telemetryItem[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_BASE_TYPE /* @min:%2ebaseType */] = "EventData";
                }
                // ensure a sender was constructed
                if (!_self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN__SENDER /* @min:%2e_sender */]) {
                    diagLogger && (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_15__._throwInternal)(diagLogger, 1 /* eLoggingSeverity.CRITICAL */, 28 /* _eInternalMessageId.SenderNotInitialized */, "Sender was not initialized");
                    return false;
                }
                // check if this item should be sampled in, else add sampleRate tag
                if (!_isSampledIn(telemetryItem)) {
                    // Item is sampled out, do not send it
                    diagLogger && (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_15__._throwInternal)(diagLogger, 2 /* eLoggingSeverity.WARNING */, 33 /* _eInternalMessageId.TelemetrySampledAndNotSent */, "Telemetry item was sampled out and not sent", { SampleRate: _self._sample[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_SAMPLE_RATE /* @min:%2esampleRate */] });
                    return false;
                }
                else {
                    telemetryItem[_microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_2__.SampleRate] = _self._sample[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_SAMPLE_RATE /* @min:%2esampleRate */];
                }
                return true;
            }
            function _getEnvelope(telemetryItem, diagLogger) {
                // construct an envelope that Application Insights endpoint can understand
                // if ikey of telemetry is provided and not empty, envelope will use this iKey instead of senderConfig iKey
                var defaultEnvelopeIkey = telemetryItem.iKey || _instrumentationKey;
                var aiEnvelope = Sender.constructEnvelope(telemetryItem, defaultEnvelopeIkey, diagLogger, _convertUndefined);
                if (!aiEnvelope) {
                    (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_15__._throwInternal)(diagLogger, 1 /* eLoggingSeverity.CRITICAL */, 47 /* _eInternalMessageId.CreateEnvelopeError */, "Unable to create an AppInsights envelope");
                    return;
                }
                var doNotSendItem = false;
                // this is for running in legacy mode, where customer may already have a custom initializer present
                if (telemetryItem[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_TAGS /* @min:%2etags */] && telemetryItem[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_TAGS /* @min:%2etags */][_microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_2__.ProcessLegacy]) {
                    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrForEach)(telemetryItem[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_TAGS /* @min:%2etags */][_microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_2__.ProcessLegacy], function (callBack) {
                        try {
                            if (callBack && callBack(aiEnvelope) === false) {
                                doNotSendItem = true;
                                (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_15__._warnToConsole)(diagLogger, "Telemetry processor check returns false");
                            }
                        }
                        catch (e) {
                            // log error but dont stop executing rest of the telemetry initializers
                            // doNotSendItem = true;
                            (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_15__._throwInternal)(diagLogger, 1 /* eLoggingSeverity.CRITICAL */, 64 /* _eInternalMessageId.TelemetryInitializerFailed */, "One of telemetry initializers failed, telemetry item will not be sent: " + (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_16__.getExceptionName)(e), { exception: (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.dumpObj)(e) }, true);
                        }
                    });
                    delete telemetryItem[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_TAGS /* @min:%2etags */][_microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_2__.ProcessLegacy];
                }
                if (doNotSendItem) {
                    return; // do not send, no need to execute next plugin
                }
                return aiEnvelope;
            }
            function _serialize(item) {
                var rlt = EMPTY_STR;
                var diagLogger = _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_DIAG_LOG /* @min:%2ediagLog */]();
                try {
                    var valid = _validate(item, diagLogger);
                    var envelope = null;
                    if (valid) {
                        envelope = _getEnvelope(item, diagLogger);
                    }
                    if (envelope) {
                        rlt = _serializer[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_SERIALIZE /* @min:%2eserialize */](envelope);
                    }
                }
                catch (e) {
                    // eslint-disable-next-line no-empty
                }
                return rlt;
            }
            function _batch(arr) {
                var rlt = EMPTY_STR;
                if (arr && arr[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LENGTH /* @min:%2elength */]) {
                    rlt = "[" + arr.join(",") + "]";
                }
                return rlt;
            }
            function _createPayload(data) {
                var _a;
                var headers = _getHeaders();
                return _a = {
                        urlString: _endpointUrl
                    },
                    _a[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_DATA /* @min:data */] = data,
                    _a.headers = headers,
                    _a;
            }
            function _isSampledIn(envelope) {
                return _self._sample.isSampledIn(envelope);
            }
            function _getOnComplete(payload, status, headers, response) {
                // ***********************************************************************************************
                //TODO: handle other status codes
                if (status === 200 && payload) {
                    _self._onSuccess(payload, payload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LENGTH /* @min:%2elength */]);
                }
                else {
                    response && _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN__ON_ERROR /* @min:%2e_onError */](payload, response);
                }
            }
            function _doSend(sendInterface, payload, isAsync, markAsSent) {
                if (markAsSent === void 0) { markAsSent = true; }
                var onComplete = function (status, headers, response) {
                    return _getOnComplete(payload, status, headers, response);
                };
                var payloadData = _getPayload(payload);
                var sendPostFunc = sendInterface && sendInterface.sendPOST;
                if (sendPostFunc && payloadData) {
                    // ***********************************************************************************************
                    // mark payload as sent at the beginning of calling each send function
                    if (markAsSent) {
                        _self._buffer[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_MARK_AS_SENT /* @min:%2emarkAsSent */](payload);
                    }
                    return sendPostFunc(payloadData, onComplete, !isAsync);
                }
                return null;
            }
            function _getPayload(payload) {
                var _a;
                if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isArray)(payload) && payload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LENGTH /* @min:%2elength */] > 0) {
                    var batch = _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN__BUFFER /* @min:%2e_buffer */].batchPayloads(payload);
                    var headers = _getHeaders();
                    var payloadData = (_a = {},
                        _a[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_DATA /* @min:data */] = batch,
                        _a.urlString = _endpointUrl,
                        _a.headers = headers,
                        _a.disableXhrSync = _disableXhr,
                        _a.disableFetchKeepAlive = !_fetchKeepAlive,
                        _a[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_ORI_PAYLOAD /* @min:oriPayload */] = payload,
                        _a);
                    return payloadData;
                }
                return null;
            }
            function _getHeaders() {
                try {
                    var headers = _headers || {};
                    if ((0,_microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_28__.isInternalApplicationInsightsEndpoint)(_endpointUrl)) {
                        headers[_microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_32__.RequestHeaders[6]] = _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_32__.RequestHeaders[7];
                    }
                    return headers;
                }
                catch (e) {
                    // eslint-disable-next-line no-empty
                }
                return null;
            }
            function _checkMaxSize(incomingPayload) {
                var incomingSize = incomingPayload ? incomingPayload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LENGTH /* @min:%2elength */] : 0;
                if ((_self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN__BUFFER /* @min:%2e_buffer */].size() + incomingSize) > _maxBatchSizeInBytes) {
                    if (!_offlineListener || _offlineListener.isOnline()) { // only trigger send when currently online
                        _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_TRIGGER_SEND /* @min:%2etriggerSend */](true, null, 10 /* SendRequestReason.MaxBatchSize */);
                    }
                    return true;
                }
                return false;
            }
            function _checkResponsStatus(status, payload, responseUrl, countOfItemsInPayload, errorMessage, res) {
                var response = null;
                if (!_self._appId) {
                    response = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_31__.parseResponse)(res);
                    if (response && response.appId) {
                        _self._appId = response.appId;
                    }
                }
                if ((status < 200 || status >= 300) && status !== 0) {
                    // Update End Point url if permanent redirect or moved permanently
                    // Updates the end point url before retry
                    if (status === 301 || status === 307 || status === 308) {
                        if (!_checkAndUpdateEndPointUrl(responseUrl)) {
                            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN__ON_ERROR /* @min:%2e_onError */](payload, errorMessage);
                            return;
                        }
                    }
                    if (!_isRetryDisabled && _isRetriable(status)) {
                        _resendPayload(payload);
                        (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_15__._throwInternal)(_self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_DIAG_LOG /* @min:%2ediagLog */](), 2 /* eLoggingSeverity.WARNING */, 40 /* _eInternalMessageId.TransmissionFailed */, ". " +
                            "Response code " + status + ". Will retry to send " + payload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LENGTH /* @min:%2elength */] + " items.");
                    }
                    else {
                        _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN__ON_ERROR /* @min:%2e_onError */](payload, errorMessage);
                    }
                }
                else if (_offlineListener && !_offlineListener.isOnline()) { // offline
                    // Note: Don't check for status == 0, since adblock gives this code
                    if (!_isRetryDisabled) {
                        var offlineBackOffMultiplier = 10; // arbritrary number
                        _resendPayload(payload, offlineBackOffMultiplier);
                        (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_15__._throwInternal)(_self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_DIAG_LOG /* @min:%2ediagLog */](), 2 /* eLoggingSeverity.WARNING */, 40 /* _eInternalMessageId.TransmissionFailed */, ". Offline - Response Code: ".concat(status, ". Offline status: ").concat(!_offlineListener.isOnline(), ". Will retry to send ").concat(payload.length, " items."));
                    }
                }
                else {
                    // check if the xhr's responseURL or fetch's response.url is same as endpoint url
                    // TODO after 10 redirects force send telemetry with 'redirect=false' as query parameter.
                    _checkAndUpdateEndPointUrl(responseUrl);
                    if (status === 206) {
                        if (!response) {
                            response = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_31__.parseResponse)(res);
                        }
                        if (response && !_isRetryDisabled) {
                            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN__ON_PARTIAL_SUCCESS /* @min:%2e_onPartialSuccess */](payload, response);
                        }
                        else {
                            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN__ON_ERROR /* @min:%2e_onError */](payload, errorMessage);
                        }
                    }
                    else {
                        _consecutiveErrors = 0;
                        _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN__ON_SUCCESS /* @min:%2e_onSuccess */](payload, countOfItemsInPayload);
                    }
                }
            }
            function _checkAndUpdateEndPointUrl(responseUrl) {
                // Maximum stamp specific redirects allowed(uncomment this when breeze is ready with not allowing redirects feature)
                if (_stamp_specific_redirects >= 10) {
                    //  _self._senderConfig.endpointUrl = () => Sender._getDefaultAppInsightsChannelConfig().endpointUrl()+"/?redirect=false";
                    //  _stamp_specific_redirects = 0;
                    return false;
                }
                if (!(0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(responseUrl) && responseUrl !== "") {
                    if (responseUrl !== _endpointUrl) {
                        _endpointUrl = responseUrl;
                        ++_stamp_specific_redirects;
                        return true;
                    }
                }
                return false;
            }
            function _doUnloadSend(payload, isAsync) {
                if (_syncUnloadSender) {
                    // We are unloading so always call the sender with sync set to false
                    _syncUnloadSender(payload, false);
                }
                else {
                    // Fallback to the previous beacon Sender (which causes a CORB warning on chrome now)
                    var beaconInst = _sendPostMgr && _sendPostMgr[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_GET_SENDER_INST /* @min:%2egetSenderInst */]([3 /* TransportType.Beacon */], true);
                    return _doSend(beaconInst, payload, isAsync);
                }
            }
            function _onBeaconRetry(payload, onComplete, canSend) {
                var internalPayload = payload;
                var data = internalPayload && internalPayload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_ORI_PAYLOAD /* @min:%2eoriPayload */];
                if (!_disableBeaconSplit) {
                    // Failed to send entire payload so try and split data and try to send as much events as possible
                    var droppedPayload = [];
                    for (var lp = 0; lp < data[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LENGTH /* @min:%2elength */]; lp++) {
                        var thePayload = data[lp];
                        var arr = [thePayload];
                        var item = _getPayload(arr);
                        if (!canSend(item, onComplete)) {
                            // Can't send anymore, so split the batch and drop the rest
                            droppedPayload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_PUSH /* @min:%2epush */](thePayload);
                        }
                        else {
                            _self._onSuccess(arr, arr[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LENGTH /* @min:%2elength */]);
                        }
                    }
                    if (droppedPayload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LENGTH /* @min:%2elength */] > 0) {
                        _fallbackSend && _fallbackSend(droppedPayload, true);
                        (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_15__._throwInternal)(_self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_DIAG_LOG /* @min:%2ediagLog */](), 2 /* eLoggingSeverity.WARNING */, 40 /* _eInternalMessageId.TransmissionFailed */, ". " + "Failed to send telemetry with Beacon API, retried with normal sender.");
                    }
                }
                else {
                    _fallbackSend && _fallbackSend(data, true);
                    (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_15__._throwInternal)(_self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_DIAG_LOG /* @min:%2ediagLog */](), 2 /* eLoggingSeverity.WARNING */, 40 /* _eInternalMessageId.TransmissionFailed */, ". " + "Failed to send telemetry with Beacon API, retried with normal sender.");
                }
            }
            function _isStringArr(arr) {
                try {
                    if (arr && arr[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LENGTH /* @min:%2elength */]) {
                        return ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isString)(arr[0]));
                    }
                }
                catch (e) {
                    //TODO: log, sender use IInternalStorageItem instead of string since 3.1.3
                }
                return null;
            }
            function _fetchKeepAliveSender(payload, isAsync) {
                var transport = null;
                if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isArray)(payload)) {
                    var payloadSize = payload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LENGTH /* @min:%2elength */];
                    for (var lp = 0; lp < payload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LENGTH /* @min:%2elength */]; lp++) {
                        payloadSize += payload[lp].item[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LENGTH /* @min:%2elength */];
                    }
                    var syncFetchPayload = _sendPostMgr.getSyncFetchPayload();
                    if ((syncFetchPayload + payloadSize) <= FetchSyncRequestSizeLimitBytes) {
                        transport = 2 /* TransportType.Fetch */;
                    }
                    else if ((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_25__.isBeaconsSupported)()) {
                        // Fallback to beacon sender as we at least get told which events can't be scheduled
                        transport = 3 /* TransportType.Beacon */;
                    }
                    else {
                        // Payload is going to be too big so just try and send via XHR
                        transport = 1 /* TransportType.Xhr */;
                        (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_15__._throwInternal)(_self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_DIAG_LOG /* @min:%2ediagLog */](), 2 /* eLoggingSeverity.WARNING */, 40 /* _eInternalMessageId.TransmissionFailed */, ". " + "Failed to send telemetry with Beacon API, retried with xhrSender.");
                    }
                    var inst = _sendPostMgr && _sendPostMgr[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_GET_SENDER_INST /* @min:%2egetSenderInst */]([transport], true);
                    return _doSend(inst, payload, isAsync);
                }
                return null;
            }
            /**
             * Resend payload. Adds payload back to the send buffer and setup a send timer (with exponential backoff).
             * @param payload
             */
            function _resendPayload(payload, linearFactor) {
                if (linearFactor === void 0) { linearFactor = 1; }
                if (!payload || payload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LENGTH /* @min:%2elength */] === 0) {
                    return;
                }
                var buffer = _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN__BUFFER /* @min:%2e_buffer */];
                buffer[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_CLEAR_SENT /* @min:%2eclearSent */](payload);
                _consecutiveErrors++;
                for (var _i = 0, payload_1 = payload; _i < payload_1.length; _i++) {
                    var item = payload_1[_i];
                    item.cnt = item.cnt || 0; // to make sure we have cnt for each payload
                    item.cnt++; // when resend, increase cnt
                    buffer[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_ENQUEUE /* @min:%2eenqueue */](item);
                }
                // setup timer
                _setRetryTime(linearFactor);
                _setupTimer();
            }
            /**
             * Calculates the time to wait before retrying in case of an error based on
             * http://en.wikipedia.org/wiki/Exponential_backoff
             */
            function _setRetryTime(linearFactor) {
                var SlotDelayInSeconds = 10;
                var delayInSeconds;
                if (_consecutiveErrors <= 1) {
                    delayInSeconds = SlotDelayInSeconds;
                }
                else {
                    var backOffSlot = (Math.pow(2, _consecutiveErrors) - 1) / 2;
                    // tslint:disable-next-line:insecure-random
                    var backOffDelay = Math.floor(Math.random() * backOffSlot * SlotDelayInSeconds) + 1;
                    backOffDelay = linearFactor * backOffDelay;
                    delayInSeconds = Math.max(Math.min(backOffDelay, 3600), SlotDelayInSeconds);
                }
                // TODO: Log the backoff time like the C# version does.
                var retryAfterTimeSpan = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.utcNow)() + (delayInSeconds * 1000);
                // TODO: Log the retry at time like the C# version does.
                _retryAt = retryAfterTimeSpan;
            }
            /**
             * Sets up the timer which triggers actually sending the data.
             */
            function _setupTimer() {
                if (!_timeoutHandle && !_paused) {
                    var retryInterval = _retryAt ? Math.max(0, _retryAt - (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.utcNow)()) : 0;
                    var timerValue = Math.max(_maxBatchInterval, retryInterval);
                    _timeoutHandle = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.scheduleTimeout)(function () {
                        _timeoutHandle = null;
                        _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_TRIGGER_SEND /* @min:%2etriggerSend */](true, null, 1 /* SendRequestReason.NormalSchedule */);
                    }, timerValue);
                }
            }
            function _clearScheduledTimer() {
                _timeoutHandle && _timeoutHandle.cancel();
                _timeoutHandle = null;
                _retryAt = null;
            }
            /**
             * Checks if the SDK should resend the payload after receiving this status code from the backend.
             * @param statusCode
             */
            function _isRetriable(statusCode) {
                // retryCodes = [] means should not retry
                if (!(0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(_retryCodes)) {
                    return _retryCodes[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LENGTH /* @min:%2elength */] && _retryCodes.indexOf(statusCode) > -1;
                }
                return statusCode === 401 // Unauthorized
                    // Removing as private links can return a 403 which causes excessive retries and session storage usage
                    // || statusCode === 403 // Forbidden
                    || statusCode === 408 // Timeout
                    || statusCode === 429 // Too many requests.
                    || statusCode === 500 // Internal server error.
                    || statusCode === 502 // Bad Gateway.
                    || statusCode === 503 // Service unavailable.
                    || statusCode === 504; // Gateway timeout.
            }
            // Using function lookups for backward compatibility as the getNotifyMgr() did not exist until after v2.5.6
            function _getNotifyMgr() {
                var func = "getNotifyMgr";
                if (_self.core[func]) {
                    return _self.core[func]();
                }
                // using _self.core['_notificationManager'] for backward compatibility
                return _self.core["_notificationManager"];
            }
            function _notifySendRequest(sendRequest, isAsync) {
                var manager = _getNotifyMgr();
                if (manager && manager[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_EVENTS_SEND_REQUEST /* @min:%2eeventsSendRequest */]) {
                    try {
                        manager[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_EVENTS_SEND_REQUEST /* @min:%2eeventsSendRequest */](sendRequest, isAsync);
                    }
                    catch (e) {
                        (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_15__._throwInternal)(_self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_DIAG_LOG /* @min:%2ediagLog */](), 1 /* eLoggingSeverity.CRITICAL */, 74 /* _eInternalMessageId.NotificationException */, "send request notification failed: " + (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_16__.getExceptionName)(e), { exception: (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.dumpObj)(e) });
                    }
                }
            }
            /**
             * Validate UUID Format
             * Specs taken from https://tools.ietf.org/html/rfc4122 and breeze repo
             */
            function _validateInstrumentationKey(instrumentationKey, config) {
                var disableValidation = config.disableInstrumentationKeyValidation;
                var disableIKeyValidationFlag = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(disableValidation) ? false : disableValidation;
                if (disableIKeyValidationFlag) {
                    return true;
                }
                var UUID_Regex = "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$";
                var regexp = new RegExp(UUID_Regex);
                return regexp.test(instrumentationKey);
            }
            function _initDefaults() {
                _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN__SENDER /* @min:%2e_sender */] = null;
                _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN__BUFFER /* @min:%2e_buffer */] = null;
                _self._appId = null;
                _self._sample = null;
                _headers = {};
                _offlineListener = null;
                _consecutiveErrors = 0;
                _retryAt = null;
                _lastSend = null;
                _paused = false;
                _timeoutHandle = null;
                _serializer = null;
                _stamp_specific_redirects = 0;
                _syncFetchPayload = 0;
                _syncUnloadSender = null;
                _evtNamespace = null;
                _endpointUrl = null;
                _orgEndpointUrl = null;
                _maxBatchSizeInBytes = 0;
                _beaconSupported = false;
                _customHeaders = null;
                _disableTelemetry = false;
                _instrumentationKey = null;
                _convertUndefined = UNDEFINED_VALUE;
                _isRetryDisabled = false;
                _sessionStorageUsed = null;
                _namePrefix = UNDEFINED_VALUE;
                _disableXhr = false;
                _fetchKeepAlive = false;
                _disableBeaconSplit = false;
                _xhrSend = null;
                _fallbackSend = null;
                _sendPostMgr = null;
                (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objDefine)(_self, "_senderConfig", {
                    g: function () {
                        return (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_16__.objExtend)({}, defaultAppInsightsChannelConfig);
                    }
                });
            }
        });
        return _this;
    }
    Sender.constructEnvelope = function (orig, iKey, logger, convertUndefined) {
        var envelope;
        if (iKey !== orig.iKey && !(0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(iKey)) {
            envelope = (0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_12__.__assignFn)((0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_12__.__assignFn)({}, orig), { iKey: iKey });
        }
        else {
            envelope = orig;
        }
        var creator = EnvelopeTypeCreator[envelope.baseType] || _EnvelopeCreator__WEBPACK_IMPORTED_MODULE_5__.EventEnvelopeCreator;
        return creator(logger, envelope, convertUndefined);
    };
// Removed Stub for Sender.prototype.pause.
// Removed Stub for Sender.prototype.resume.
// Removed Stub for Sender.prototype.flush.
// Removed Stub for Sender.prototype.onunloadFlush.
// Removed Stub for Sender.prototype.initialize.
// Removed Stub for Sender.prototype.processTelemetry.
// Removed Stub for Sender.prototype._xhrReadyStateChange.
// Removed Stub for Sender.prototype.triggerSend.
// Removed Stub for Sender.prototype._onError.
// Removed Stub for Sender.prototype._onPartialSuccess.
// Removed Stub for Sender.prototype._onSuccess.
// Removed Stub for Sender.prototype._xdrOnLoad.
// Removed Stub for Sender.prototype.addHeader.
// Removed Stub for Sender.prototype.isCompletelyIdle.
// Removed Stub for Sender.prototype.getOfflineSupport.
    return Sender;
}(_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_33__.BaseTelemetryPlugin));

//# sourceMappingURL=Sender.js.map

/***/ }),
/* 121 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "_DYN_ALWAYS_USE_XHR_OVERR4": () => (/* binding */ _DYN_ALWAYS_USE_XHR_OVERR4),
/* harmony export */   "_DYN_BASE_TYPE": () => (/* binding */ _DYN_BASE_TYPE),
/* harmony export */   "_DYN_BUFFER_OVERRIDE": () => (/* binding */ _DYN_BUFFER_OVERRIDE),
/* harmony export */   "_DYN_CLEAR": () => (/* binding */ _DYN_CLEAR),
/* harmony export */   "_DYN_CLEAR_SENT": () => (/* binding */ _DYN_CLEAR_SENT),
/* harmony export */   "_DYN_CONCAT": () => (/* binding */ _DYN_CONCAT),
/* harmony export */   "_DYN_CONVERT_UNDEFINED": () => (/* binding */ _DYN_CONVERT_UNDEFINED),
/* harmony export */   "_DYN_COUNT": () => (/* binding */ _DYN_COUNT),
/* harmony export */   "_DYN_CREATE_NEW": () => (/* binding */ _DYN_CREATE_NEW),
/* harmony export */   "_DYN_CUSTOM_HEADERS": () => (/* binding */ _DYN_CUSTOM_HEADERS),
/* harmony export */   "_DYN_DATA": () => (/* binding */ _DYN_DATA),
/* harmony export */   "_DYN_DATA_TYPE": () => (/* binding */ _DYN_DATA_TYPE),
/* harmony export */   "_DYN_DEVICE_TYPE": () => (/* binding */ _DYN_DEVICE_TYPE),
/* harmony export */   "_DYN_DIAG_LOG": () => (/* binding */ _DYN_DIAG_LOG),
/* harmony export */   "_DYN_DISABLE_SEND_BEACON_7": () => (/* binding */ _DYN_DISABLE_SEND_BEACON_7),
/* harmony export */   "_DYN_DISABLE_XHR": () => (/* binding */ _DYN_DISABLE_XHR),
/* harmony export */   "_DYN_EMIT_LINE_DELIMITED_0": () => (/* binding */ _DYN_EMIT_LINE_DELIMITED_0),
/* harmony export */   "_DYN_ENABLE_SEND_PROMISE": () => (/* binding */ _DYN_ENABLE_SEND_PROMISE),
/* harmony export */   "_DYN_ENABLE_SESSION_STORA5": () => (/* binding */ _DYN_ENABLE_SESSION_STORA5),
/* harmony export */   "_DYN_ENQUEUE": () => (/* binding */ _DYN_ENQUEUE),
/* harmony export */   "_DYN_ENVELOPE_TYPE": () => (/* binding */ _DYN_ENVELOPE_TYPE),
/* harmony export */   "_DYN_EVENTS_LIMIT_IN_MEM": () => (/* binding */ _DYN_EVENTS_LIMIT_IN_MEM),
/* harmony export */   "_DYN_EVENTS_SEND_REQUEST": () => (/* binding */ _DYN_EVENTS_SEND_REQUEST),
/* harmony export */   "_DYN_GET_HASH_CODE_SCORE": () => (/* binding */ _DYN_GET_HASH_CODE_SCORE),
/* harmony export */   "_DYN_GET_SAMPLING_SCORE": () => (/* binding */ _DYN_GET_SAMPLING_SCORE),
/* harmony export */   "_DYN_GET_SENDER_INST": () => (/* binding */ _DYN_GET_SENDER_INST),
/* harmony export */   "_DYN_INITIALIZE": () => (/* binding */ _DYN_INITIALIZE),
/* harmony export */   "_DYN_INSTRUMENTATION_KEY": () => (/* binding */ _DYN_INSTRUMENTATION_KEY),
/* harmony export */   "_DYN_IS_BEACON_API_DISABL3": () => (/* binding */ _DYN_IS_BEACON_API_DISABL3),
/* harmony export */   "_DYN_ITEM": () => (/* binding */ _DYN_ITEM),
/* harmony export */   "_DYN_ITEMS_ACCEPTED": () => (/* binding */ _DYN_ITEMS_ACCEPTED),
/* harmony export */   "_DYN_ITEMS_RECEIVED": () => (/* binding */ _DYN_ITEMS_RECEIVED),
/* harmony export */   "_DYN_LENGTH": () => (/* binding */ _DYN_LENGTH),
/* harmony export */   "_DYN_MARK_AS_SENT": () => (/* binding */ _DYN_MARK_AS_SENT),
/* harmony export */   "_DYN_MAX_BATCH_INTERVAL": () => (/* binding */ _DYN_MAX_BATCH_INTERVAL),
/* harmony export */   "_DYN_MAX_BATCH_SIZE_IN_BY1": () => (/* binding */ _DYN_MAX_BATCH_SIZE_IN_BY1),
/* harmony export */   "_DYN_MEASUREMENTS": () => (/* binding */ _DYN_MEASUREMENTS),
/* harmony export */   "_DYN_NAME": () => (/* binding */ _DYN_NAME),
/* harmony export */   "_DYN_ONUNLOAD_DISABLE_BEA2": () => (/* binding */ _DYN_ONUNLOAD_DISABLE_BEA2),
/* harmony export */   "_DYN_ONUNLOAD_DISABLE_FET6": () => (/* binding */ _DYN_ONUNLOAD_DISABLE_FET6),
/* harmony export */   "_DYN_ORI_PAYLOAD": () => (/* binding */ _DYN_ORI_PAYLOAD),
/* harmony export */   "_DYN_PUSH": () => (/* binding */ _DYN_PUSH),
/* harmony export */   "_DYN_SAMPLE_RATE": () => (/* binding */ _DYN_SAMPLE_RATE),
/* harmony export */   "_DYN_SERIALIZE": () => (/* binding */ _DYN_SERIALIZE),
/* harmony export */   "_DYN_STRINGIFY": () => (/* binding */ _DYN_STRINGIFY),
/* harmony export */   "_DYN_TAGS": () => (/* binding */ _DYN_TAGS),
/* harmony export */   "_DYN_TO_STRING": () => (/* binding */ _DYN_TO_STRING),
/* harmony export */   "_DYN_TRACE_ID": () => (/* binding */ _DYN_TRACE_ID),
/* harmony export */   "_DYN_TRIGGER_SEND": () => (/* binding */ _DYN_TRIGGER_SEND),
/* harmony export */   "_DYN_UNLOAD_TRANSPORTS": () => (/* binding */ _DYN_UNLOAD_TRANSPORTS),
/* harmony export */   "_DYN__BUFFER": () => (/* binding */ _DYN__BUFFER),
/* harmony export */   "_DYN__BUFFER__KEY": () => (/* binding */ _DYN__BUFFER__KEY),
/* harmony export */   "_DYN__GET": () => (/* binding */ _DYN__GET),
/* harmony export */   "_DYN__MAX__BUFFER__SIZE": () => (/* binding */ _DYN__MAX__BUFFER__SIZE),
/* harmony export */   "_DYN__ON_ERROR": () => (/* binding */ _DYN__ON_ERROR),
/* harmony export */   "_DYN__ON_PARTIAL_SUCCESS": () => (/* binding */ _DYN__ON_PARTIAL_SUCCESS),
/* harmony export */   "_DYN__ON_SUCCESS": () => (/* binding */ _DYN__ON_SUCCESS),
/* harmony export */   "_DYN__SENDER": () => (/* binding */ _DYN__SENDER),
/* harmony export */   "_DYN__SENT__BUFFER__KEY": () => (/* binding */ _DYN__SENT__BUFFER__KEY)
/* harmony export */ });
/*
 * Application Insights JavaScript SDK - Channel, 3.3.0
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */


// @skip-file-minify
// ##############################################################
// AUTO GENERATED FILE: This file is Auto Generated during build.
// ##############################################################
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// Note: DON'T Export these const from the package as we are still targeting ES3 this will export a mutable variables that someone could change!!!
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
var _DYN_TAGS = "tags"; // Count: 17
var _DYN_DEVICE_TYPE = "deviceType"; // Count: 3
var _DYN_DATA = "data"; // Count: 15
var _DYN_NAME = "name"; // Count: 8
var _DYN_TRACE_ID = "traceID"; // Count: 5
var _DYN_LENGTH = "length"; // Count: 38
var _DYN_STRINGIFY = "stringify"; // Count: 5
var _DYN_MEASUREMENTS = "measurements"; // Count: 7
var _DYN_DATA_TYPE = "dataType"; // Count: 10
var _DYN_ENVELOPE_TYPE = "envelopeType"; // Count: 7
var _DYN_TO_STRING = "toString"; // Count: 7
var _DYN__GET = "_get"; // Count: 5
var _DYN_ENQUEUE = "enqueue"; // Count: 7
var _DYN_COUNT = "count"; // Count: 7
var _DYN_EVENTS_LIMIT_IN_MEM = "eventsLimitInMem"; // Count: 2
var _DYN_PUSH = "push"; // Count: 9
var _DYN_ITEM = "item"; // Count: 6
var _DYN_EMIT_LINE_DELIMITED_0 = "emitLineDelimitedJson"; // Count: 3
var _DYN_CLEAR = "clear"; // Count: 6
var _DYN_CREATE_NEW = "createNew"; // Count: 3
var _DYN_MARK_AS_SENT = "markAsSent"; // Count: 4
var _DYN_CLEAR_SENT = "clearSent"; // Count: 5
var _DYN_BUFFER_OVERRIDE = "bufferOverride"; // Count: 3
var _DYN__BUFFER__KEY = "BUFFER_KEY"; // Count: 5
var _DYN__SENT__BUFFER__KEY = "SENT_BUFFER_KEY"; // Count: 8
var _DYN_CONCAT = "concat"; // Count: 6
var _DYN__MAX__BUFFER__SIZE = "MAX_BUFFER_SIZE"; // Count: 5
var _DYN_TRIGGER_SEND = "triggerSend"; // Count: 5
var _DYN_DIAG_LOG = "diagLog"; // Count: 16
var _DYN_INITIALIZE = "initialize"; // Count: 3
var _DYN__SENDER = "_sender"; // Count: 5
var _DYN_CUSTOM_HEADERS = "customHeaders"; // Count: 3
var _DYN_MAX_BATCH_SIZE_IN_BY1 = "maxBatchSizeInBytes"; // Count: 2
var _DYN_ONUNLOAD_DISABLE_BEA2 = "onunloadDisableBeacon"; // Count: 3
var _DYN_IS_BEACON_API_DISABL3 = "isBeaconApiDisabled"; // Count: 3
var _DYN_ALWAYS_USE_XHR_OVERR4 = "alwaysUseXhrOverride"; // Count: 2
var _DYN_DISABLE_XHR = "disableXhr"; // Count: 3
var _DYN_ENABLE_SESSION_STORA5 = "enableSessionStorageBuffer"; // Count: 2
var _DYN__BUFFER = "_buffer"; // Count: 9
var _DYN_ONUNLOAD_DISABLE_FET6 = "onunloadDisableFetch"; // Count: 2
var _DYN_DISABLE_SEND_BEACON_7 = "disableSendBeaconSplit"; // Count: 2
var _DYN_INSTRUMENTATION_KEY = "instrumentationKey"; // Count: 2
var _DYN_ENABLE_SEND_PROMISE = "enableSendPromise"; // Count: 2
var _DYN_GET_SENDER_INST = "getSenderInst"; // Count: 4
var _DYN_UNLOAD_TRANSPORTS = "unloadTransports"; // Count: 2
var _DYN_CONVERT_UNDEFINED = "convertUndefined"; // Count: 2
var _DYN_MAX_BATCH_INTERVAL = "maxBatchInterval"; // Count: 2
var _DYN_SERIALIZE = "serialize"; // Count: 4
var _DYN__ON_ERROR = "_onError"; // Count: 7
var _DYN__ON_PARTIAL_SUCCESS = "_onPartialSuccess"; // Count: 3
var _DYN__ON_SUCCESS = "_onSuccess"; // Count: 6
var _DYN_ITEMS_RECEIVED = "itemsReceived"; // Count: 3
var _DYN_ITEMS_ACCEPTED = "itemsAccepted"; // Count: 3
var _DYN_ORI_PAYLOAD = "oriPayload"; // Count: 3
var _DYN_BASE_TYPE = "baseType"; // Count: 4
var _DYN_SAMPLE_RATE = "sampleRate"; // Count: 4
var _DYN_EVENTS_SEND_REQUEST = "eventsSendRequest"; // Count: 2
var _DYN_GET_SAMPLING_SCORE = "getSamplingScore"; // Count: 2
var _DYN_GET_HASH_CODE_SCORE = "getHashCodeScore"; // Count: 4
//# sourceMappingURL=__DynamicConstants.js.map

/***/ }),
/* 122 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DependencyEnvelopeCreator": () => (/* binding */ DependencyEnvelopeCreator),
/* harmony export */   "EnvelopeCreator": () => (/* binding */ EnvelopeCreator),
/* harmony export */   "EventEnvelopeCreator": () => (/* binding */ EventEnvelopeCreator),
/* harmony export */   "ExceptionEnvelopeCreator": () => (/* binding */ ExceptionEnvelopeCreator),
/* harmony export */   "MetricEnvelopeCreator": () => (/* binding */ MetricEnvelopeCreator),
/* harmony export */   "PageViewEnvelopeCreator": () => (/* binding */ PageViewEnvelopeCreator),
/* harmony export */   "PageViewPerformanceEnvelopeCreator": () => (/* binding */ PageViewPerformanceEnvelopeCreator),
/* harmony export */   "TraceEnvelopeCreator": () => (/* binding */ TraceEnvelopeCreator)
/* harmony export */ });
/* harmony import */ var _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(33);
/* harmony import */ var _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(115);
/* harmony import */ var _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(95);
/* harmony import */ var _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(100);
/* harmony import */ var _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(91);
/* harmony import */ var _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(107);
/* harmony import */ var _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(110);
/* harmony import */ var _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(101);
/* harmony import */ var _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(102);
/* harmony import */ var _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(103);
/* harmony import */ var _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(105);
/* harmony import */ var _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(109);
/* harmony import */ var _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(108);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(45);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(30);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(44);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(50);
/* harmony import */ var _InternalConstants__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(123);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(121);
/*
 * Application Insights JavaScript SDK - Channel, 3.3.0
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */





// these two constants are used to filter out properties not needed when trying to extract custom properties and measurements from the incoming payload
var strBaseType = "baseType";
var strBaseData = "baseData";
var strProperties = "properties";
var strTrue = "true";
function _setValueIf(target, field, value) {
    return (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.setValue)(target, field, value, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.isTruthy);
}
/*
 * Maps Part A data from CS 4.0
 */
function _extractPartAExtensions(logger, item, env) {
    // todo: switch to keys from common in this method
    var envTags = env[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_TAGS /* @min:%2etags */] = env[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_TAGS /* @min:%2etags */] || {};
    var itmExt = item.ext = item.ext || {};
    var itmTags = item[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_TAGS /* @min:%2etags */] = item[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_TAGS /* @min:%2etags */] || [];
    var extUser = itmExt.user;
    if (extUser) {
        _setValueIf(envTags, _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_3__.CtxTagKeys.userAuthUserId, extUser.authId);
        _setValueIf(envTags, _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_3__.CtxTagKeys.userId, extUser.id || extUser.localId);
    }
    var extApp = itmExt.app;
    if (extApp) {
        _setValueIf(envTags, _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_3__.CtxTagKeys.sessionId, extApp.sesId);
    }
    var extDevice = itmExt.device;
    if (extDevice) {
        _setValueIf(envTags, _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_3__.CtxTagKeys.deviceId, extDevice.id || extDevice.localId);
        _setValueIf(envTags, _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_3__.CtxTagKeys[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_DEVICE_TYPE /* @min:%2edeviceType */], extDevice.deviceClass);
        _setValueIf(envTags, _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_3__.CtxTagKeys.deviceIp, extDevice.ip);
        _setValueIf(envTags, _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_3__.CtxTagKeys.deviceModel, extDevice.model);
        _setValueIf(envTags, _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_3__.CtxTagKeys[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_DEVICE_TYPE /* @min:%2edeviceType */], extDevice[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_DEVICE_TYPE /* @min:%2edeviceType */]);
    }
    var web = item.ext.web;
    if (web) {
        _setValueIf(envTags, _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_3__.CtxTagKeys.deviceLanguage, web.browserLang);
        _setValueIf(envTags, _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_3__.CtxTagKeys.deviceBrowserVersion, web.browserVer);
        _setValueIf(envTags, _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_3__.CtxTagKeys.deviceBrowser, web.browser);
        var envData = env[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_DATA /* @min:%2edata */] = env[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_DATA /* @min:%2edata */] || {};
        var envBaseData = envData[strBaseData] = envData[strBaseData] || {};
        var envProps = envBaseData[strProperties] = envBaseData[strProperties] || {};
        _setValueIf(envProps, "domain", web.domain);
        _setValueIf(envProps, "isManual", web.isManual ? strTrue : null);
        _setValueIf(envProps, "screenRes", web.screenRes);
        _setValueIf(envProps, "userConsent", web.userConsent ? strTrue : null);
    }
    var extOs = itmExt.os;
    if (extOs) {
        _setValueIf(envTags, _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_3__.CtxTagKeys.deviceOS, extOs[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_NAME /* @min:%2ename */]);
        _setValueIf(envTags, _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_3__.CtxTagKeys.deviceOSVersion, extOs.osVer);
    }
    // No support for mapping Trace.traceState to 2.0 as it is currently empty
    var extTrace = itmExt.trace;
    if (extTrace) {
        _setValueIf(envTags, _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_3__.CtxTagKeys.operationParentId, extTrace.parentID);
        _setValueIf(envTags, _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_3__.CtxTagKeys.operationName, (0,_microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_4__.dataSanitizeString)(logger, extTrace[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_NAME /* @min:%2ename */]));
        _setValueIf(envTags, _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_3__.CtxTagKeys.operationId, extTrace[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_TRACE_ID /* @min:%2etraceID */]);
    }
    // Sample 4.0 schema
    //  {
    //     "time" : "2018-09-05T22:51:22.4936Z",
    //     "name" : "MetricWithNamespace",
    //     "iKey" : "ABC-5a4cbd20-e601-4ef5-a3c6-5d6577e4398e",
    //     "ext": {  "cloud": {
    //          "role": "WATSON3",
    //          "roleInstance": "CO4AEAP00000260"
    //      },
    //      "device": {}, "correlation": {} },
    //      "tags": [
    //        { "amazon.region" : "east2" },
    //        { "os.expid" : "wp:02df239" }
    //     ]
    //   }
    var tgs = {};
    // deals with tags.push({object})
    for (var i = itmTags[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_LENGTH /* @min:%2elength */] - 1; i >= 0; i--) {
        var tg = itmTags[i];
        (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.objForEachKey)(tg, function (key, value) {
            tgs[key] = value;
        });
        itmTags.splice(i, 1);
    }
    // deals with tags[key]=value (and handles hasOwnProperty)
    (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.objForEachKey)(itmTags, function (tg, value) {
        tgs[tg] = value;
    });
    var theTags = (0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_5__.__assignFn)((0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_5__.__assignFn)({}, envTags), tgs);
    if (!theTags[_microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_3__.CtxTagKeys.internalSdkVersion]) {
        // Append a version in case it is not already set
        theTags[_microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_3__.CtxTagKeys.internalSdkVersion] = (0,_microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_4__.dataSanitizeString)(logger, "javascript:".concat(EnvelopeCreator.Version), 64);
    }
    env[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_TAGS /* @min:%2etags */] = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.optimizeObject)(theTags);
}
function _extractPropsAndMeasurements(data, properties, measurements) {
    if (!(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(data)) {
        (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.objForEachKey)(data, function (key, value) {
            if ((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.isNumber)(value)) {
                measurements[key] = value;
            }
            else if ((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.isString)(value)) {
                properties[key] = value;
            }
            else if ((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_6__.hasJSON)()) {
                properties[key] = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_6__.getJSON)()[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_STRINGIFY /* @min:%2estringify */](value);
            }
        });
    }
}
function _convertPropsUndefinedToCustomDefinedValue(properties, customUndefinedValue) {
    if (!(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(properties)) {
        (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.objForEachKey)(properties, function (key, value) {
            properties[key] = value || customUndefinedValue;
        });
    }
}
// TODO: Do we want this to take logger as arg or use this._logger as nonstatic?
function _createEnvelope(logger, envelopeType, telemetryItem, data) {
    var envelope = new _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_7__.Envelope(logger, data, envelopeType);
    _setValueIf(envelope, "sampleRate", telemetryItem[_microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_8__.SampleRate]);
    if ((telemetryItem[strBaseData] || {}).startTime) {
        // Starting from Version 3.0.3, the time property will be assigned by the startTime value,
        // which records the loadEvent time for the pageView event.
        envelope.time = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.toISOString)(telemetryItem[strBaseData].startTime);
    }
    envelope.iKey = telemetryItem.iKey;
    var iKeyNoDashes = telemetryItem.iKey.replace(/-/g, "");
    envelope[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_NAME /* @min:%2ename */] = envelope[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_NAME /* @min:%2ename */].replace("{0}", iKeyNoDashes);
    // extract all extensions from ctx
    _extractPartAExtensions(logger, telemetryItem, envelope);
    // loop through the envelope tags (extension of Part A) and pick out the ones that should go in outgoing envelope tags
    telemetryItem[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_TAGS /* @min:%2etags */] = telemetryItem[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_TAGS /* @min:%2etags */] || [];
    return (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.optimizeObject)(envelope);
}
function EnvelopeCreatorInit(logger, telemetryItem) {
    if ((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(telemetryItem[strBaseData])) {
        (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_9__._throwInternal)(logger, 1 /* eLoggingSeverity.CRITICAL */, 46 /* _eInternalMessageId.TelemetryEnvelopeInvalid */, "telemetryItem.baseData cannot be null.");
    }
}
var EnvelopeCreator = {
    Version: '3.3.0'
};
function DependencyEnvelopeCreator(logger, telemetryItem, customUndefinedValue) {
    EnvelopeCreatorInit(logger, telemetryItem);
    var customMeasurements = telemetryItem[strBaseData][_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_MEASUREMENTS /* @min:%2emeasurements */] || {};
    var customProperties = telemetryItem[strBaseData][strProperties] || {};
    _extractPropsAndMeasurements(telemetryItem[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_DATA /* @min:%2edata */], customProperties, customMeasurements);
    if (!(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(customUndefinedValue)) {
        _convertPropsUndefinedToCustomDefinedValue(customProperties, customUndefinedValue);
    }
    var bd = telemetryItem[strBaseData];
    if ((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(bd)) {
        (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_9__._warnToConsole)(logger, "Invalid input for dependency data");
        return null;
    }
    var method = bd[strProperties] && bd[strProperties][_microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_8__.HttpMethod] ? bd[strProperties][_microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_8__.HttpMethod] : "GET";
    var remoteDepData = new _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_10__.RemoteDependencyData(logger, bd.id, bd.target, bd[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_NAME /* @min:%2ename */], bd[_InternalConstants__WEBPACK_IMPORTED_MODULE_11__.STR_DURATION /* @min:%2eduration */], bd.success, bd.responseCode, method, bd.type, bd.correlationContext, customProperties, customMeasurements);
    var data = new _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_12__.Data(_microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_10__.RemoteDependencyData[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_DATA_TYPE /* @min:%2edataType */], remoteDepData);
    return _createEnvelope(logger, _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_10__.RemoteDependencyData[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_ENVELOPE_TYPE /* @min:%2eenvelopeType */], telemetryItem, data);
}
function EventEnvelopeCreator(logger, telemetryItem, customUndefinedValue) {
    EnvelopeCreatorInit(logger, telemetryItem);
    var customProperties = {};
    var customMeasurements = {};
    if (telemetryItem[strBaseType] !== _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_13__.Event[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_DATA_TYPE /* @min:%2edataType */]) {
        customProperties["baseTypeSource"] = telemetryItem[strBaseType]; // save the passed in base type as a property
    }
    if (telemetryItem[strBaseType] === _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_13__.Event[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_DATA_TYPE /* @min:%2edataType */]) { // take collection
        customProperties = telemetryItem[strBaseData][strProperties] || {};
        customMeasurements = telemetryItem[strBaseData][_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_MEASUREMENTS /* @min:%2emeasurements */] || {};
    }
    else { // if its not a known type, convert to custom event
        if (telemetryItem[strBaseData]) {
            _extractPropsAndMeasurements(telemetryItem[strBaseData], customProperties, customMeasurements);
        }
    }
    // Extract root level properties from part C telemetryItem.data
    _extractPropsAndMeasurements(telemetryItem[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_DATA /* @min:%2edata */], customProperties, customMeasurements);
    if (!(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(customUndefinedValue)) {
        _convertPropsUndefinedToCustomDefinedValue(customProperties, customUndefinedValue);
    }
    var eventName = telemetryItem[strBaseData][_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_NAME /* @min:%2ename */];
    var eventData = new _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_13__.Event(logger, eventName, customProperties, customMeasurements);
    var data = new _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_12__.Data(_microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_13__.Event[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_DATA_TYPE /* @min:%2edataType */], eventData);
    return _createEnvelope(logger, _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_13__.Event[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_ENVELOPE_TYPE /* @min:%2eenvelopeType */], telemetryItem, data);
}
function ExceptionEnvelopeCreator(logger, telemetryItem, customUndefinedValue) {
    EnvelopeCreatorInit(logger, telemetryItem);
    // Extract root level properties from part C telemetryItem.data
    var customMeasurements = telemetryItem[strBaseData][_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_MEASUREMENTS /* @min:%2emeasurements */] || {};
    var customProperties = telemetryItem[strBaseData][strProperties] || {};
    _extractPropsAndMeasurements(telemetryItem[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_DATA /* @min:%2edata */], customProperties, customMeasurements);
    if (!(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(customUndefinedValue)) {
        _convertPropsUndefinedToCustomDefinedValue(customProperties, customUndefinedValue);
    }
    var bd = telemetryItem[strBaseData];
    var exData = _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_14__.Exception.CreateFromInterface(logger, bd, customProperties, customMeasurements);
    var data = new _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_12__.Data(_microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_14__.Exception[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_DATA_TYPE /* @min:%2edataType */], exData);
    return _createEnvelope(logger, _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_14__.Exception[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_ENVELOPE_TYPE /* @min:%2eenvelopeType */], telemetryItem, data);
}
function MetricEnvelopeCreator(logger, telemetryItem, customUndefinedValue) {
    EnvelopeCreatorInit(logger, telemetryItem);
    var baseData = telemetryItem[strBaseData];
    var props = baseData[strProperties] || {};
    var measurements = baseData[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_MEASUREMENTS /* @min:%2emeasurements */] || {};
    _extractPropsAndMeasurements(telemetryItem[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_DATA /* @min:%2edata */], props, measurements);
    if (!(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(customUndefinedValue)) {
        _convertPropsUndefinedToCustomDefinedValue(props, customUndefinedValue);
    }
    var baseMetricData = new _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_15__.Metric(logger, baseData[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_NAME /* @min:%2ename */], baseData.average, baseData.sampleCount, baseData.min, baseData.max, baseData.stdDev, props, measurements);
    var data = new _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_12__.Data(_microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_15__.Metric[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_DATA_TYPE /* @min:%2edataType */], baseMetricData);
    return _createEnvelope(logger, _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_15__.Metric[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_ENVELOPE_TYPE /* @min:%2eenvelopeType */], telemetryItem, data);
}
function PageViewEnvelopeCreator(logger, telemetryItem, customUndefinedValue) {
    EnvelopeCreatorInit(logger, telemetryItem);
    // Since duration is not part of the domain properties in Common Schema, extract it from part C
    var duration;
    var baseData = telemetryItem[strBaseData];
    if (!(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(baseData) &&
        !(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(baseData[strProperties]) &&
        !(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(baseData[strProperties][_InternalConstants__WEBPACK_IMPORTED_MODULE_11__.STR_DURATION])) { // from part B properties
        duration = baseData[strProperties][_InternalConstants__WEBPACK_IMPORTED_MODULE_11__.STR_DURATION];
        delete baseData[strProperties][_InternalConstants__WEBPACK_IMPORTED_MODULE_11__.STR_DURATION];
    }
    else if (!(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(telemetryItem[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_DATA /* @min:%2edata */]) &&
        !(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(telemetryItem[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_DATA /* @min:%2edata */][_InternalConstants__WEBPACK_IMPORTED_MODULE_11__.STR_DURATION])) { // from custom properties
        duration = telemetryItem[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_DATA /* @min:%2edata */][_InternalConstants__WEBPACK_IMPORTED_MODULE_11__.STR_DURATION];
        delete telemetryItem[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_DATA /* @min:%2edata */][_InternalConstants__WEBPACK_IMPORTED_MODULE_11__.STR_DURATION];
    }
    var bd = telemetryItem[strBaseData];
    // special case: pageview.id is grabbed from current operation id. Analytics plugin is decoupled from properties plugin, so this is done here instead. This can be made a default telemetry intializer instead if needed to be decoupled from channel
    var currentContextId;
    if (((telemetryItem.ext || {}).trace || {})[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_TRACE_ID /* @min:%2etraceID */]) {
        currentContextId = telemetryItem.ext.trace[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_TRACE_ID /* @min:%2etraceID */];
    }
    var id = bd.id || currentContextId;
    var name = bd[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_NAME /* @min:%2ename */];
    var url = bd.uri;
    var properties = bd[strProperties] || {};
    var measurements = bd[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_MEASUREMENTS /* @min:%2emeasurements */] || {};
    // refUri is a field that Breeze still does not recognize as part of Part B. For now, put it in Part C until it supports it as a domain property
    if (!(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(bd.refUri)) {
        properties["refUri"] = bd.refUri;
    }
    // pageType is a field that Breeze still does not recognize as part of Part B. For now, put it in Part C until it supports it as a domain property
    if (!(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(bd.pageType)) {
        properties["pageType"] = bd.pageType;
    }
    // isLoggedIn is a field that Breeze still does not recognize as part of Part B. For now, put it in Part C until it supports it as a domain property
    if (!(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(bd.isLoggedIn)) {
        properties["isLoggedIn"] = bd.isLoggedIn[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_TO_STRING /* @min:%2etoString */]();
    }
    // pageTags is a field that Breeze still does not recognize as part of Part B. For now, put it in Part C until it supports it as a domain property
    if (!(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(bd[strProperties])) {
        var pageTags = bd[strProperties];
        (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.objForEachKey)(pageTags, function (key, value) {
            properties[key] = value;
        });
    }
    _extractPropsAndMeasurements(telemetryItem[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_DATA /* @min:%2edata */], properties, measurements);
    if (!(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(customUndefinedValue)) {
        _convertPropsUndefinedToCustomDefinedValue(properties, customUndefinedValue);
    }
    var pageViewData = new _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_16__.PageView(logger, name, url, duration, properties, measurements, id);
    var data = new _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_12__.Data(_microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_16__.PageView[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_DATA_TYPE /* @min:%2edataType */], pageViewData);
    return _createEnvelope(logger, _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_16__.PageView[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_ENVELOPE_TYPE /* @min:%2eenvelopeType */], telemetryItem, data);
}
function PageViewPerformanceEnvelopeCreator(logger, telemetryItem, customUndefinedValue) {
    EnvelopeCreatorInit(logger, telemetryItem);
    var bd = telemetryItem[strBaseData];
    var name = bd[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_NAME /* @min:%2ename */];
    var url = bd.uri || bd.url;
    var properties = bd[strProperties] || {};
    var measurements = bd[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_MEASUREMENTS /* @min:%2emeasurements */] || {};
    _extractPropsAndMeasurements(telemetryItem[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_DATA /* @min:%2edata */], properties, measurements);
    if (!(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(customUndefinedValue)) {
        _convertPropsUndefinedToCustomDefinedValue(properties, customUndefinedValue);
    }
    var baseData = new _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_17__.PageViewPerformance(logger, name, url, undefined, properties, measurements, bd);
    var data = new _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_12__.Data(_microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_17__.PageViewPerformance[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_DATA_TYPE /* @min:%2edataType */], baseData);
    return _createEnvelope(logger, _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_17__.PageViewPerformance[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_ENVELOPE_TYPE /* @min:%2eenvelopeType */], telemetryItem, data);
}
function TraceEnvelopeCreator(logger, telemetryItem, customUndefinedValue) {
    EnvelopeCreatorInit(logger, telemetryItem);
    var message = telemetryItem[strBaseData].message;
    var severityLevel = telemetryItem[strBaseData].severityLevel;
    var props = telemetryItem[strBaseData][strProperties] || {};
    var measurements = telemetryItem[strBaseData][_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_MEASUREMENTS /* @min:%2emeasurements */] || {};
    _extractPropsAndMeasurements(telemetryItem[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_DATA /* @min:%2edata */], props, measurements);
    if (!(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(customUndefinedValue)) {
        _convertPropsUndefinedToCustomDefinedValue(props, customUndefinedValue);
    }
    var baseData = new _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_18__.Trace(logger, message, severityLevel, props, measurements);
    var data = new _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_12__.Data(_microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_18__.Trace[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_DATA_TYPE /* @min:%2edataType */], baseData);
    return _createEnvelope(logger, _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_18__.Trace[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_ENVELOPE_TYPE /* @min:%2eenvelopeType */], telemetryItem, data);
}
//# sourceMappingURL=EnvelopeCreator.js.map

/***/ }),
/* 123 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "STR_DURATION": () => (/* binding */ STR_DURATION)
/* harmony export */ });
/*
 * Application Insights JavaScript SDK - Channel, 3.3.0
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */


// ###################################################################################################################################################
// Note: DON'T Export these const from the package as we are still targeting IE/ES5 this will export a mutable variables that someone could change ###
// ###################################################################################################################################################
// Generally you should only put values that are used more than 2 times and then only if not already exposed as a constant (such as SdkCoreNames)
// as when using "short" named values from here they will be will be minified smaller than the SdkCoreNames[eSdkCoreNames.xxxx] value.
var STR_DURATION = "duration";
//# sourceMappingURL=InternalConstants.js.map

/***/ }),
/* 124 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Serializer": () => (/* binding */ Serializer)
/* harmony export */ });
/* harmony import */ var _microsoft_dynamicproto_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(35);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(44);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(50);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(30);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(121);
/*
 * Application Insights JavaScript SDK - Channel, 3.3.0
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */



var Serializer = /** @class */ (function () {
    function Serializer(logger) {
        (0,_microsoft_dynamicproto_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Serializer, this, function (_self) {
            /**
             * Serializes the current object to a JSON string.
             */
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_SERIALIZE /* @min:%2eserialize */] = function (input) {
                var output = _serializeObject(input, "root");
                try {
                    return (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__.getJSON)()[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_STRINGIFY /* @min:%2estringify */](output);
                }
                catch (e) {
                    // if serialization fails return an empty string
                    (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_3__._throwInternal)(logger, 1 /* eLoggingSeverity.CRITICAL */, 48 /* _eInternalMessageId.CannotSerializeObject */, (e && (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_4__.isFunction)(e[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_TO_STRING /* @min:%2etoString */])) ? e[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_TO_STRING /* @min:%2etoString */]() : "Error serializing object", null, true);
                }
            };
            function _serializeObject(source, name) {
                var circularReferenceCheck = "__aiCircularRefCheck";
                var output = {};
                if (!source) {
                    (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_3__._throwInternal)(logger, 1 /* eLoggingSeverity.CRITICAL */, 48 /* _eInternalMessageId.CannotSerializeObject */, "cannot serialize object because it is null or undefined", { name: name }, true);
                    return output;
                }
                if (source[circularReferenceCheck]) {
                    (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_3__._throwInternal)(logger, 2 /* eLoggingSeverity.WARNING */, 50 /* _eInternalMessageId.CircularReferenceDetected */, "Circular reference detected while serializing object", { name: name }, true);
                    return output;
                }
                if (!source.aiDataContract) {
                    // special case for measurements/properties/tags
                    if (name === "measurements") {
                        output = _serializeStringMap(source, "number", name);
                    }
                    else if (name === "properties") {
                        output = _serializeStringMap(source, "string", name);
                    }
                    else if (name === "tags") {
                        output = _serializeStringMap(source, "string", name);
                    }
                    else if ((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_4__.isArray)(source)) {
                        output = _serializeArray(source, name);
                    }
                    else {
                        (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_3__._throwInternal)(logger, 2 /* eLoggingSeverity.WARNING */, 49 /* _eInternalMessageId.CannotSerializeObjectNonSerializable */, "Attempting to serialize an object which does not implement ISerializable", { name: name }, true);
                        try {
                            // verify that the object can be stringified
                            (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__.getJSON)()[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_STRINGIFY /* @min:%2estringify */](source);
                            output = source;
                        }
                        catch (e) {
                            // if serialization fails return an empty string
                            (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_3__._throwInternal)(logger, 1 /* eLoggingSeverity.CRITICAL */, 48 /* _eInternalMessageId.CannotSerializeObject */, (e && (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_4__.isFunction)(e[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_TO_STRING /* @min:%2etoString */])) ? e[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_TO_STRING /* @min:%2etoString */]() : "Error serializing object", null, true);
                        }
                    }
                    return output;
                }
                source[circularReferenceCheck] = true;
                (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_4__.objForEachKey)(source.aiDataContract, function (field, contract) {
                    var isRequired = ((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_4__.isFunction)(contract)) ? (contract() & 1 /* FieldType.Required */) : (contract & 1 /* FieldType.Required */);
                    var isHidden = ((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_4__.isFunction)(contract)) ? (contract() & 4 /* FieldType.Hidden */) : (contract & 4 /* FieldType.Hidden */);
                    var isArray = contract & 2 /* FieldType.Array */;
                    var isPresent = source[field] !== undefined;
                    var isObj = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_4__.isObject)(source[field]) && source[field] !== null;
                    if (isRequired && !isPresent && !isArray) {
                        (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_3__._throwInternal)(logger, 1 /* eLoggingSeverity.CRITICAL */, 24 /* _eInternalMessageId.MissingRequiredFieldSpecification */, "Missing required field specification. The field is required but not present on source", { field: field, name: name });
                        // If not in debug mode, continue and hope the error is permissible
                    }
                    else if (!isHidden) { // Don't serialize hidden fields
                        var value = void 0;
                        if (isObj) {
                            if (isArray) {
                                // special case; recurse on each object in the source array
                                value = _serializeArray(source[field], field);
                            }
                            else {
                                // recurse on the source object in this field
                                value = _serializeObject(source[field], field);
                            }
                        }
                        else {
                            // assign the source field to the output even if undefined or required
                            value = source[field];
                        }
                        // only emit this field if the value is defined
                        if (value !== undefined) {
                            output[field] = value;
                        }
                    }
                });
                delete source[circularReferenceCheck];
                return output;
            }
            function _serializeArray(sources, name) {
                var output;
                if (!!sources) {
                    if (!(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_4__.isArray)(sources)) {
                        (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_3__._throwInternal)(logger, 1 /* eLoggingSeverity.CRITICAL */, 54 /* _eInternalMessageId.ItemNotInArray */, "This field was specified as an array in the contract but the item is not an array.\r\n", { name: name }, true);
                    }
                    else {
                        output = [];
                        for (var i = 0; i < sources[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LENGTH /* @min:%2elength */]; i++) {
                            var source = sources[i];
                            var item = _serializeObject(source, name + "[" + i + "]");
                            output[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_PUSH /* @min:%2epush */](item);
                        }
                    }
                }
                return output;
            }
            function _serializeStringMap(map, expectedType, name) {
                var output;
                if (map) {
                    output = {};
                    (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_4__.objForEachKey)(map, function (field, value) {
                        if (expectedType === "string") {
                            if (value === undefined) {
                                output[field] = "undefined";
                            }
                            else if (value === null) {
                                output[field] = "null";
                            }
                            else if (!value[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_TO_STRING /* @min:%2etoString */]) {
                                output[field] = "invalid field: toString() is not defined.";
                            }
                            else {
                                output[field] = value[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_TO_STRING /* @min:%2etoString */]();
                            }
                        }
                        else if (expectedType === "number") {
                            if (value === undefined) {
                                output[field] = "undefined";
                            }
                            else if (value === null) {
                                output[field] = "null";
                            }
                            else {
                                var num = parseFloat(value);
                                output[field] = num;
                            }
                        }
                        else {
                            output[field] = "invalid field: " + name + " is of unknown type.";
                            (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_3__._throwInternal)(logger, 1 /* eLoggingSeverity.CRITICAL */, output[field], null, true);
                        }
                    });
                }
                return output;
            }
        });
    }
// Removed Stub for Serializer.prototype.serialize.
    // This is a workaround for an IE bug when using dynamicProto() with classes that don't have any
    // non-dynamic functions or static properties/functions when using uglify-js to minify the resulting code.
    Serializer.__ieDyn=1;

    return Serializer;
}());

//# sourceMappingURL=Serializer.js.map

/***/ }),
/* 125 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ArraySendBuffer": () => (/* binding */ ArraySendBuffer),
/* harmony export */   "SessionStorageSendBuffer": () => (/* binding */ SessionStorageSendBuffer)
/* harmony export */ });
/* harmony import */ var _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(33);
/* harmony import */ var _microsoft_dynamicproto_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(35);
/* harmony import */ var _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(97);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(50);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(30);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(44);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(45);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(121);
/*
 * Application Insights JavaScript SDK - Channel, 3.3.0
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */





var BaseSendBuffer = /** @class */ (function () {
    function BaseSendBuffer(logger, config) {
        var _buffer = [];
        var _bufferFullMessageSent = false;
        var _maxRetryCnt = config.maxRetryCnt;
        this[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN__GET /* @min:%2e_get */] = function () {
            return _buffer;
        };
        this._set = function (buffer) {
            _buffer = buffer;
            return _buffer;
        };
        (0,_microsoft_dynamicproto_js__WEBPACK_IMPORTED_MODULE_1__["default"])(BaseSendBuffer, this, function (_self) {
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_ENQUEUE /* @min:%2eenqueue */] = function (payload) {
                if (_self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_COUNT /* @min:%2ecount */]() >= config[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_EVENTS_LIMIT_IN_MEM /* @min:%2eeventsLimitInMem */]) {
                    // sent internal log only once per page view
                    if (!_bufferFullMessageSent) {
                        (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__._throwInternal)(logger, 2 /* eLoggingSeverity.WARNING */, 105 /* _eInternalMessageId.InMemoryStorageBufferFull */, "Maximum in-memory buffer size reached: " + _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_COUNT /* @min:%2ecount */](), true);
                        _bufferFullMessageSent = true;
                    }
                    return;
                }
                payload.cnt = payload.cnt || 0;
                // max retry is defined, and max retry is reached, do not add the payload to buffer
                if (!(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_3__.isNullOrUndefined)(_maxRetryCnt)) {
                    if (payload.cnt > _maxRetryCnt) {
                        // TODO: add log here on dropping payloads
                        return;
                    }
                }
                _buffer[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_PUSH /* @min:%2epush */](payload);
                return;
            };
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_COUNT /* @min:%2ecount */] = function () {
                return _buffer[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_LENGTH /* @min:%2elength */];
            };
            _self.size = function () {
                var size = _buffer[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_LENGTH /* @min:%2elength */];
                for (var lp = 0; lp < _buffer[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_LENGTH /* @min:%2elength */]; lp++) {
                    size += (_buffer[lp].item)[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_LENGTH /* @min:%2elength */];
                }
                if (!config[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_EMIT_LINE_DELIMITED_0 /* @min:%2eemitLineDelimitedJson */]) {
                    size += 2;
                }
                return size;
            };
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_CLEAR /* @min:%2eclear */] = function () {
                _buffer = [];
                _bufferFullMessageSent = false;
            };
            _self.getItems = function () {
                return _buffer.slice(0);
            };
            _self.batchPayloads = function (payloads) {
                if (payloads && payloads[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_LENGTH /* @min:%2elength */] > 0) {
                    var payloadStr_1 = [];
                    (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_3__.arrForEach)(payloads, function (payload) {
                        payloadStr_1[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_PUSH /* @min:%2epush */](payload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_ITEM /* @min:%2eitem */]);
                    });
                    var batch = config[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_EMIT_LINE_DELIMITED_0 /* @min:%2eemitLineDelimitedJson */] ?
                        payloadStr_1.join("\n") :
                        "[" + payloadStr_1.join(",") + "]";
                    return batch;
                }
                return null;
            };
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_CREATE_NEW /* @min:%2ecreateNew */] = function (newLogger, newConfig, canUseSessionStorage) {
                var items = _buffer.slice(0);
                newLogger = newLogger || logger;
                newConfig = newConfig || {};
                var newBuffer = !!canUseSessionStorage ? new SessionStorageSendBuffer(newLogger, newConfig) : new ArraySendBuffer(newLogger, newConfig);
                (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_3__.arrForEach)(items, function (payload) {
                    newBuffer[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_ENQUEUE /* @min:%2eenqueue */](payload);
                });
                return newBuffer;
            };
        });
    }
// Removed Stub for BaseSendBuffer.prototype.enqueue.
// Removed Stub for BaseSendBuffer.prototype.count.
// Removed Stub for BaseSendBuffer.prototype.size.
// Removed Stub for BaseSendBuffer.prototype.clear.
// Removed Stub for BaseSendBuffer.prototype.getItems.
// Removed Stub for BaseSendBuffer.prototype.batchPayloads.
// Removed Stub for BaseSendBuffer.prototype.createNew.
    // This is a workaround for an IE bug when using dynamicProto() with classes that don't have any
    // non-dynamic functions or static properties/functions when using uglify-js to minify the resulting code.
    BaseSendBuffer.__ieDyn=1;

    return BaseSendBuffer;
}());
/*
 * An array based send buffer.
 */
var ArraySendBuffer = /** @class */ (function (_super) {
    (0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_4__.__extendsFn)(ArraySendBuffer, _super);
    function ArraySendBuffer(logger, config) {
        var _this = _super.call(this, logger, config) || this;
        (0,_microsoft_dynamicproto_js__WEBPACK_IMPORTED_MODULE_1__["default"])(ArraySendBuffer, _this, function (_self, _base) {
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_MARK_AS_SENT /* @min:%2emarkAsSent */] = function (payload) {
                _base[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_CLEAR /* @min:%2eclear */]();
            };
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_CLEAR_SENT /* @min:%2eclearSent */] = function (payload) {
                // not supported
            };
        });
        return _this;
    }
// Removed Stub for ArraySendBuffer.prototype.markAsSent.
// Removed Stub for ArraySendBuffer.prototype.clearSent.
    // This is a workaround for an IE bug when using dynamicProto() with classes that don't have any
    // non-dynamic functions or static properties/functions when using uglify-js to minify the resulting code.
    ArraySendBuffer.__ieDyn=1;

    return ArraySendBuffer;
}(BaseSendBuffer));

var PREVIOUS_KEYS = ["AI_buffer", "AI_sentBuffer"];
/*
 * Session storage buffer holds a copy of all unsent items in the browser session storage.
 */
var SessionStorageSendBuffer = /** @class */ (function (_super) {
    (0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_4__.__extendsFn)(SessionStorageSendBuffer, _super);
    function SessionStorageSendBuffer(logger, config) {
        var _this = _super.call(this, logger, config) || this;
        var _bufferFullMessageSent = false;
        //Note: should not use config.namePrefix directly, because it will always refers to the latest namePrefix
        var _namePrefix = config === null || config === void 0 ? void 0 : config.namePrefix;
        // TODO: add remove buffer override as well
        var _b = config[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_BUFFER_OVERRIDE /* @min:%2ebufferOverride */] || { getItem: _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_5__.utlGetSessionStorage, setItem: _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_5__.utlSetSessionStorage }, getItem = _b.getItem, setItem = _b.setItem;
        var _maxRetryCnt = config.maxRetryCnt;
        (0,_microsoft_dynamicproto_js__WEBPACK_IMPORTED_MODULE_1__["default"])(SessionStorageSendBuffer, _this, function (_self, _base) {
            var bufferItems = _getBuffer(SessionStorageSendBuffer[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN__BUFFER__KEY /* @min:%2eBUFFER_KEY */]);
            var itemsInSentBuffer = _getBuffer(SessionStorageSendBuffer[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN__SENT__BUFFER__KEY /* @min:%2eSENT_BUFFER_KEY */]);
            var previousItems = _getPreviousEvents();
            var notDeliveredItems = itemsInSentBuffer[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_CONCAT /* @min:%2econcat */](previousItems);
            var buffer = _self._set(bufferItems[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_CONCAT /* @min:%2econcat */](notDeliveredItems));
            // If the buffer has too many items, drop items from the end.
            if (buffer[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_LENGTH /* @min:%2elength */] > SessionStorageSendBuffer[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN__MAX__BUFFER__SIZE /* @min:%2eMAX_BUFFER_SIZE */]) {
                buffer[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_LENGTH /* @min:%2elength */] = SessionStorageSendBuffer[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN__MAX__BUFFER__SIZE /* @min:%2eMAX_BUFFER_SIZE */];
            }
            _setBuffer(SessionStorageSendBuffer[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN__SENT__BUFFER__KEY /* @min:%2eSENT_BUFFER_KEY */], []);
            _setBuffer(SessionStorageSendBuffer[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN__BUFFER__KEY /* @min:%2eBUFFER_KEY */], buffer);
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_ENQUEUE /* @min:%2eenqueue */] = function (payload) {
                if (_self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_COUNT /* @min:%2ecount */]() >= SessionStorageSendBuffer[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN__MAX__BUFFER__SIZE /* @min:%2eMAX_BUFFER_SIZE */]) {
                    // sent internal log only once per page view
                    if (!_bufferFullMessageSent) {
                        (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__._throwInternal)(logger, 2 /* eLoggingSeverity.WARNING */, 67 /* _eInternalMessageId.SessionStorageBufferFull */, "Maximum buffer size reached: " + _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_COUNT /* @min:%2ecount */](), true);
                        _bufferFullMessageSent = true;
                    }
                    return;
                }
                payload.cnt = payload.cnt || 0;
                // max retry is defined, and max retry is reached, do not add the payload to buffer
                if (!(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_3__.isNullOrUndefined)(_maxRetryCnt)) {
                    if (payload.cnt > _maxRetryCnt) {
                        // TODO: add log here on dropping payloads
                        return;
                    }
                }
                _base[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_ENQUEUE /* @min:%2eenqueue */](payload);
                _setBuffer(SessionStorageSendBuffer.BUFFER_KEY, _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN__GET /* @min:%2e_get */]());
            };
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_CLEAR /* @min:%2eclear */] = function () {
                _base[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_CLEAR /* @min:%2eclear */]();
                _setBuffer(SessionStorageSendBuffer.BUFFER_KEY, _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN__GET /* @min:%2e_get */]());
                _setBuffer(SessionStorageSendBuffer[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN__SENT__BUFFER__KEY /* @min:%2eSENT_BUFFER_KEY */], []);
                _bufferFullMessageSent = false;
            };
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_MARK_AS_SENT /* @min:%2emarkAsSent */] = function (payload) {
                _setBuffer(SessionStorageSendBuffer[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN__BUFFER__KEY /* @min:%2eBUFFER_KEY */], _self._set(_removePayloadsFromBuffer(payload, _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN__GET /* @min:%2e_get */]())));
                var sentElements = _getBuffer(SessionStorageSendBuffer[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN__SENT__BUFFER__KEY /* @min:%2eSENT_BUFFER_KEY */]);
                if (sentElements instanceof Array && payload instanceof Array) {
                    sentElements = sentElements[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_CONCAT /* @min:%2econcat */](payload);
                    if (sentElements[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_LENGTH /* @min:%2elength */] > SessionStorageSendBuffer[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN__MAX__BUFFER__SIZE /* @min:%2eMAX_BUFFER_SIZE */]) {
                        // We send telemetry normally. If the SENT_BUFFER is too big we don't add new elements
                        // until we receive a response from the backend and the buffer has free space again (see clearSent method)
                        (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__._throwInternal)(logger, 1 /* eLoggingSeverity.CRITICAL */, 67 /* _eInternalMessageId.SessionStorageBufferFull */, "Sent buffer reached its maximum size: " + sentElements[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_LENGTH /* @min:%2elength */], true);
                        sentElements[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_LENGTH /* @min:%2elength */] = SessionStorageSendBuffer[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN__MAX__BUFFER__SIZE /* @min:%2eMAX_BUFFER_SIZE */];
                    }
                    _setBuffer(SessionStorageSendBuffer[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN__SENT__BUFFER__KEY /* @min:%2eSENT_BUFFER_KEY */], sentElements);
                }
            };
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_CLEAR_SENT /* @min:%2eclearSent */] = function (payload) {
                var sentElements = _getBuffer(SessionStorageSendBuffer[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN__SENT__BUFFER__KEY /* @min:%2eSENT_BUFFER_KEY */]);
                sentElements = _removePayloadsFromBuffer(payload, sentElements);
                _setBuffer(SessionStorageSendBuffer[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN__SENT__BUFFER__KEY /* @min:%2eSENT_BUFFER_KEY */], sentElements);
            };
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_CREATE_NEW /* @min:%2ecreateNew */] = function (newLogger, newConfig, canUseSessionStorage) {
                canUseSessionStorage = !!canUseSessionStorage;
                var unsentItems = _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN__GET /* @min:%2e_get */]().slice(0);
                var sentItems = _getBuffer(SessionStorageSendBuffer[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN__SENT__BUFFER__KEY /* @min:%2eSENT_BUFFER_KEY */]).slice(0);
                newLogger = newLogger || logger;
                newConfig = newConfig || {};
                // to make sure that we do not send duplicated payloads when it is switched back to previous one
                _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_CLEAR /* @min:%2eclear */]();
                var newBuffer = canUseSessionStorage ? new SessionStorageSendBuffer(newLogger, newConfig) : new ArraySendBuffer(newLogger, newConfig);
                (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_3__.arrForEach)(unsentItems, function (payload) {
                    newBuffer[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_ENQUEUE /* @min:%2eenqueue */](payload);
                });
                if (canUseSessionStorage) {
                    // arr buffer will clear all payloads if markAsSent() is called
                    newBuffer[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_MARK_AS_SENT /* @min:%2emarkAsSent */](sentItems);
                }
                return newBuffer;
            };
            function _removePayloadsFromBuffer(payloads, buffer) {
                var remaining = [];
                var payloadStr = [];
                (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_3__.arrForEach)(payloads, function (payload) {
                    payloadStr[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_PUSH /* @min:%2epush */](payload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_ITEM /* @min:%2eitem */]);
                });
                (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_3__.arrForEach)(buffer, function (value) {
                    if (!(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_3__.isFunction)(value) && (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_3__.arrIndexOf)(payloadStr, value[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_ITEM /* @min:%2eitem */]) === -1) {
                        remaining[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_PUSH /* @min:%2epush */](value);
                    }
                });
                return remaining;
            }
            function _getBuffer(key) {
                var prefixedKey = key;
                prefixedKey = _namePrefix ? _namePrefix + "_" + prefixedKey : prefixedKey;
                return _getBufferBase(prefixedKey);
            }
            function _getBufferBase(key) {
                try {
                    var bufferJson = getItem(logger, key);
                    if (bufferJson) {
                        var buffer_1 = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_6__.getJSON)().parse(bufferJson);
                        if ((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_3__.isString)(buffer_1)) {
                            // When using some version prototype.js the stringify / parse cycle does not decode array's correctly
                            buffer_1 = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_6__.getJSON)().parse(buffer_1);
                        }
                        if (buffer_1 && (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_3__.isArray)(buffer_1)) {
                            return buffer_1;
                        }
                    }
                }
                catch (e) {
                    (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__._throwInternal)(logger, 1 /* eLoggingSeverity.CRITICAL */, 42 /* _eInternalMessageId.FailedToRestoreStorageBuffer */, " storage key: " + key + ", " + (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_7__.getExceptionName)(e), { exception: (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_3__.dumpObj)(e) });
                }
                return [];
            }
            function _setBuffer(key, buffer) {
                var prefixedKey = key;
                try {
                    prefixedKey = _namePrefix ? _namePrefix + "_" + prefixedKey : prefixedKey;
                    var bufferJson = JSON[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_STRINGIFY /* @min:%2estringify */](buffer);
                    setItem(logger, prefixedKey, bufferJson);
                }
                catch (e) {
                    // if there was an error, clear the buffer
                    // telemetry is stored in the _buffer array so we won't loose any items
                    setItem(logger, prefixedKey, JSON[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_STRINGIFY /* @min:%2estringify */]([]));
                    (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__._throwInternal)(logger, 2 /* eLoggingSeverity.WARNING */, 41 /* _eInternalMessageId.FailedToSetStorageBuffer */, " storage key: " + prefixedKey + ", " + (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_7__.getExceptionName)(e) + ". Buffer cleared", { exception: (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_3__.dumpObj)(e) });
                }
            }
            // this removes buffer with prefix+key
            function _getPreviousEvents() {
                var items = [];
                try {
                    (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_3__.arrForEach)(PREVIOUS_KEYS, function (key) {
                        var events = _getItemsFromPreviousKey(key);
                        items = items[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_CONCAT /* @min:%2econcat */](events);
                        // to make sure that we also transfer items from old prefixed + key buffer
                        if (_namePrefix) {
                            var prefixedKey = _namePrefix + "_" + key;
                            var prefixEvents = _getItemsFromPreviousKey(prefixedKey);
                            items = items[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_CONCAT /* @min:%2econcat */](prefixEvents);
                        }
                    });
                    return items;
                }
                catch (e) {
                    (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__._throwInternal)(logger, 2 /* eLoggingSeverity.WARNING */, 41 /* _eInternalMessageId.FailedToSetStorageBuffer */, "Transfer events from previous buffers: " + (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_7__.getExceptionName)(e) + ". previous Buffer items can not be removed", { exception: (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_3__.dumpObj)(e) });
                }
                return [];
            }
            // transform string[] to IInternalStorageItem[]
            function _getItemsFromPreviousKey(key) {
                try {
                    var items = _getBufferBase(key);
                    var transFormedItems_1 = [];
                    (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_3__.arrForEach)(items, function (item) {
                        var internalItem = {
                            item: item,
                            cnt: 0 // previous events will be default to 0 count
                        };
                        transFormedItems_1[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_PUSH /* @min:%2epush */](internalItem);
                    });
                    // remove the session storage if we can add events back
                    (0,_microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_5__.utlRemoveSessionStorage)(logger, key);
                    return transFormedItems_1;
                }
                catch (e) {
                    // eslint-disable-next-line no-empty
                }
                return [];
            }
        });
        return _this;
    }
// Removed Stub for SessionStorageSendBuffer.prototype.enqueue.
// Removed Stub for SessionStorageSendBuffer.prototype.clear.
// Removed Stub for SessionStorageSendBuffer.prototype.markAsSent.
// Removed Stub for SessionStorageSendBuffer.prototype.clearSent.
// Removed Stub for SessionStorageSendBuffer.prototype.createNew.
    var _a;
    _a = SessionStorageSendBuffer;
    SessionStorageSendBuffer.VERSION = "_1";
    SessionStorageSendBuffer.BUFFER_KEY = "AI_buffer" + _a.VERSION;
    SessionStorageSendBuffer.SENT_BUFFER_KEY = "AI_sentBuffer" + _a.VERSION;
    // Maximum number of payloads stored in the buffer. If the buffer is full, new elements will be dropped.
    SessionStorageSendBuffer.MAX_BUFFER_SIZE = 2000;
    return SessionStorageSendBuffer;
}(BaseSendBuffer));

//# sourceMappingURL=SendBuffer.js.map

/***/ }),
/* 126 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Sample": () => (/* binding */ Sample)
/* harmony export */ });
/* harmony import */ var _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(103);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(50);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(121);
/* harmony import */ var _SamplingScoreGenerators_SamplingScoreGenerator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(127);
/*
 * Application Insights JavaScript SDK - Channel, 3.3.0
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */






var Sample = /** @class */ (function () {
    function Sample(sampleRate, logger) {
        // We're using 32 bit math, hence max value is (2^31 - 1)
        this.INT_MAX_VALUE = 2147483647;
        var _logger = logger || (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.safeGetLogger)(null);
        if (sampleRate > 100 || sampleRate < 0) {
            _logger.throwInternal(2 /* eLoggingSeverity.WARNING */, 58 /* _eInternalMessageId.SampleRateOutOfRange */, "Sampling rate is out of range (0..100). Sampling will be disabled, you may be sending too much data which may affect your AI service level.", { samplingRate: sampleRate }, true);
            sampleRate = 100;
        }
        this[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_SAMPLE_RATE /* @min:%2esampleRate */] = sampleRate;
        this.samplingScoreGenerator = new _SamplingScoreGenerators_SamplingScoreGenerator__WEBPACK_IMPORTED_MODULE_2__.SamplingScoreGenerator();
    }
    /**
    * Determines if an envelope is sampled in (i.e. will be sent) or not (i.e. will be dropped).
    */
    Sample.prototype.isSampledIn = function (envelope) {
        var samplingPercentage = this[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_SAMPLE_RATE /* @min:%2esampleRate */]; // 0 - 100
        var isSampledIn = false;
        if (samplingPercentage === null || samplingPercentage === undefined || samplingPercentage >= 100) {
            return true;
        }
        else if (envelope.baseType === _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_3__.Metric[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_DATA_TYPE /* @min:%2edataType */]) {
            // exclude MetricData telemetry from sampling
            return true;
        }
        isSampledIn = this.samplingScoreGenerator[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_GET_SAMPLING_SCORE /* @min:%2egetSamplingScore */](envelope) < samplingPercentage;
        return isSampledIn;
    };
    return Sample;
}());

//# sourceMappingURL=Sample.js.map

/***/ }),
/* 127 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SamplingScoreGenerator": () => (/* binding */ SamplingScoreGenerator)
/* harmony export */ });
/* harmony import */ var _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(113);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(121);
/* harmony import */ var _HashCodeScoreGenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(128);
/*
 * Application Insights JavaScript SDK - Channel, 3.3.0
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */





var SamplingScoreGenerator = /** @class */ (function () {
    function SamplingScoreGenerator() {
        var _self = this;
        var hashCodeGenerator = new _HashCodeScoreGenerator__WEBPACK_IMPORTED_MODULE_0__.HashCodeScoreGenerator();
        var keys = new _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_1__.ContextTagKeys();
        _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_GET_SAMPLING_SCORE /* @min:%2egetSamplingScore */] = function (item) {
            var score = 0;
            if (item[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_TAGS /* @min:%2etags */] && item[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_TAGS /* @min:%2etags */][keys.userId]) { // search in tags first, then ext
                score = hashCodeGenerator.getHashCodeScore(item[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_TAGS /* @min:%2etags */][keys.userId]);
            }
            else if (item.ext && item.ext.user && item.ext.user.id) {
                score = hashCodeGenerator[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_GET_HASH_CODE_SCORE /* @min:%2egetHashCodeScore */](item.ext.user.id);
            }
            else if (item[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_TAGS /* @min:%2etags */] && item[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_TAGS /* @min:%2etags */][keys.operationId]) { // search in tags first, then ext
                score = hashCodeGenerator.getHashCodeScore(item[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_TAGS /* @min:%2etags */][keys.operationId]);
            }
            else if (item.ext && item.ext.telemetryTrace && item.ext.telemetryTrace[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_TRACE_ID /* @min:%2etraceID */]) {
                score = hashCodeGenerator.getHashCodeScore(item.ext.telemetryTrace[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_TRACE_ID /* @min:%2etraceID */]);
            }
            else {
                // tslint:disable-next-line:insecure-random
                score = (Math.random() * 100);
            }
            return score;
        };
    }
    return SamplingScoreGenerator;
}());

//# sourceMappingURL=SamplingScoreGenerator.js.map

/***/ }),
/* 128 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "HashCodeScoreGenerator": () => (/* binding */ HashCodeScoreGenerator)
/* harmony export */ });
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(121);
/*
 * Application Insights JavaScript SDK - Channel, 3.3.0
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */



// (Magic number) DJB algorithm can't work on shorter strings (results in poor distribution
var MIN_INPUT_LENGTH = 8;
var HashCodeScoreGenerator = /** @class */ (function () {
    function HashCodeScoreGenerator() {
    }
    HashCodeScoreGenerator.prototype.getHashCodeScore = function (key) {
        var score = this.getHashCode(key) / HashCodeScoreGenerator.INT_MAX_VALUE;
        return score * 100;
    };
    HashCodeScoreGenerator.prototype.getHashCode = function (input) {
        if (input === "") {
            return 0;
        }
        while (input[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_LENGTH /* @min:%2elength */] < MIN_INPUT_LENGTH) {
            input = input[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_CONCAT /* @min:%2econcat */](input);
        }
        // 5381 is a magic number: http://stackoverflow.com/questions/10696223/reason-for-5381-number-in-djb-hash-function
        var hash = 5381;
        for (var i = 0; i < input[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_LENGTH /* @min:%2elength */]; ++i) {
            hash = ((hash << 5) + hash) + input.charCodeAt(i);
            // 'hash' is of number type which means 53 bit integer (http://www.ecma-international.org/ecma-262/6.0/#sec-ecmascript-language-types-number-type)
            // 'hash & hash' will keep it 32 bit integer - just to make it clearer what the result is.
            hash = hash & hash;
        }
        return Math.abs(hash);
    };
    // We're using 32 bit math, hence max value is (2^31 - 1)
    HashCodeScoreGenerator.INT_MAX_VALUE = 2147483647;
    return HashCodeScoreGenerator;
}());

//# sourceMappingURL=HashCodeScoreGenerator.js.map

/***/ }),
/* 129 */
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MeasurementEntries = exports.DimensionEntries = exports.ErrorType = exports.ErrorCodes = exports.EventName = void 0;
var EventName;
(function (EventName) {
    EventName["ERROR"] = "error";
    EventName["INFO"] = "info";
    EventName["OPERATION_START"] = "opStart";
    EventName["OPERATION_END"] = "opEnd";
    EventName["OPERATION_STEP"] = "opStep";
})(EventName || (exports.EventName = EventName = {}));
var ErrorCodes;
(function (ErrorCodes) {
    ErrorCodes.NO_ERROR = 0;
    ErrorCodes.GENERAL_ERROR = 1;
})(ErrorCodes || (exports.ErrorCodes = ErrorCodes = {}));
var ErrorType;
(function (ErrorType) {
    ErrorType["USER_ERROR"] = "userError";
    ErrorType["SYSTEM_ERROR"] = "systemError";
})(ErrorType || (exports.ErrorType = ErrorType = {}));
exports.DimensionEntries = [
    "operationId",
    "operationName",
    "errorCode",
    "errorType",
    "message",
    "stack",
    "stepName",
];
exports.MeasurementEntries = [
    "duration",
];
//# sourceMappingURL=event.js.map

/***/ }),
/* 130 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Output = void 0;
const vscode = __webpack_require__(1);
class Output {
    constructor() {
    }
    static getInstance() {
        if (!this.INSTANCE) {
            this.INSTANCE = vscode.window.createOutputChannel(`Telemetry Wrapper (${Output.extensionId})`);
        }
        return this.INSTANCE;
    }
    static setExtensionId(extensionId) {
        Output.extensionId = extensionId;
    }
}
exports.Output = Output;
//# sourceMappingURL=output.js.map

/***/ }),
/* 131 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LombokCodeActionProvider = exports.lombokAction = void 0;
const vscode_1 = __webpack_require__(1);
const commands_1 = __webpack_require__(132);
const ProtocolConverter = __webpack_require__(133);
const CodeConverter = __webpack_require__(183);
const vscode_extension_telemetry_wrapper_1 = __webpack_require__(2);
const protoConverter = ProtocolConverter.createConverter(undefined, undefined);
const codeConverter = CodeConverter.createConverter();
const supportedLombokAnnotations = ["Data", "NoArgsConstructor", "AllArgsConstructor", "Getter", "Setter", "ToString", "EqualsAndHashCode"];
const annotationsDescriptions = [
    "Bundles the features of @ToString, @EqualsAndHashCode, @Getter, @Setter and @RequiredArgsConstructor together",
    "Generates a constructor with no parameters.",
    "Generates a constructor with 1 parameter for each field in your class.",
    "Generates the default getter automatically.",
    "Generates the default setter automatically.",
    "Generates a toString for you.",
    "Generates hashCode and equals implementations from the fields of your object."
];
const annotationLinks = [
    "https://projectlombok.org/features/Data",
    "https://projectlombok.org/features/constructor",
    "https://projectlombok.org/features/constructor",
    "https://projectlombok.org/features/GetterSetter",
    "https://projectlombok.org/features/GetterSetter",
    "https://projectlombok.org/features/ToString",
    "https://projectlombok.org/features/EqualsAndHashCode"
];
function applyWorkspaceEdit(workspaceEdit) {
    return __awaiter(this, void 0, void 0, function* () {
        const edit = protoConverter.asWorkspaceEdit(workspaceEdit);
        if (edit) {
            yield vscode_1.workspace.applyEdit(edit);
        }
    });
}
function revealWorkspaceEdit(workspaceEdit) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        const codeWorkspaceEdit = protoConverter.asWorkspaceEdit(workspaceEdit);
        if (!codeWorkspaceEdit) {
            return;
        }
        for (const entry of codeWorkspaceEdit.entries()) {
            yield vscode_1.workspace.openTextDocument(entry[0]);
            if (entry[1].length > 0) {
                // reveal first available change of the workspace edit
                (_a = vscode_1.window.activeTextEditor) === null || _a === void 0 ? void 0 : _a.revealRange(entry[1][0].range, vscode_1.TextEditorRevealType.InCenter);
                break;
            }
        }
    });
}
function lombokAction(params, annotations) {
    return __awaiter(this, void 0, void 0, function* () {
        // TODO: remove the diagnostics here because the server side will throw:
        // java.lang.IllegalStateException: Expected BEGIN_OBJECT but was STRING path $.context.diagnostics[0].code
        // when parsing the params from json string to object. What we need is only the range and textDocument.
        params.context.diagnostics = [];
        const annotationResponse = yield (0, commands_1.executeJavaLanguageServerCommand)(commands_1.Commands.JAVA_CODEACTION_LOMBOK_ANNOTATIONS, JSON.stringify(params));
        if (!annotationResponse) {
            return;
        }
        let annotationsAfter = [];
        if (annotations.length) {
            annotationsAfter = annotationResponse.annotations.filter((item) => {
                return !annotations.includes(item);
            });
        }
        else {
            const annotationItems = supportedLombokAnnotations.map(name => {
                return {
                    label: `@${name}`,
                    description: annotationsDescriptions[supportedLombokAnnotations.indexOf(name)],
                    buttons: [{
                            iconPath: new vscode_1.ThemeIcon("link-external"),
                            tooltip: "Reference"
                        }]
                };
            });
            const itemsToDelombok = annotationItems.filter((item) => {
                return annotationResponse.annotations.indexOf(item.label.split('@')[1]) >= 0;
            });
            const itemsToLombok = annotationItems.filter((item) => {
                return annotationResponse.annotations.indexOf(item.label.split('@')[1]) < 0;
            });
            const showItems = [];
            showItems.push({
                label: "Unselect to Delombok",
                kind: vscode_1.QuickPickItemKind.Separator
            });
            showItems.push(...itemsToDelombok);
            showItems.push({
                label: "Select to Lombok",
                kind: vscode_1.QuickPickItemKind.Separator
            });
            showItems.push(...itemsToLombok);
            let selectedItems = [];
            const disposables = [];
            try {
                selectedItems = yield new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                    const pickBox = vscode_1.window.createQuickPick();
                    pickBox.items = showItems;
                    pickBox.canSelectMany = true;
                    pickBox.ignoreFocusOut = true;
                    pickBox.selectedItems = itemsToDelombok;
                    pickBox.placeholder = 'Add or remove Lombok annotations in class';
                    disposables.push(pickBox.onDidTriggerItemButton(e => {
                        vscode_1.env.openExternal(vscode_1.Uri.parse(annotationLinks[supportedLombokAnnotations.indexOf(e.item.label.split('@')[1])]));
                    }), pickBox.onDidAccept(() => {
                        resolve(pickBox.selectedItems);
                    }), pickBox.onDidHide(() => {
                        reject();
                    }));
                    disposables.push(pickBox);
                    pickBox.show();
                }));
            }
            catch (err) {
                // return when the quickpick is cancelled.
                (0, vscode_extension_telemetry_wrapper_1.sendInfo)("", {
                    operationName: "cancelLombokAction",
                });
                return;
            }
            finally {
                disposables.forEach(d => d.dispose());
            }
            annotationsAfter = selectedItems.map(item => {
                return item.label.split('@')[1];
            });
        }
        const lombokParams = {
            context: params,
            annotationsBefore: annotationResponse.annotations,
            annotationsAfter
        };
        const lombok = [];
        const delombok = [];
        for (const annotation of lombokParams.annotationsBefore) {
            if (!lombokParams.annotationsAfter.includes(annotation)) {
                delombok.push(annotation);
            }
        }
        for (const annotation of lombokParams.annotationsAfter) {
            if (!lombokParams.annotationsBefore.includes(annotation)) {
                lombok.push(annotation);
            }
        }
        if (!lombok.length && !delombok.length) {
            (0, vscode_extension_telemetry_wrapper_1.sendInfo)("", {
                operationName: "cancelLombokAction",
            });
            return;
        }
        const startAt = Date.now();
        let workspaceEdit;
        try {
            workspaceEdit = (yield (0, commands_1.executeJavaLanguageServerCommand)(commands_1.Commands.JAVA_CODEACTION_LOMBOK, JSON.stringify(lombokParams)));
        }
        finally {
            (0, vscode_extension_telemetry_wrapper_1.sendInfo)("", {
                operationName: "applyLombokAction",
                lombok: JSON.stringify(lombok),
                delombok: JSON.stringify(delombok),
                duration: Date.now() - startAt,
            });
        }
        yield applyWorkspaceEdit(workspaceEdit);
        yield revealWorkspaceEdit(workspaceEdit);
        // organize imports silently to fix missing annotation imports
        yield vscode_1.commands.executeCommand(commands_1.Commands.ORGANIZE_IMPORTS_SILENTLY, params.textDocument.uri.toString());
    });
}
exports.lombokAction = lombokAction;
function getSelectedAnnotations(text) {
    return supportedLombokAnnotations.filter((item) => text.includes(`@${item}`));
}
class LombokCodeActionProvider {
    provideCodeActions(document, range, context, _token) {
        const params = {
            textDocument: codeConverter.asTextDocumentIdentifier(document),
            range: codeConverter.asRange(range),
            context: codeConverter.asCodeActionContext(context)
        };
        const selectText = document.getText(range);
        let codeActionTitle = "Lombok...";
        let selectedAnnotations = [];
        if (selectText !== "") {
            selectedAnnotations = getSelectedAnnotations(selectText);
            if (selectedAnnotations.length === 1) {
                codeActionTitle = `Delombok '${selectedAnnotations[0]}'`;
            }
            else if (selectedAnnotations.length > 1) {
                codeActionTitle = `Delombok ${selectedAnnotations.length} annotations`;
            }
        }
        return [
            {
                title: codeActionTitle,
                kind: vscode_1.CodeActionKind.Refactor,
                command: {
                    title: codeActionTitle,
                    command: commands_1.Commands.CODEACTION_LOMBOK,
                    arguments: [params, selectedAnnotations]
                },
            }
        ];
    }
}
exports.LombokCodeActionProvider = LombokCodeActionProvider;


/***/ }),
/* 132 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.executeJavaLanguageServerCommand = exports.Commands = void 0;
const vscode = __webpack_require__(1);
// tslint:disable-next-line: no-namespace
var Commands;
(function (Commands) {
    Commands.JAVA_EXECUTE_WORKSPACE_COMMAND = "java.execute.workspaceCommand";
    Commands.CODEACTION_LOMBOK = "codeAction.lombok";
    Commands.JAVA_CODEACTION_LOMBOK_ANNOTATIONS = "java.codeAction.lombok.getAnnotations";
    Commands.JAVA_CODEACTION_LOMBOK = "java.codeAction.lombok";
    Commands.GET_ALL_JAVA_PROJECTS = 'java.project.getAll';
    Commands.ORGANIZE_IMPORTS_SILENTLY = "java.edit.organizeImports";
})(Commands = exports.Commands || (exports.Commands = {}));
function executeJavaLanguageServerCommand(...rest) {
    return __awaiter(this, void 0, void 0, function* () {
        return vscode.commands.executeCommand(Commands.JAVA_EXECUTE_WORKSPACE_COMMAND, ...rest);
    });
}
exports.executeJavaLanguageServerCommand = executeJavaLanguageServerCommand;


/***/ }),
/* 133 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
/// <reference path="../../typings/vscode-proposed.d.ts" />
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createConverter = void 0;
const code = __webpack_require__(1);
const ls = __webpack_require__(134);
const Is = __webpack_require__(176);
const protocolCompletionItem_1 = __webpack_require__(177);
const protocolCodeLens_1 = __webpack_require__(178);
const protocolDocumentLink_1 = __webpack_require__(179);
const protocolCodeAction_1 = __webpack_require__(180);
const protocolDiagnostic_1 = __webpack_require__(181);
const protocolCallHierarchyItem_1 = __webpack_require__(182);
const vscode_languageserver_protocol_1 = __webpack_require__(134);
var CodeBlock;
(function (CodeBlock) {
    function is(value) {
        let candidate = value;
        return candidate && Is.string(candidate.language) && Is.string(candidate.value);
    }
    CodeBlock.is = is;
})(CodeBlock || (CodeBlock = {}));
function createConverter(uriConverter, trustMarkdown) {
    const nullConverter = (value) => code.Uri.parse(value);
    const _uriConverter = uriConverter || nullConverter;
    function asUri(value) {
        return _uriConverter(value);
    }
    function asDiagnostics(diagnostics) {
        return diagnostics.map(asDiagnostic);
    }
    function asDiagnostic(diagnostic) {
        let result = new protocolDiagnostic_1.ProtocolDiagnostic(asRange(diagnostic.range), diagnostic.message, asDiagnosticSeverity(diagnostic.severity), diagnostic.data);
        if (diagnostic.code !== undefined) {
            if (ls.CodeDescription.is(diagnostic.codeDescription)) {
                result.code = {
                    value: diagnostic.code,
                    target: asUri(diagnostic.codeDescription.href)
                };
            }
            else if (protocolDiagnostic_1.DiagnosticCode.is(diagnostic.code)) {
                result.hasDiagnosticCode = true;
                result.code = {
                    value: diagnostic.code.value,
                    target: asUri(diagnostic.code.target)
                };
            }
            else {
                result.code = diagnostic.code;
            }
        }
        if (diagnostic.source) {
            result.source = diagnostic.source;
        }
        if (diagnostic.relatedInformation) {
            result.relatedInformation = asRelatedInformation(diagnostic.relatedInformation);
        }
        if (Array.isArray(diagnostic.tags)) {
            result.tags = asDiagnosticTags(diagnostic.tags);
        }
        return result;
    }
    function asRelatedInformation(relatedInformation) {
        return relatedInformation.map(asDiagnosticRelatedInformation);
    }
    function asDiagnosticRelatedInformation(information) {
        return new code.DiagnosticRelatedInformation(asLocation(information.location), information.message);
    }
    function asDiagnosticTags(tags) {
        if (!tags) {
            return undefined;
        }
        let result = [];
        for (let tag of tags) {
            let converted = asDiagnosticTag(tag);
            if (converted !== undefined) {
                result.push(converted);
            }
        }
        return result.length > 0 ? result : undefined;
    }
    function asDiagnosticTag(tag) {
        switch (tag) {
            case ls.DiagnosticTag.Unnecessary:
                return code.DiagnosticTag.Unnecessary;
            case ls.DiagnosticTag.Deprecated:
                return code.DiagnosticTag.Deprecated;
            default:
                return undefined;
        }
    }
    function asPosition(value) {
        if (!value) {
            return undefined;
        }
        return new code.Position(value.line, value.character);
    }
    function asRange(value) {
        if (!value) {
            return undefined;
        }
        return new code.Range(asPosition(value.start), asPosition(value.end));
    }
    function asRanges(value) {
        return value.map(value => asRange(value));
    }
    function asDiagnosticSeverity(value) {
        if (value === undefined || value === null) {
            return code.DiagnosticSeverity.Error;
        }
        switch (value) {
            case ls.DiagnosticSeverity.Error:
                return code.DiagnosticSeverity.Error;
            case ls.DiagnosticSeverity.Warning:
                return code.DiagnosticSeverity.Warning;
            case ls.DiagnosticSeverity.Information:
                return code.DiagnosticSeverity.Information;
            case ls.DiagnosticSeverity.Hint:
                return code.DiagnosticSeverity.Hint;
        }
        return code.DiagnosticSeverity.Error;
    }
    function asHoverContent(value) {
        if (Is.string(value)) {
            return asMarkdownString(value);
        }
        else if (CodeBlock.is(value)) {
            let result = asMarkdownString();
            return result.appendCodeblock(value.value, value.language);
        }
        else if (Array.isArray(value)) {
            let result = [];
            for (let element of value) {
                let item = asMarkdownString();
                if (CodeBlock.is(element)) {
                    item.appendCodeblock(element.value, element.language);
                }
                else {
                    item.appendMarkdown(element);
                }
                result.push(item);
            }
            return result;
        }
        else {
            let result;
            switch (value.kind) {
                case ls.MarkupKind.Markdown:
                    return asMarkdownString(value.value);
                case ls.MarkupKind.PlainText:
                    result = asMarkdownString();
                    result.appendText(value.value);
                    return result;
                default:
                    result = asMarkdownString();
                    result.appendText(`Unsupported Markup content received. Kind is: ${value.kind}`);
                    return result;
            }
        }
    }
    function asDocumentation(value) {
        if (Is.string(value)) {
            return value;
        }
        else {
            switch (value.kind) {
                case ls.MarkupKind.Markdown:
                    return asMarkdownString(value.value);
                case ls.MarkupKind.PlainText:
                    return value.value;
                default:
                    return `Unsupported Markup content received. Kind is: ${value.kind}`;
            }
        }
    }
    function asMarkdownString(value) {
        const result = new code.MarkdownString(value);
        if (trustMarkdown === true) {
            result.isTrusted = trustMarkdown;
        }
        return result;
    }
    function asHover(hover) {
        if (!hover) {
            return undefined;
        }
        return new code.Hover(asHoverContent(hover.contents), asRange(hover.range));
    }
    function asCompletionResult(result) {
        if (!result) {
            return undefined;
        }
        if (Array.isArray(result)) {
            let items = result;
            return items.map(asCompletionItem);
        }
        let list = result;
        return new code.CompletionList(list.items.map(asCompletionItem), list.isIncomplete);
    }
    function asCompletionItemKind(value) {
        // Protocol item kind is 1 based, codes item kind is zero based.
        if (ls.CompletionItemKind.Text <= value && value <= ls.CompletionItemKind.TypeParameter) {
            return [value - 1, undefined];
        }
        return [code.CompletionItemKind.Text, value];
    }
    function asCompletionItemTag(tag) {
        switch (tag) {
            case ls.CompletionItemTag.Deprecated:
                return code.CompletionItemTag.Deprecated;
        }
        return undefined;
    }
    function asCompletionItemTags(tags) {
        if (tags === undefined || tags === null) {
            return [];
        }
        const result = [];
        for (const tag of tags) {
            const converted = asCompletionItemTag(tag);
            if (converted !== undefined) {
                result.push(converted);
            }
        }
        return result;
    }
    function asCompletionItem(item) {
        const tags = asCompletionItemTags(item.tags);
        const result = new protocolCompletionItem_1.default(item.label);
        const label2 = asCompletionItemLabel(item);
        if (label2 !== undefined) {
            result.label2 = label2;
        }
        if (item.detail) {
            result.detail = item.detail;
        }
        if (item.documentation) {
            result.documentation = asDocumentation(item.documentation);
            result.documentationFormat = Is.string(item.documentation) ? '$string' : item.documentation.kind;
        }
        if (item.filterText) {
            result.filterText = item.filterText;
        }
        const insertText = asCompletionInsertText(item);
        if (insertText) {
            result.insertText = insertText.text;
            result.range = insertText.range;
            result.fromEdit = insertText.fromEdit;
        }
        if (Is.number(item.kind)) {
            let [itemKind, original] = asCompletionItemKind(item.kind);
            result.kind = itemKind;
            if (original) {
                result.originalItemKind = original;
            }
        }
        if (item.sortText) {
            result.sortText = item.sortText;
        }
        if (item.additionalTextEdits) {
            result.additionalTextEdits = asTextEdits(item.additionalTextEdits);
        }
        if (Is.stringArray(item.commitCharacters)) {
            result.commitCharacters = item.commitCharacters.slice();
        }
        if (item.command) {
            result.command = asCommand(item.command);
        }
        if (item.deprecated === true || item.deprecated === false) {
            result.deprecated = item.deprecated;
            if (item.deprecated === true) {
                tags.push(code.CompletionItemTag.Deprecated);
            }
        }
        if (item.preselect === true || item.preselect === false) {
            result.preselect = item.preselect;
        }
        if (item.data !== undefined) {
            result.data = item.data;
        }
        if (tags.length > 0) {
            result.tags = tags;
        }
        if (item.insertTextMode !== undefined) {
            result.insertTextMode = item.insertTextMode;
            if (item.insertTextMode === vscode_languageserver_protocol_1.InsertTextMode.asIs) {
                result.keepWhitespace = true;
            }
        }
        return result;
    }
    function asCompletionItemLabel(item) {
        if (vscode_languageserver_protocol_1.CompletionItemLabelDetails.is(item.labelDetails)) {
            return { name: item.label, parameters: item.labelDetails.parameters, qualifier: item.labelDetails.qualifier, type: item.labelDetails.type };
        }
        else {
            return undefined;
        }
    }
    function asCompletionInsertText(item) {
        if (item.textEdit) {
            if (item.insertTextFormat === ls.InsertTextFormat.Snippet) {
                return { text: new code.SnippetString(item.textEdit.newText), range: asCompletionRange(item.textEdit), fromEdit: true };
            }
            else {
                return { text: item.textEdit.newText, range: asCompletionRange(item.textEdit), fromEdit: true };
            }
        }
        else if (item.insertText) {
            if (item.insertTextFormat === ls.InsertTextFormat.Snippet) {
                return { text: new code.SnippetString(item.insertText), fromEdit: false };
            }
            else {
                return { text: item.insertText, fromEdit: false };
            }
        }
        else {
            return undefined;
        }
    }
    function asCompletionRange(value) {
        if (ls.InsertReplaceEdit.is(value)) {
            return { inserting: asRange(value.insert), replacing: asRange(value.replace) };
        }
        else {
            return asRange(value.range);
        }
    }
    function asTextEdit(edit) {
        if (!edit) {
            return undefined;
        }
        return new code.TextEdit(asRange(edit.range), edit.newText);
    }
    function asTextEdits(items) {
        if (!items) {
            return undefined;
        }
        return items.map(asTextEdit);
    }
    function asSignatureHelp(item) {
        if (!item) {
            return undefined;
        }
        let result = new code.SignatureHelp();
        if (Is.number(item.activeSignature)) {
            result.activeSignature = item.activeSignature;
        }
        else {
            // activeSignature was optional in the past
            result.activeSignature = 0;
        }
        if (Is.number(item.activeParameter)) {
            result.activeParameter = item.activeParameter;
        }
        else {
            // activeParameter was optional in the past
            result.activeParameter = 0;
        }
        if (item.signatures) {
            result.signatures = asSignatureInformations(item.signatures);
        }
        return result;
    }
    function asSignatureInformations(items) {
        return items.map(asSignatureInformation);
    }
    function asSignatureInformation(item) {
        let result = new code.SignatureInformation(item.label);
        if (item.documentation !== undefined) {
            result.documentation = asDocumentation(item.documentation);
        }
        if (item.parameters !== undefined) {
            result.parameters = asParameterInformations(item.parameters);
        }
        if (item.activeParameter !== undefined) {
            result.activeParameter = item.activeParameter;
        }
        {
            return result;
        }
    }
    function asParameterInformations(item) {
        return item.map(asParameterInformation);
    }
    function asParameterInformation(item) {
        let result = new code.ParameterInformation(item.label);
        if (item.documentation) {
            result.documentation = asDocumentation(item.documentation);
        }
        return result;
    }
    function asLocation(item) {
        if (!item) {
            return undefined;
        }
        return new code.Location(_uriConverter(item.uri), asRange(item.range));
    }
    function asDeclarationResult(item) {
        if (!item) {
            return undefined;
        }
        return asLocationResult(item);
    }
    function asDefinitionResult(item) {
        if (!item) {
            return undefined;
        }
        return asLocationResult(item);
    }
    function asLocationLink(item) {
        if (!item) {
            return undefined;
        }
        let result = {
            targetUri: _uriConverter(item.targetUri),
            targetRange: asRange(item.targetRange),
            originSelectionRange: asRange(item.originSelectionRange),
            targetSelectionRange: asRange(item.targetSelectionRange)
        };
        if (!result.targetSelectionRange) {
            throw new Error(`targetSelectionRange must not be undefined or null`);
        }
        return result;
    }
    function asLocationResult(item) {
        if (!item) {
            return undefined;
        }
        if (Is.array(item)) {
            if (item.length === 0) {
                return [];
            }
            else if (ls.LocationLink.is(item[0])) {
                let links = item;
                return links.map((link) => asLocationLink(link));
            }
            else {
                let locations = item;
                return locations.map((location) => asLocation(location));
            }
        }
        else if (ls.LocationLink.is(item)) {
            return [asLocationLink(item)];
        }
        else {
            return asLocation(item);
        }
    }
    function asReferences(values) {
        if (!values) {
            return undefined;
        }
        return values.map(location => asLocation(location));
    }
    function asDocumentHighlights(values) {
        if (!values) {
            return undefined;
        }
        return values.map(asDocumentHighlight);
    }
    function asDocumentHighlight(item) {
        let result = new code.DocumentHighlight(asRange(item.range));
        if (Is.number(item.kind)) {
            result.kind = asDocumentHighlightKind(item.kind);
        }
        return result;
    }
    function asDocumentHighlightKind(item) {
        switch (item) {
            case ls.DocumentHighlightKind.Text:
                return code.DocumentHighlightKind.Text;
            case ls.DocumentHighlightKind.Read:
                return code.DocumentHighlightKind.Read;
            case ls.DocumentHighlightKind.Write:
                return code.DocumentHighlightKind.Write;
        }
        return code.DocumentHighlightKind.Text;
    }
    function asSymbolInformations(values, uri) {
        if (!values) {
            return undefined;
        }
        return values.map(information => asSymbolInformation(information, uri));
    }
    function asSymbolKind(item) {
        if (item <= ls.SymbolKind.TypeParameter) {
            // Symbol kind is one based in the protocol and zero based in code.
            return item - 1;
        }
        return code.SymbolKind.Property;
    }
    function asSymbolTag(value) {
        switch (value) {
            case ls.SymbolTag.Deprecated:
                return code.SymbolTag.Deprecated;
            default:
                return undefined;
        }
    }
    function asSymbolTags(items) {
        if (items === undefined || items === null) {
            return undefined;
        }
        const result = [];
        for (const item of items) {
            const converted = asSymbolTag(item);
            if (converted !== undefined) {
                result.push(converted);
            }
        }
        return result.length === 0 ? undefined : result;
    }
    function asSymbolInformation(item, uri) {
        // Symbol kind is one based in the protocol and zero based in code.
        let result = new code.SymbolInformation(item.name, asSymbolKind(item.kind), asRange(item.location.range), item.location.uri ? _uriConverter(item.location.uri) : uri);
        fillTags(result, item);
        if (item.containerName) {
            result.containerName = item.containerName;
        }
        return result;
    }
    function asDocumentSymbols(values) {
        if (values === undefined || values === null) {
            return undefined;
        }
        return values.map(asDocumentSymbol);
    }
    function asDocumentSymbol(value) {
        let result = new code.DocumentSymbol(value.name, value.detail || '', asSymbolKind(value.kind), asRange(value.range), asRange(value.selectionRange));
        fillTags(result, value);
        if (value.children !== undefined && value.children.length > 0) {
            let children = [];
            for (let child of value.children) {
                children.push(asDocumentSymbol(child));
            }
            result.children = children;
        }
        return result;
    }
    function fillTags(result, value) {
        result.tags = asSymbolTags(value.tags);
        if (value.deprecated) {
            if (!result.tags) {
                result.tags = [code.SymbolTag.Deprecated];
            }
            else {
                if (!result.tags.includes(code.SymbolTag.Deprecated)) {
                    result.tags = result.tags.concat(code.SymbolTag.Deprecated);
                }
            }
        }
    }
    function asCommand(item) {
        let result = { title: item.title, command: item.command };
        if (item.arguments) {
            result.arguments = item.arguments;
        }
        return result;
    }
    function asCommands(items) {
        if (!items) {
            return undefined;
        }
        return items.map(asCommand);
    }
    const kindMapping = new Map();
    kindMapping.set(ls.CodeActionKind.Empty, code.CodeActionKind.Empty);
    kindMapping.set(ls.CodeActionKind.QuickFix, code.CodeActionKind.QuickFix);
    kindMapping.set(ls.CodeActionKind.Refactor, code.CodeActionKind.Refactor);
    kindMapping.set(ls.CodeActionKind.RefactorExtract, code.CodeActionKind.RefactorExtract);
    kindMapping.set(ls.CodeActionKind.RefactorInline, code.CodeActionKind.RefactorInline);
    kindMapping.set(ls.CodeActionKind.RefactorRewrite, code.CodeActionKind.RefactorRewrite);
    kindMapping.set(ls.CodeActionKind.Source, code.CodeActionKind.Source);
    kindMapping.set(ls.CodeActionKind.SourceOrganizeImports, code.CodeActionKind.SourceOrganizeImports);
    function asCodeActionKind(item) {
        if (item === undefined || item === null) {
            return undefined;
        }
        let result = kindMapping.get(item);
        if (result) {
            return result;
        }
        let parts = item.split('.');
        result = code.CodeActionKind.Empty;
        for (let part of parts) {
            result = result.append(part);
        }
        return result;
    }
    function asCodeActionKinds(items) {
        if (items === undefined || items === null) {
            return undefined;
        }
        return items.map(kind => asCodeActionKind(kind));
    }
    function asCodeAction(item) {
        if (item === undefined || item === null) {
            return undefined;
        }
        let result = new protocolCodeAction_1.default(item.title, item.data);
        if (item.kind !== undefined) {
            result.kind = asCodeActionKind(item.kind);
        }
        if (item.diagnostics !== undefined) {
            result.diagnostics = asDiagnostics(item.diagnostics);
        }
        if (item.edit !== undefined) {
            result.edit = asWorkspaceEdit(item.edit);
        }
        if (item.command !== undefined) {
            result.command = asCommand(item.command);
        }
        if (item.isPreferred !== undefined) {
            result.isPreferred = item.isPreferred;
        }
        if (item.disabled !== undefined) {
            result.disabled = { reason: item.disabled.reason };
        }
        return result;
    }
    function asCodeLens(item) {
        if (!item) {
            return undefined;
        }
        let result = new protocolCodeLens_1.default(asRange(item.range));
        if (item.command) {
            result.command = asCommand(item.command);
        }
        if (item.data !== undefined && item.data !== null) {
            result.data = item.data;
        }
        return result;
    }
    function asCodeLenses(items) {
        if (!items) {
            return undefined;
        }
        return items.map((codeLens) => asCodeLens(codeLens));
    }
    function asWorkspaceEdit(item) {
        if (!item) {
            return undefined;
        }
        const sharedMetadata = new Map();
        if (item.changeAnnotations !== undefined) {
            for (const key of Object.keys(item.changeAnnotations)) {
                const metaData = asWorkspaceEditEntryMetadata(item.changeAnnotations[key]);
                sharedMetadata.set(key, metaData);
            }
        }
        const asMetadata = (annotation) => {
            if (annotation === undefined) {
                return undefined;
            }
            else {
                return sharedMetadata.get(annotation);
            }
        };
        const result = new code.WorkspaceEdit();
        if (item.documentChanges) {
            for (const change of item.documentChanges) {
                if (ls.CreateFile.is(change)) {
                    result.createFile(_uriConverter(change.uri), change.options, asMetadata(change.annotationId));
                }
                else if (ls.RenameFile.is(change)) {
                    result.renameFile(_uriConverter(change.oldUri), _uriConverter(change.newUri), change.options, asMetadata(change.annotationId));
                }
                else if (ls.DeleteFile.is(change)) {
                    result.deleteFile(_uriConverter(change.uri), change.options, asMetadata(change.annotationId));
                }
                else if (ls.TextDocumentEdit.is(change)) {
                    const uri = _uriConverter(change.textDocument.uri);
                    for (const edit of change.edits) {
                        if (vscode_languageserver_protocol_1.AnnotatedTextEdit.is(edit)) {
                            result.replace(uri, asRange(edit.range), edit.newText, asMetadata(edit.annotationId));
                        }
                        else {
                            result.replace(uri, asRange(edit.range), edit.newText);
                        }
                    }
                }
                else {
                    throw new Error(`Unknown workspace edit change received:\n${JSON.stringify(change, undefined, 4)}`);
                }
            }
        }
        else if (item.changes) {
            Object.keys(item.changes).forEach(key => {
                result.set(_uriConverter(key), asTextEdits(item.changes[key]));
            });
        }
        return result;
    }
    function asWorkspaceEditEntryMetadata(annotation) {
        if (annotation === undefined) {
            return undefined;
        }
        return { label: annotation.label, needsConfirmation: !!annotation.needsConfirmation, description: annotation.description };
    }
    function asDocumentLink(item) {
        let range = asRange(item.range);
        let target = item.target ? asUri(item.target) : undefined;
        // target must be optional in DocumentLink
        let link = new protocolDocumentLink_1.default(range, target);
        if (item.tooltip !== undefined) {
            link.tooltip = item.tooltip;
        }
        if (item.data !== undefined && item.data !== null) {
            link.data = item.data;
        }
        return link;
    }
    function asDocumentLinks(items) {
        if (!items) {
            return undefined;
        }
        return items.map(asDocumentLink);
    }
    function asColor(color) {
        return new code.Color(color.red, color.green, color.blue, color.alpha);
    }
    function asColorInformation(ci) {
        return new code.ColorInformation(asRange(ci.range), asColor(ci.color));
    }
    function asColorInformations(colorInformation) {
        if (Array.isArray(colorInformation)) {
            return colorInformation.map(asColorInformation);
        }
        return undefined;
    }
    function asColorPresentation(cp) {
        let presentation = new code.ColorPresentation(cp.label);
        presentation.additionalTextEdits = asTextEdits(cp.additionalTextEdits);
        if (cp.textEdit) {
            presentation.textEdit = asTextEdit(cp.textEdit);
        }
        return presentation;
    }
    function asColorPresentations(colorPresentations) {
        if (Array.isArray(colorPresentations)) {
            return colorPresentations.map(asColorPresentation);
        }
        return undefined;
    }
    function asFoldingRangeKind(kind) {
        if (kind) {
            switch (kind) {
                case ls.FoldingRangeKind.Comment:
                    return code.FoldingRangeKind.Comment;
                case ls.FoldingRangeKind.Imports:
                    return code.FoldingRangeKind.Imports;
                case ls.FoldingRangeKind.Region:
                    return code.FoldingRangeKind.Region;
            }
        }
        return undefined;
    }
    function asFoldingRange(r) {
        return new code.FoldingRange(r.startLine, r.endLine, asFoldingRangeKind(r.kind));
    }
    function asFoldingRanges(foldingRanges) {
        if (Array.isArray(foldingRanges)) {
            return foldingRanges.map(asFoldingRange);
        }
        return undefined;
    }
    function asSelectionRange(selectionRange) {
        return new code.SelectionRange(asRange(selectionRange.range), selectionRange.parent ? asSelectionRange(selectionRange.parent) : undefined);
    }
    function asSelectionRanges(selectionRanges) {
        if (!Array.isArray(selectionRanges)) {
            return [];
        }
        let result = [];
        for (let range of selectionRanges) {
            result.push(asSelectionRange(range));
        }
        return result;
    }
    function asCallHierarchyItem(item) {
        if (item === null) {
            return undefined;
        }
        let result = new protocolCallHierarchyItem_1.default(asSymbolKind(item.kind), item.name, item.detail || '', asUri(item.uri), asRange(item.range), asRange(item.selectionRange), item.data);
        if (item.tags !== undefined) {
            result.tags = asSymbolTags(item.tags);
        }
        return result;
    }
    function asCallHierarchyItems(items) {
        if (items === null) {
            return undefined;
        }
        return items.map(item => asCallHierarchyItem(item));
    }
    function asCallHierarchyIncomingCall(item) {
        return new code.CallHierarchyIncomingCall(asCallHierarchyItem(item.from), asRanges(item.fromRanges));
    }
    function asCallHierarchyIncomingCalls(items) {
        if (items === null) {
            return undefined;
        }
        return items.map(item => asCallHierarchyIncomingCall(item));
    }
    function asCallHierarchyOutgoingCall(item) {
        return new code.CallHierarchyOutgoingCall(asCallHierarchyItem(item.to), asRanges(item.fromRanges));
    }
    function asCallHierarchyOutgoingCalls(items) {
        if (items === null) {
            return undefined;
        }
        return items.map(item => asCallHierarchyOutgoingCall(item));
    }
    function asSemanticTokens(value) {
        if (value === undefined || value === null) {
            return undefined;
        }
        return new code.SemanticTokens(new Uint32Array(value.data), value.resultId);
    }
    function asSemanticTokensEdit(value) {
        return new code.SemanticTokensEdit(value.start, value.deleteCount, value.data !== undefined ? new Uint32Array(value.data) : undefined);
    }
    function asSemanticTokensEdits(value) {
        if (value === undefined || value === null) {
            return undefined;
        }
        return new code.SemanticTokensEdits(value.edits.map(asSemanticTokensEdit), value.resultId);
    }
    function asSemanticTokensLegend(value) {
        return value;
    }
    function asLinkedEditingRanges(value) {
        if (value === null || value === undefined) {
            return undefined;
        }
        return new code.LinkedEditingRanges(asRanges(value.ranges), asRegularExpression(value.wordPattern));
    }
    function asRegularExpression(value) {
        if (value === null || value === undefined) {
            return undefined;
        }
        return new RegExp(value);
    }
    return {
        asUri,
        asDiagnostics,
        asDiagnostic,
        asRange,
        asRanges,
        asPosition,
        asDiagnosticSeverity,
        asDiagnosticTag,
        asHover,
        asCompletionResult,
        asCompletionItem,
        asTextEdit,
        asTextEdits,
        asSignatureHelp,
        asSignatureInformations,
        asSignatureInformation,
        asParameterInformations,
        asParameterInformation,
        asDeclarationResult,
        asDefinitionResult,
        asLocation,
        asReferences,
        asDocumentHighlights,
        asDocumentHighlight,
        asDocumentHighlightKind,
        asSymbolKind,
        asSymbolTag,
        asSymbolTags,
        asSymbolInformations,
        asSymbolInformation,
        asDocumentSymbols,
        asDocumentSymbol,
        asCommand,
        asCommands,
        asCodeAction,
        asCodeActionKind,
        asCodeActionKinds,
        asCodeLens,
        asCodeLenses,
        asWorkspaceEdit,
        asDocumentLink,
        asDocumentLinks,
        asFoldingRangeKind,
        asFoldingRange,
        asFoldingRanges,
        asColor,
        asColorInformation,
        asColorInformations,
        asColorPresentation,
        asColorPresentations,
        asSelectionRange,
        asSelectionRanges,
        asSemanticTokensLegend,
        asSemanticTokens,
        asSemanticTokensEdit,
        asSemanticTokensEdits,
        asCallHierarchyItem,
        asCallHierarchyItems,
        asCallHierarchyIncomingCall,
        asCallHierarchyIncomingCalls,
        asCallHierarchyOutgoingCall,
        asCallHierarchyOutgoingCalls,
        asLinkedEditingRanges: asLinkedEditingRanges
    };
}
exports.createConverter = createConverter;
//# sourceMappingURL=protocolConverter.js.map

/***/ }),
/* 134 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createProtocolConnection = void 0;
const node_1 = __webpack_require__(135);
__exportStar(__webpack_require__(135), exports);
__exportStar(__webpack_require__(154), exports);
function createProtocolConnection(input, output, logger, options) {
    return node_1.createMessageConnection(input, output, logger, options);
}
exports.createProtocolConnection = createProtocolConnection;
//# sourceMappingURL=main.js.map

/***/ }),
/* 135 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ----------------------------------------------------------------------------------------- */


module.exports = __webpack_require__(136);

/***/ }),
/* 136 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createMessageConnection = exports.createServerSocketTransport = exports.createClientSocketTransport = exports.createServerPipeTransport = exports.createClientPipeTransport = exports.generateRandomPipeName = exports.StreamMessageWriter = exports.StreamMessageReader = exports.SocketMessageWriter = exports.SocketMessageReader = exports.IPCMessageWriter = exports.IPCMessageReader = void 0;
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ----------------------------------------------------------------------------------------- */
const ril_1 = __webpack_require__(137);
// Install the node runtime abstract.
ril_1.default.install();
const api_1 = __webpack_require__(142);
const path = __webpack_require__(152);
const os = __webpack_require__(21);
const crypto_1 = __webpack_require__(7);
const net_1 = __webpack_require__(153);
__exportStar(__webpack_require__(142), exports);
class IPCMessageReader extends api_1.AbstractMessageReader {
    constructor(process) {
        super();
        this.process = process;
        let eventEmitter = this.process;
        eventEmitter.on('error', (error) => this.fireError(error));
        eventEmitter.on('close', () => this.fireClose());
    }
    listen(callback) {
        this.process.on('message', callback);
        return api_1.Disposable.create(() => this.process.off('message', callback));
    }
}
exports.IPCMessageReader = IPCMessageReader;
class IPCMessageWriter extends api_1.AbstractMessageWriter {
    constructor(process) {
        super();
        this.process = process;
        this.errorCount = 0;
        let eventEmitter = this.process;
        eventEmitter.on('error', (error) => this.fireError(error));
        eventEmitter.on('close', () => this.fireClose);
    }
    write(msg) {
        try {
            if (typeof this.process.send === 'function') {
                this.process.send(msg, undefined, undefined, (error) => {
                    if (error) {
                        this.errorCount++;
                        this.handleError(error, msg);
                    }
                    else {
                        this.errorCount = 0;
                    }
                });
            }
            return Promise.resolve();
        }
        catch (error) {
            this.handleError(error, msg);
            return Promise.reject(error);
        }
    }
    handleError(error, msg) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
    }
    end() {
    }
}
exports.IPCMessageWriter = IPCMessageWriter;
class SocketMessageReader extends api_1.ReadableStreamMessageReader {
    constructor(socket, encoding = 'utf-8') {
        super(ril_1.default().stream.asReadableStream(socket), encoding);
    }
}
exports.SocketMessageReader = SocketMessageReader;
class SocketMessageWriter extends api_1.WriteableStreamMessageWriter {
    constructor(socket, options) {
        super(ril_1.default().stream.asWritableStream(socket), options);
        this.socket = socket;
    }
    dispose() {
        super.dispose();
        this.socket.destroy();
    }
}
exports.SocketMessageWriter = SocketMessageWriter;
class StreamMessageReader extends api_1.ReadableStreamMessageReader {
    constructor(readble, encoding) {
        super(ril_1.default().stream.asReadableStream(readble), encoding);
    }
}
exports.StreamMessageReader = StreamMessageReader;
class StreamMessageWriter extends api_1.WriteableStreamMessageWriter {
    constructor(writable, options) {
        super(ril_1.default().stream.asWritableStream(writable), options);
    }
}
exports.StreamMessageWriter = StreamMessageWriter;
const XDG_RUNTIME_DIR = process.env['XDG_RUNTIME_DIR'];
const safeIpcPathLengths = new Map([
    ['linux', 107],
    ['darwin', 103]
]);
function generateRandomPipeName() {
    const randomSuffix = crypto_1.randomBytes(21).toString('hex');
    if (process.platform === 'win32') {
        return `\\\\.\\pipe\\vscode-jsonrpc-${randomSuffix}-sock`;
    }
    let result;
    if (XDG_RUNTIME_DIR) {
        result = path.join(XDG_RUNTIME_DIR, `vscode-ipc-${randomSuffix}.sock`);
    }
    else {
        result = path.join(os.tmpdir(), `vscode-${randomSuffix}.sock`);
    }
    const limit = safeIpcPathLengths.get(process.platform);
    if (limit !== undefined && result.length >= limit) {
        ril_1.default().console.warn(`WARNING: IPC handle "${result}" is longer than ${limit} characters.`);
    }
    return result;
}
exports.generateRandomPipeName = generateRandomPipeName;
function createClientPipeTransport(pipeName, encoding = 'utf-8') {
    let connectResolve;
    const connected = new Promise((resolve, _reject) => {
        connectResolve = resolve;
    });
    return new Promise((resolve, reject) => {
        let server = net_1.createServer((socket) => {
            server.close();
            connectResolve([
                new SocketMessageReader(socket, encoding),
                new SocketMessageWriter(socket, encoding)
            ]);
        });
        server.on('error', reject);
        server.listen(pipeName, () => {
            server.removeListener('error', reject);
            resolve({
                onConnected: () => { return connected; }
            });
        });
    });
}
exports.createClientPipeTransport = createClientPipeTransport;
function createServerPipeTransport(pipeName, encoding = 'utf-8') {
    const socket = net_1.createConnection(pipeName);
    return [
        new SocketMessageReader(socket, encoding),
        new SocketMessageWriter(socket, encoding)
    ];
}
exports.createServerPipeTransport = createServerPipeTransport;
function createClientSocketTransport(port, encoding = 'utf-8') {
    let connectResolve;
    const connected = new Promise((resolve, _reject) => {
        connectResolve = resolve;
    });
    return new Promise((resolve, reject) => {
        const server = net_1.createServer((socket) => {
            server.close();
            connectResolve([
                new SocketMessageReader(socket, encoding),
                new SocketMessageWriter(socket, encoding)
            ]);
        });
        server.on('error', reject);
        server.listen(port, '127.0.0.1', () => {
            server.removeListener('error', reject);
            resolve({
                onConnected: () => { return connected; }
            });
        });
    });
}
exports.createClientSocketTransport = createClientSocketTransport;
function createServerSocketTransport(port, encoding = 'utf-8') {
    const socket = net_1.createConnection(port, '127.0.0.1');
    return [
        new SocketMessageReader(socket, encoding),
        new SocketMessageWriter(socket, encoding)
    ];
}
exports.createServerSocketTransport = createServerSocketTransport;
function isReadableStream(value) {
    const candidate = value;
    return candidate.read !== undefined && candidate.addListener !== undefined;
}
function isWritableStream(value) {
    const candidate = value;
    return candidate.write !== undefined && candidate.addListener !== undefined;
}
function createMessageConnection(input, output, logger, options) {
    if (!logger) {
        logger = api_1.NullLogger;
    }
    const reader = isReadableStream(input) ? new StreamMessageReader(input) : input;
    const writer = isWritableStream(output) ? new StreamMessageWriter(output) : output;
    if (api_1.ConnectionStrategy.is(options)) {
        options = { connectionStrategy: options };
    }
    return api_1.createMessageConnection(reader, writer, logger, options);
}
exports.createMessageConnection = createMessageConnection;
//# sourceMappingURL=main.js.map

/***/ }),
/* 137 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
const ral_1 = __webpack_require__(138);
const util_1 = __webpack_require__(139);
const disposable_1 = __webpack_require__(140);
const messageBuffer_1 = __webpack_require__(141);
class MessageBuffer extends messageBuffer_1.AbstractMessageBuffer {
    constructor(encoding = 'utf-8') {
        super(encoding);
    }
    emptyBuffer() {
        return MessageBuffer.emptyBuffer;
    }
    fromString(value, encoding) {
        return Buffer.from(value, encoding);
    }
    toString(value, encoding) {
        if (value instanceof Buffer) {
            return value.toString(encoding);
        }
        else {
            return new util_1.TextDecoder(encoding).decode(value);
        }
    }
    asNative(buffer, length) {
        if (length === undefined) {
            return buffer instanceof Buffer ? buffer : Buffer.from(buffer);
        }
        else {
            return buffer instanceof Buffer ? buffer.slice(0, length) : Buffer.from(buffer, 0, length);
        }
    }
    allocNative(length) {
        return Buffer.allocUnsafe(length);
    }
}
MessageBuffer.emptyBuffer = Buffer.allocUnsafe(0);
class ReadableStreamWrapper {
    constructor(stream) {
        this.stream = stream;
    }
    onClose(listener) {
        this.stream.on('close', listener);
        return disposable_1.Disposable.create(() => this.stream.off('close', listener));
    }
    onError(listener) {
        this.stream.on('error', listener);
        return disposable_1.Disposable.create(() => this.stream.off('error', listener));
    }
    onEnd(listener) {
        this.stream.on('end', listener);
        return disposable_1.Disposable.create(() => this.stream.off('end', listener));
    }
    onData(listener) {
        this.stream.on('data', listener);
        return disposable_1.Disposable.create(() => this.stream.off('data', listener));
    }
}
class WritableStreamWrapper {
    constructor(stream) {
        this.stream = stream;
    }
    onClose(listener) {
        this.stream.on('close', listener);
        return disposable_1.Disposable.create(() => this.stream.off('close', listener));
    }
    onError(listener) {
        this.stream.on('error', listener);
        return disposable_1.Disposable.create(() => this.stream.off('error', listener));
    }
    onEnd(listener) {
        this.stream.on('end', listener);
        return disposable_1.Disposable.create(() => this.stream.off('end', listener));
    }
    write(data, encoding) {
        return new Promise((resolve, reject) => {
            const callback = (error) => {
                if (error === undefined || error === null) {
                    resolve();
                }
                else {
                    reject(error);
                }
            };
            if (typeof data === 'string') {
                this.stream.write(data, encoding, callback);
            }
            else {
                this.stream.write(data, callback);
            }
        });
    }
    end() {
        this.stream.end();
    }
}
const _ril = Object.freeze({
    messageBuffer: Object.freeze({
        create: (encoding) => new MessageBuffer(encoding)
    }),
    applicationJson: Object.freeze({
        encoder: Object.freeze({
            name: 'application/json',
            encode: (msg, options) => {
                try {
                    return Promise.resolve(Buffer.from(JSON.stringify(msg, undefined, 0), options.charset));
                }
                catch (err) {
                    return Promise.reject(err);
                }
            }
        }),
        decoder: Object.freeze({
            name: 'application/json',
            decode: (buffer, options) => {
                try {
                    if (buffer instanceof Buffer) {
                        return Promise.resolve(JSON.parse(buffer.toString(options.charset)));
                    }
                    else {
                        return Promise.resolve(JSON.parse(new util_1.TextDecoder(options.charset).decode(buffer)));
                    }
                }
                catch (err) {
                    return Promise.reject(err);
                }
            }
        })
    }),
    stream: Object.freeze({
        asReadableStream: (stream) => new ReadableStreamWrapper(stream),
        asWritableStream: (stream) => new WritableStreamWrapper(stream)
    }),
    console: console,
    timer: Object.freeze({
        setTimeout(callback, ms, ...args) {
            const handle = setTimeout(callback, ms, ...args);
            return { dispose: () => clearTimeout(handle) };
        },
        setImmediate(callback, ...args) {
            const handle = setImmediate(callback, ...args);
            return { dispose: () => clearImmediate(handle) };
        },
        setInterval(callback, ms, ...args) {
            const handle = setInterval(callback, ms, ...args);
            return { dispose: () => clearInterval(handle) };
        }
    })
});
function RIL() {
    return _ril;
}
(function (RIL) {
    function install() {
        ral_1.default.install(_ril);
    }
    RIL.install = install;
})(RIL || (RIL = {}));
exports["default"] = RIL;
//# sourceMappingURL=ril.js.map

/***/ }),
/* 138 */
/***/ ((__unused_webpack_module, exports) => {


/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
let _ral;
function RAL() {
    if (_ral === undefined) {
        throw new Error(`No runtime abstraction layer installed`);
    }
    return _ral;
}
(function (RAL) {
    function install(ral) {
        if (ral === undefined) {
            throw new Error(`No runtime abstraction layer provided`);
        }
        _ral = ral;
    }
    RAL.install = install;
})(RAL || (RAL = {}));
exports["default"] = RAL;
//# sourceMappingURL=ral.js.map

/***/ }),
/* 139 */
/***/ ((module) => {

module.exports = require("util");

/***/ }),
/* 140 */
/***/ ((__unused_webpack_module, exports) => {


/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Disposable = void 0;
var Disposable;
(function (Disposable) {
    function create(func) {
        return {
            dispose: func
        };
    }
    Disposable.create = create;
})(Disposable = exports.Disposable || (exports.Disposable = {}));
//# sourceMappingURL=disposable.js.map

/***/ }),
/* 141 */
/***/ ((__unused_webpack_module, exports) => {


/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AbstractMessageBuffer = void 0;
const CR = 13;
const LF = 10;
const CRLF = '\r\n';
class AbstractMessageBuffer {
    constructor(encoding = 'utf-8') {
        this._encoding = encoding;
        this._chunks = [];
        this._totalLength = 0;
    }
    get encoding() {
        return this._encoding;
    }
    append(chunk) {
        const toAppend = typeof chunk === 'string' ? this.fromString(chunk, this._encoding) : chunk;
        this._chunks.push(toAppend);
        this._totalLength += toAppend.byteLength;
    }
    tryReadHeaders() {
        if (this._chunks.length === 0) {
            return undefined;
        }
        let state = 0;
        let chunkIndex = 0;
        let offset = 0;
        let chunkBytesRead = 0;
        row: while (chunkIndex < this._chunks.length) {
            const chunk = this._chunks[chunkIndex];
            offset = 0;
            column: while (offset < chunk.length) {
                const value = chunk[offset];
                switch (value) {
                    case CR:
                        switch (state) {
                            case 0:
                                state = 1;
                                break;
                            case 2:
                                state = 3;
                                break;
                            default:
                                state = 0;
                        }
                        break;
                    case LF:
                        switch (state) {
                            case 1:
                                state = 2;
                                break;
                            case 3:
                                state = 4;
                                offset++;
                                break row;
                            default:
                                state = 0;
                        }
                        break;
                    default:
                        state = 0;
                }
                offset++;
            }
            chunkBytesRead += chunk.byteLength;
            chunkIndex++;
        }
        if (state !== 4) {
            return undefined;
        }
        // The buffer contains the two CRLF at the end. So we will
        // have two empty lines after the split at the end as well.
        const buffer = this._read(chunkBytesRead + offset);
        const result = new Map();
        const headers = this.toString(buffer, 'ascii').split(CRLF);
        if (headers.length < 2) {
            return result;
        }
        for (let i = 0; i < headers.length - 2; i++) {
            const header = headers[i];
            const index = header.indexOf(':');
            if (index === -1) {
                throw new Error('Message header must separate key and value using :');
            }
            const key = header.substr(0, index);
            const value = header.substr(index + 1).trim();
            result.set(key, value);
        }
        return result;
    }
    tryReadBody(length) {
        if (this._totalLength < length) {
            return undefined;
        }
        return this._read(length);
    }
    get numberOfBytes() {
        return this._totalLength;
    }
    _read(byteCount) {
        if (byteCount === 0) {
            return this.emptyBuffer();
        }
        if (byteCount > this._totalLength) {
            throw new Error(`Cannot read so many bytes!`);
        }
        if (this._chunks[0].byteLength === byteCount) {
            // super fast path, precisely first chunk must be returned
            const chunk = this._chunks[0];
            this._chunks.shift();
            this._totalLength -= byteCount;
            return this.asNative(chunk);
        }
        if (this._chunks[0].byteLength > byteCount) {
            // fast path, the reading is entirely within the first chunk
            const chunk = this._chunks[0];
            const result = this.asNative(chunk, byteCount);
            this._chunks[0] = chunk.slice(byteCount);
            this._totalLength -= byteCount;
            return result;
        }
        const result = this.allocNative(byteCount);
        let resultOffset = 0;
        let chunkIndex = 0;
        while (byteCount > 0) {
            const chunk = this._chunks[chunkIndex];
            if (chunk.byteLength > byteCount) {
                // this chunk will survive
                const chunkPart = chunk.slice(0, byteCount);
                result.set(chunkPart, resultOffset);
                resultOffset += byteCount;
                this._chunks[chunkIndex] = chunk.slice(byteCount);
                this._totalLength -= byteCount;
                byteCount -= byteCount;
            }
            else {
                // this chunk will be entirely read
                result.set(chunk, resultOffset);
                resultOffset += chunk.byteLength;
                this._chunks.shift();
                this._totalLength -= chunk.byteLength;
                byteCount -= chunk.byteLength;
            }
        }
        return result;
    }
}
exports.AbstractMessageBuffer = AbstractMessageBuffer;
//# sourceMappingURL=messageBuffer.js.map

/***/ }),
/* 142 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
/// <reference path="../../typings/thenable.d.ts" />
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConnectionErrors = exports.LogTraceNotification = exports.SetTraceNotification = exports.TraceFormat = exports.Trace = exports.ProgressType = exports.createMessageConnection = exports.NullLogger = exports.ConnectionOptions = exports.ConnectionStrategy = exports.WriteableStreamMessageWriter = exports.AbstractMessageWriter = exports.MessageWriter = exports.ReadableStreamMessageReader = exports.AbstractMessageReader = exports.MessageReader = exports.CancellationToken = exports.CancellationTokenSource = exports.Emitter = exports.Event = exports.Disposable = exports.LRUCache = exports.Touch = exports.LinkedMap = exports.ParameterStructures = exports.NotificationType9 = exports.NotificationType8 = exports.NotificationType7 = exports.NotificationType6 = exports.NotificationType5 = exports.NotificationType4 = exports.NotificationType3 = exports.NotificationType2 = exports.NotificationType1 = exports.NotificationType0 = exports.NotificationType = exports.ErrorCodes = exports.ResponseError = exports.RequestType9 = exports.RequestType8 = exports.RequestType7 = exports.RequestType6 = exports.RequestType5 = exports.RequestType4 = exports.RequestType3 = exports.RequestType2 = exports.RequestType1 = exports.RequestType0 = exports.RequestType = exports.RAL = void 0;
exports.CancellationStrategy = exports.CancellationSenderStrategy = exports.CancellationReceiverStrategy = exports.ConnectionError = void 0;
const messages_1 = __webpack_require__(143);
Object.defineProperty(exports, "RequestType", ({ enumerable: true, get: function () { return messages_1.RequestType; } }));
Object.defineProperty(exports, "RequestType0", ({ enumerable: true, get: function () { return messages_1.RequestType0; } }));
Object.defineProperty(exports, "RequestType1", ({ enumerable: true, get: function () { return messages_1.RequestType1; } }));
Object.defineProperty(exports, "RequestType2", ({ enumerable: true, get: function () { return messages_1.RequestType2; } }));
Object.defineProperty(exports, "RequestType3", ({ enumerable: true, get: function () { return messages_1.RequestType3; } }));
Object.defineProperty(exports, "RequestType4", ({ enumerable: true, get: function () { return messages_1.RequestType4; } }));
Object.defineProperty(exports, "RequestType5", ({ enumerable: true, get: function () { return messages_1.RequestType5; } }));
Object.defineProperty(exports, "RequestType6", ({ enumerable: true, get: function () { return messages_1.RequestType6; } }));
Object.defineProperty(exports, "RequestType7", ({ enumerable: true, get: function () { return messages_1.RequestType7; } }));
Object.defineProperty(exports, "RequestType8", ({ enumerable: true, get: function () { return messages_1.RequestType8; } }));
Object.defineProperty(exports, "RequestType9", ({ enumerable: true, get: function () { return messages_1.RequestType9; } }));
Object.defineProperty(exports, "ResponseError", ({ enumerable: true, get: function () { return messages_1.ResponseError; } }));
Object.defineProperty(exports, "ErrorCodes", ({ enumerable: true, get: function () { return messages_1.ErrorCodes; } }));
Object.defineProperty(exports, "NotificationType", ({ enumerable: true, get: function () { return messages_1.NotificationType; } }));
Object.defineProperty(exports, "NotificationType0", ({ enumerable: true, get: function () { return messages_1.NotificationType0; } }));
Object.defineProperty(exports, "NotificationType1", ({ enumerable: true, get: function () { return messages_1.NotificationType1; } }));
Object.defineProperty(exports, "NotificationType2", ({ enumerable: true, get: function () { return messages_1.NotificationType2; } }));
Object.defineProperty(exports, "NotificationType3", ({ enumerable: true, get: function () { return messages_1.NotificationType3; } }));
Object.defineProperty(exports, "NotificationType4", ({ enumerable: true, get: function () { return messages_1.NotificationType4; } }));
Object.defineProperty(exports, "NotificationType5", ({ enumerable: true, get: function () { return messages_1.NotificationType5; } }));
Object.defineProperty(exports, "NotificationType6", ({ enumerable: true, get: function () { return messages_1.NotificationType6; } }));
Object.defineProperty(exports, "NotificationType7", ({ enumerable: true, get: function () { return messages_1.NotificationType7; } }));
Object.defineProperty(exports, "NotificationType8", ({ enumerable: true, get: function () { return messages_1.NotificationType8; } }));
Object.defineProperty(exports, "NotificationType9", ({ enumerable: true, get: function () { return messages_1.NotificationType9; } }));
Object.defineProperty(exports, "ParameterStructures", ({ enumerable: true, get: function () { return messages_1.ParameterStructures; } }));
const linkedMap_1 = __webpack_require__(145);
Object.defineProperty(exports, "LinkedMap", ({ enumerable: true, get: function () { return linkedMap_1.LinkedMap; } }));
Object.defineProperty(exports, "LRUCache", ({ enumerable: true, get: function () { return linkedMap_1.LRUCache; } }));
Object.defineProperty(exports, "Touch", ({ enumerable: true, get: function () { return linkedMap_1.Touch; } }));
const disposable_1 = __webpack_require__(140);
Object.defineProperty(exports, "Disposable", ({ enumerable: true, get: function () { return disposable_1.Disposable; } }));
const events_1 = __webpack_require__(146);
Object.defineProperty(exports, "Event", ({ enumerable: true, get: function () { return events_1.Event; } }));
Object.defineProperty(exports, "Emitter", ({ enumerable: true, get: function () { return events_1.Emitter; } }));
const cancellation_1 = __webpack_require__(147);
Object.defineProperty(exports, "CancellationTokenSource", ({ enumerable: true, get: function () { return cancellation_1.CancellationTokenSource; } }));
Object.defineProperty(exports, "CancellationToken", ({ enumerable: true, get: function () { return cancellation_1.CancellationToken; } }));
const messageReader_1 = __webpack_require__(148);
Object.defineProperty(exports, "MessageReader", ({ enumerable: true, get: function () { return messageReader_1.MessageReader; } }));
Object.defineProperty(exports, "AbstractMessageReader", ({ enumerable: true, get: function () { return messageReader_1.AbstractMessageReader; } }));
Object.defineProperty(exports, "ReadableStreamMessageReader", ({ enumerable: true, get: function () { return messageReader_1.ReadableStreamMessageReader; } }));
const messageWriter_1 = __webpack_require__(149);
Object.defineProperty(exports, "MessageWriter", ({ enumerable: true, get: function () { return messageWriter_1.MessageWriter; } }));
Object.defineProperty(exports, "AbstractMessageWriter", ({ enumerable: true, get: function () { return messageWriter_1.AbstractMessageWriter; } }));
Object.defineProperty(exports, "WriteableStreamMessageWriter", ({ enumerable: true, get: function () { return messageWriter_1.WriteableStreamMessageWriter; } }));
const connection_1 = __webpack_require__(151);
Object.defineProperty(exports, "ConnectionStrategy", ({ enumerable: true, get: function () { return connection_1.ConnectionStrategy; } }));
Object.defineProperty(exports, "ConnectionOptions", ({ enumerable: true, get: function () { return connection_1.ConnectionOptions; } }));
Object.defineProperty(exports, "NullLogger", ({ enumerable: true, get: function () { return connection_1.NullLogger; } }));
Object.defineProperty(exports, "createMessageConnection", ({ enumerable: true, get: function () { return connection_1.createMessageConnection; } }));
Object.defineProperty(exports, "ProgressType", ({ enumerable: true, get: function () { return connection_1.ProgressType; } }));
Object.defineProperty(exports, "Trace", ({ enumerable: true, get: function () { return connection_1.Trace; } }));
Object.defineProperty(exports, "TraceFormat", ({ enumerable: true, get: function () { return connection_1.TraceFormat; } }));
Object.defineProperty(exports, "SetTraceNotification", ({ enumerable: true, get: function () { return connection_1.SetTraceNotification; } }));
Object.defineProperty(exports, "LogTraceNotification", ({ enumerable: true, get: function () { return connection_1.LogTraceNotification; } }));
Object.defineProperty(exports, "ConnectionErrors", ({ enumerable: true, get: function () { return connection_1.ConnectionErrors; } }));
Object.defineProperty(exports, "ConnectionError", ({ enumerable: true, get: function () { return connection_1.ConnectionError; } }));
Object.defineProperty(exports, "CancellationReceiverStrategy", ({ enumerable: true, get: function () { return connection_1.CancellationReceiverStrategy; } }));
Object.defineProperty(exports, "CancellationSenderStrategy", ({ enumerable: true, get: function () { return connection_1.CancellationSenderStrategy; } }));
Object.defineProperty(exports, "CancellationStrategy", ({ enumerable: true, get: function () { return connection_1.CancellationStrategy; } }));
const ral_1 = __webpack_require__(138);
exports.RAL = ral_1.default;
//# sourceMappingURL=api.js.map

/***/ }),
/* 143 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isResponseMessage = exports.isNotificationMessage = exports.isRequestMessage = exports.NotificationType9 = exports.NotificationType8 = exports.NotificationType7 = exports.NotificationType6 = exports.NotificationType5 = exports.NotificationType4 = exports.NotificationType3 = exports.NotificationType2 = exports.NotificationType1 = exports.NotificationType0 = exports.NotificationType = exports.RequestType9 = exports.RequestType8 = exports.RequestType7 = exports.RequestType6 = exports.RequestType5 = exports.RequestType4 = exports.RequestType3 = exports.RequestType2 = exports.RequestType1 = exports.RequestType = exports.RequestType0 = exports.AbstractMessageSignature = exports.ParameterStructures = exports.ResponseError = exports.ErrorCodes = void 0;
const is = __webpack_require__(144);
/**
 * Predefined error codes.
 */
var ErrorCodes;
(function (ErrorCodes) {
    // Defined by JSON RPC
    ErrorCodes.ParseError = -32700;
    ErrorCodes.InvalidRequest = -32600;
    ErrorCodes.MethodNotFound = -32601;
    ErrorCodes.InvalidParams = -32602;
    ErrorCodes.InternalError = -32603;
    /**
     * This is the start range of JSON RPC reserved error codes.
     * It doesn't denote a real error code. No application error codes should
     * be defined between the start and end range. For backwards
     * compatibility the `ServerNotInitialized` and the `UnknownErrorCode`
     * are left in the range.
     *
     * @since 3.16.0
    */
    ErrorCodes.jsonrpcReservedErrorRangeStart = -32099;
    /** @deprecated use  jsonrpcReservedErrorRangeStart */
    ErrorCodes.serverErrorStart = ErrorCodes.jsonrpcReservedErrorRangeStart;
    ErrorCodes.MessageWriteError = -32099;
    ErrorCodes.MessageReadError = -32098;
    /**
     * Error code indicating that a server received a notification or
     * request before the server has received the `initialize` request.
     */
    ErrorCodes.ServerNotInitialized = -32002;
    ErrorCodes.UnknownErrorCode = -32001;
    /**
     * This is the end range of JSON RPC reserved error codes.
     * It doesn't denote a real error code.
     *
     * @since 3.16.0
    */
    ErrorCodes.jsonrpcReservedErrorRangeEnd = -32000;
    /** @deprecated use  jsonrpcReservedErrorRangeEnd */
    ErrorCodes.serverErrorEnd = ErrorCodes.jsonrpcReservedErrorRangeEnd;
})(ErrorCodes = exports.ErrorCodes || (exports.ErrorCodes = {}));
/**
 * An error object return in a response in case a request
 * has failed.
 */
class ResponseError extends Error {
    constructor(code, message, data) {
        super(message);
        this.code = is.number(code) ? code : ErrorCodes.UnknownErrorCode;
        this.data = data;
        Object.setPrototypeOf(this, ResponseError.prototype);
    }
    toJson() {
        const result = {
            code: this.code,
            message: this.message
        };
        if (this.data !== undefined) {
            result.data = this.data;
        }
        return result;
    }
}
exports.ResponseError = ResponseError;
class ParameterStructures {
    constructor(kind) {
        this.kind = kind;
    }
    static is(value) {
        return value === ParameterStructures.auto || value === ParameterStructures.byName || value === ParameterStructures.byPosition;
    }
    toString() {
        return this.kind;
    }
}
exports.ParameterStructures = ParameterStructures;
/**
 * The parameter structure is automatically inferred on the number of parameters
 * and the parameter type in case of a single param.
 */
ParameterStructures.auto = new ParameterStructures('auto');
/**
 * Forces `byPosition` parameter structure. This is useful if you have a single
 * parameter which has a literal type.
 */
ParameterStructures.byPosition = new ParameterStructures('byPosition');
/**
 * Forces `byName` parameter structure. This is only useful when having a single
 * parameter. The library will report errors if used with a different number of
 * parameters.
 */
ParameterStructures.byName = new ParameterStructures('byName');
/**
 * An abstract implementation of a MessageType.
 */
class AbstractMessageSignature {
    constructor(method, numberOfParams) {
        this.method = method;
        this.numberOfParams = numberOfParams;
    }
    get parameterStructures() {
        return ParameterStructures.auto;
    }
}
exports.AbstractMessageSignature = AbstractMessageSignature;
/**
 * Classes to type request response pairs
 */
class RequestType0 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 0);
    }
}
exports.RequestType0 = RequestType0;
class RequestType extends AbstractMessageSignature {
    constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
    }
    get parameterStructures() {
        return this._parameterStructures;
    }
}
exports.RequestType = RequestType;
class RequestType1 extends AbstractMessageSignature {
    constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
    }
    get parameterStructures() {
        return this._parameterStructures;
    }
}
exports.RequestType1 = RequestType1;
class RequestType2 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 2);
    }
}
exports.RequestType2 = RequestType2;
class RequestType3 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 3);
    }
}
exports.RequestType3 = RequestType3;
class RequestType4 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 4);
    }
}
exports.RequestType4 = RequestType4;
class RequestType5 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 5);
    }
}
exports.RequestType5 = RequestType5;
class RequestType6 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 6);
    }
}
exports.RequestType6 = RequestType6;
class RequestType7 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 7);
    }
}
exports.RequestType7 = RequestType7;
class RequestType8 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 8);
    }
}
exports.RequestType8 = RequestType8;
class RequestType9 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 9);
    }
}
exports.RequestType9 = RequestType9;
class NotificationType extends AbstractMessageSignature {
    constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
    }
    get parameterStructures() {
        return this._parameterStructures;
    }
}
exports.NotificationType = NotificationType;
class NotificationType0 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 0);
    }
}
exports.NotificationType0 = NotificationType0;
class NotificationType1 extends AbstractMessageSignature {
    constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
    }
    get parameterStructures() {
        return this._parameterStructures;
    }
}
exports.NotificationType1 = NotificationType1;
class NotificationType2 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 2);
    }
}
exports.NotificationType2 = NotificationType2;
class NotificationType3 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 3);
    }
}
exports.NotificationType3 = NotificationType3;
class NotificationType4 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 4);
    }
}
exports.NotificationType4 = NotificationType4;
class NotificationType5 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 5);
    }
}
exports.NotificationType5 = NotificationType5;
class NotificationType6 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 6);
    }
}
exports.NotificationType6 = NotificationType6;
class NotificationType7 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 7);
    }
}
exports.NotificationType7 = NotificationType7;
class NotificationType8 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 8);
    }
}
exports.NotificationType8 = NotificationType8;
class NotificationType9 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 9);
    }
}
exports.NotificationType9 = NotificationType9;
/**
 * Tests if the given message is a request message
 */
function isRequestMessage(message) {
    const candidate = message;
    return candidate && is.string(candidate.method) && (is.string(candidate.id) || is.number(candidate.id));
}
exports.isRequestMessage = isRequestMessage;
/**
 * Tests if the given message is a notification message
 */
function isNotificationMessage(message) {
    const candidate = message;
    return candidate && is.string(candidate.method) && message.id === void 0;
}
exports.isNotificationMessage = isNotificationMessage;
/**
 * Tests if the given message is a response message
 */
function isResponseMessage(message) {
    const candidate = message;
    return candidate && (candidate.result !== void 0 || !!candidate.error) && (is.string(candidate.id) || is.number(candidate.id) || candidate.id === null);
}
exports.isResponseMessage = isResponseMessage;
//# sourceMappingURL=messages.js.map

/***/ }),
/* 144 */
/***/ ((__unused_webpack_module, exports) => {


/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.stringArray = exports.array = exports.func = exports.error = exports.number = exports.string = exports.boolean = void 0;
function boolean(value) {
    return value === true || value === false;
}
exports.boolean = boolean;
function string(value) {
    return typeof value === 'string' || value instanceof String;
}
exports.string = string;
function number(value) {
    return typeof value === 'number' || value instanceof Number;
}
exports.number = number;
function error(value) {
    return value instanceof Error;
}
exports.error = error;
function func(value) {
    return typeof value === 'function';
}
exports.func = func;
function array(value) {
    return Array.isArray(value);
}
exports.array = array;
function stringArray(value) {
    return array(value) && value.every(elem => string(elem));
}
exports.stringArray = stringArray;
//# sourceMappingURL=is.js.map

/***/ }),
/* 145 */
/***/ ((__unused_webpack_module, exports) => {


/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LRUCache = exports.LinkedMap = exports.Touch = void 0;
var Touch;
(function (Touch) {
    Touch.None = 0;
    Touch.First = 1;
    Touch.AsOld = Touch.First;
    Touch.Last = 2;
    Touch.AsNew = Touch.Last;
})(Touch = exports.Touch || (exports.Touch = {}));
class LinkedMap {
    constructor() {
        this[_a] = 'LinkedMap';
        this._map = new Map();
        this._head = undefined;
        this._tail = undefined;
        this._size = 0;
        this._state = 0;
    }
    clear() {
        this._map.clear();
        this._head = undefined;
        this._tail = undefined;
        this._size = 0;
        this._state++;
    }
    isEmpty() {
        return !this._head && !this._tail;
    }
    get size() {
        return this._size;
    }
    get first() {
        var _b;
        return (_b = this._head) === null || _b === void 0 ? void 0 : _b.value;
    }
    get last() {
        var _b;
        return (_b = this._tail) === null || _b === void 0 ? void 0 : _b.value;
    }
    has(key) {
        return this._map.has(key);
    }
    get(key, touch = Touch.None) {
        const item = this._map.get(key);
        if (!item) {
            return undefined;
        }
        if (touch !== Touch.None) {
            this.touch(item, touch);
        }
        return item.value;
    }
    set(key, value, touch = Touch.None) {
        let item = this._map.get(key);
        if (item) {
            item.value = value;
            if (touch !== Touch.None) {
                this.touch(item, touch);
            }
        }
        else {
            item = { key, value, next: undefined, previous: undefined };
            switch (touch) {
                case Touch.None:
                    this.addItemLast(item);
                    break;
                case Touch.First:
                    this.addItemFirst(item);
                    break;
                case Touch.Last:
                    this.addItemLast(item);
                    break;
                default:
                    this.addItemLast(item);
                    break;
            }
            this._map.set(key, item);
            this._size++;
        }
        return this;
    }
    delete(key) {
        return !!this.remove(key);
    }
    remove(key) {
        const item = this._map.get(key);
        if (!item) {
            return undefined;
        }
        this._map.delete(key);
        this.removeItem(item);
        this._size--;
        return item.value;
    }
    shift() {
        if (!this._head && !this._tail) {
            return undefined;
        }
        if (!this._head || !this._tail) {
            throw new Error('Invalid list');
        }
        const item = this._head;
        this._map.delete(item.key);
        this.removeItem(item);
        this._size--;
        return item.value;
    }
    forEach(callbackfn, thisArg) {
        const state = this._state;
        let current = this._head;
        while (current) {
            if (thisArg) {
                callbackfn.bind(thisArg)(current.value, current.key, this);
            }
            else {
                callbackfn(current.value, current.key, this);
            }
            if (this._state !== state) {
                throw new Error(`LinkedMap got modified during iteration.`);
            }
            current = current.next;
        }
    }
    keys() {
        const state = this._state;
        let current = this._head;
        const iterator = {
            [Symbol.iterator]: () => {
                return iterator;
            },
            next: () => {
                if (this._state !== state) {
                    throw new Error(`LinkedMap got modified during iteration.`);
                }
                if (current) {
                    const result = { value: current.key, done: false };
                    current = current.next;
                    return result;
                }
                else {
                    return { value: undefined, done: true };
                }
            }
        };
        return iterator;
    }
    values() {
        const state = this._state;
        let current = this._head;
        const iterator = {
            [Symbol.iterator]: () => {
                return iterator;
            },
            next: () => {
                if (this._state !== state) {
                    throw new Error(`LinkedMap got modified during iteration.`);
                }
                if (current) {
                    const result = { value: current.value, done: false };
                    current = current.next;
                    return result;
                }
                else {
                    return { value: undefined, done: true };
                }
            }
        };
        return iterator;
    }
    entries() {
        const state = this._state;
        let current = this._head;
        const iterator = {
            [Symbol.iterator]: () => {
                return iterator;
            },
            next: () => {
                if (this._state !== state) {
                    throw new Error(`LinkedMap got modified during iteration.`);
                }
                if (current) {
                    const result = { value: [current.key, current.value], done: false };
                    current = current.next;
                    return result;
                }
                else {
                    return { value: undefined, done: true };
                }
            }
        };
        return iterator;
    }
    [(_a = Symbol.toStringTag, Symbol.iterator)]() {
        return this.entries();
    }
    trimOld(newSize) {
        if (newSize >= this.size) {
            return;
        }
        if (newSize === 0) {
            this.clear();
            return;
        }
        let current = this._head;
        let currentSize = this.size;
        while (current && currentSize > newSize) {
            this._map.delete(current.key);
            current = current.next;
            currentSize--;
        }
        this._head = current;
        this._size = currentSize;
        if (current) {
            current.previous = undefined;
        }
        this._state++;
    }
    addItemFirst(item) {
        // First time Insert
        if (!this._head && !this._tail) {
            this._tail = item;
        }
        else if (!this._head) {
            throw new Error('Invalid list');
        }
        else {
            item.next = this._head;
            this._head.previous = item;
        }
        this._head = item;
        this._state++;
    }
    addItemLast(item) {
        // First time Insert
        if (!this._head && !this._tail) {
            this._head = item;
        }
        else if (!this._tail) {
            throw new Error('Invalid list');
        }
        else {
            item.previous = this._tail;
            this._tail.next = item;
        }
        this._tail = item;
        this._state++;
    }
    removeItem(item) {
        if (item === this._head && item === this._tail) {
            this._head = undefined;
            this._tail = undefined;
        }
        else if (item === this._head) {
            // This can only happened if size === 1 which is handle
            // by the case above.
            if (!item.next) {
                throw new Error('Invalid list');
            }
            item.next.previous = undefined;
            this._head = item.next;
        }
        else if (item === this._tail) {
            // This can only happened if size === 1 which is handle
            // by the case above.
            if (!item.previous) {
                throw new Error('Invalid list');
            }
            item.previous.next = undefined;
            this._tail = item.previous;
        }
        else {
            const next = item.next;
            const previous = item.previous;
            if (!next || !previous) {
                throw new Error('Invalid list');
            }
            next.previous = previous;
            previous.next = next;
        }
        item.next = undefined;
        item.previous = undefined;
        this._state++;
    }
    touch(item, touch) {
        if (!this._head || !this._tail) {
            throw new Error('Invalid list');
        }
        if ((touch !== Touch.First && touch !== Touch.Last)) {
            return;
        }
        if (touch === Touch.First) {
            if (item === this._head) {
                return;
            }
            const next = item.next;
            const previous = item.previous;
            // Unlink the item
            if (item === this._tail) {
                // previous must be defined since item was not head but is tail
                // So there are more than on item in the map
                previous.next = undefined;
                this._tail = previous;
            }
            else {
                // Both next and previous are not undefined since item was neither head nor tail.
                next.previous = previous;
                previous.next = next;
            }
            // Insert the node at head
            item.previous = undefined;
            item.next = this._head;
            this._head.previous = item;
            this._head = item;
            this._state++;
        }
        else if (touch === Touch.Last) {
            if (item === this._tail) {
                return;
            }
            const next = item.next;
            const previous = item.previous;
            // Unlink the item.
            if (item === this._head) {
                // next must be defined since item was not tail but is head
                // So there are more than on item in the map
                next.previous = undefined;
                this._head = next;
            }
            else {
                // Both next and previous are not undefined since item was neither head nor tail.
                next.previous = previous;
                previous.next = next;
            }
            item.next = undefined;
            item.previous = this._tail;
            this._tail.next = item;
            this._tail = item;
            this._state++;
        }
    }
    toJSON() {
        const data = [];
        this.forEach((value, key) => {
            data.push([key, value]);
        });
        return data;
    }
    fromJSON(data) {
        this.clear();
        for (const [key, value] of data) {
            this.set(key, value);
        }
    }
}
exports.LinkedMap = LinkedMap;
class LRUCache extends LinkedMap {
    constructor(limit, ratio = 1) {
        super();
        this._limit = limit;
        this._ratio = Math.min(Math.max(0, ratio), 1);
    }
    get limit() {
        return this._limit;
    }
    set limit(limit) {
        this._limit = limit;
        this.checkTrim();
    }
    get ratio() {
        return this._ratio;
    }
    set ratio(ratio) {
        this._ratio = Math.min(Math.max(0, ratio), 1);
        this.checkTrim();
    }
    get(key, touch = Touch.AsNew) {
        return super.get(key, touch);
    }
    peek(key) {
        return super.get(key, Touch.None);
    }
    set(key, value) {
        super.set(key, value, Touch.Last);
        this.checkTrim();
        return this;
    }
    checkTrim() {
        if (this.size > this._limit) {
            this.trimOld(Math.round(this._limit * this._ratio));
        }
    }
}
exports.LRUCache = LRUCache;
//# sourceMappingURL=linkedMap.js.map

/***/ }),
/* 146 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Emitter = exports.Event = void 0;
const ral_1 = __webpack_require__(138);
var Event;
(function (Event) {
    const _disposable = { dispose() { } };
    Event.None = function () { return _disposable; };
})(Event = exports.Event || (exports.Event = {}));
class CallbackList {
    add(callback, context = null, bucket) {
        if (!this._callbacks) {
            this._callbacks = [];
            this._contexts = [];
        }
        this._callbacks.push(callback);
        this._contexts.push(context);
        if (Array.isArray(bucket)) {
            bucket.push({ dispose: () => this.remove(callback, context) });
        }
    }
    remove(callback, context = null) {
        if (!this._callbacks) {
            return;
        }
        let foundCallbackWithDifferentContext = false;
        for (let i = 0, len = this._callbacks.length; i < len; i++) {
            if (this._callbacks[i] === callback) {
                if (this._contexts[i] === context) {
                    // callback & context match => remove it
                    this._callbacks.splice(i, 1);
                    this._contexts.splice(i, 1);
                    return;
                }
                else {
                    foundCallbackWithDifferentContext = true;
                }
            }
        }
        if (foundCallbackWithDifferentContext) {
            throw new Error('When adding a listener with a context, you should remove it with the same context');
        }
    }
    invoke(...args) {
        if (!this._callbacks) {
            return [];
        }
        const ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);
        for (let i = 0, len = callbacks.length; i < len; i++) {
            try {
                ret.push(callbacks[i].apply(contexts[i], args));
            }
            catch (e) {
                // eslint-disable-next-line no-console
                ral_1.default().console.error(e);
            }
        }
        return ret;
    }
    isEmpty() {
        return !this._callbacks || this._callbacks.length === 0;
    }
    dispose() {
        this._callbacks = undefined;
        this._contexts = undefined;
    }
}
class Emitter {
    constructor(_options) {
        this._options = _options;
    }
    /**
     * For the public to allow to subscribe
     * to events from this Emitter
     */
    get event() {
        if (!this._event) {
            this._event = (listener, thisArgs, disposables) => {
                if (!this._callbacks) {
                    this._callbacks = new CallbackList();
                }
                if (this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty()) {
                    this._options.onFirstListenerAdd(this);
                }
                this._callbacks.add(listener, thisArgs);
                const result = {
                    dispose: () => {
                        if (!this._callbacks) {
                            // disposable is disposed after emitter is disposed.
                            return;
                        }
                        this._callbacks.remove(listener, thisArgs);
                        result.dispose = Emitter._noop;
                        if (this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty()) {
                            this._options.onLastListenerRemove(this);
                        }
                    }
                };
                if (Array.isArray(disposables)) {
                    disposables.push(result);
                }
                return result;
            };
        }
        return this._event;
    }
    /**
     * To be kept private to fire an event to
     * subscribers
     */
    fire(event) {
        if (this._callbacks) {
            this._callbacks.invoke.call(this._callbacks, event);
        }
    }
    dispose() {
        if (this._callbacks) {
            this._callbacks.dispose();
            this._callbacks = undefined;
        }
    }
}
exports.Emitter = Emitter;
Emitter._noop = function () { };
//# sourceMappingURL=events.js.map

/***/ }),
/* 147 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CancellationTokenSource = exports.CancellationToken = void 0;
const ral_1 = __webpack_require__(138);
const Is = __webpack_require__(144);
const events_1 = __webpack_require__(146);
var CancellationToken;
(function (CancellationToken) {
    CancellationToken.None = Object.freeze({
        isCancellationRequested: false,
        onCancellationRequested: events_1.Event.None
    });
    CancellationToken.Cancelled = Object.freeze({
        isCancellationRequested: true,
        onCancellationRequested: events_1.Event.None
    });
    function is(value) {
        const candidate = value;
        return candidate && (candidate === CancellationToken.None
            || candidate === CancellationToken.Cancelled
            || (Is.boolean(candidate.isCancellationRequested) && !!candidate.onCancellationRequested));
    }
    CancellationToken.is = is;
})(CancellationToken = exports.CancellationToken || (exports.CancellationToken = {}));
const shortcutEvent = Object.freeze(function (callback, context) {
    const handle = ral_1.default().timer.setTimeout(callback.bind(context), 0);
    return { dispose() { handle.dispose(); } };
});
class MutableToken {
    constructor() {
        this._isCancelled = false;
    }
    cancel() {
        if (!this._isCancelled) {
            this._isCancelled = true;
            if (this._emitter) {
                this._emitter.fire(undefined);
                this.dispose();
            }
        }
    }
    get isCancellationRequested() {
        return this._isCancelled;
    }
    get onCancellationRequested() {
        if (this._isCancelled) {
            return shortcutEvent;
        }
        if (!this._emitter) {
            this._emitter = new events_1.Emitter();
        }
        return this._emitter.event;
    }
    dispose() {
        if (this._emitter) {
            this._emitter.dispose();
            this._emitter = undefined;
        }
    }
}
class CancellationTokenSource {
    get token() {
        if (!this._token) {
            // be lazy and create the token only when
            // actually needed
            this._token = new MutableToken();
        }
        return this._token;
    }
    cancel() {
        if (!this._token) {
            // save an object by returning the default
            // cancelled token when cancellation happens
            // before someone asks for the token
            this._token = CancellationToken.Cancelled;
        }
        else {
            this._token.cancel();
        }
    }
    dispose() {
        if (!this._token) {
            // ensure to initialize with an empty token if we had none
            this._token = CancellationToken.None;
        }
        else if (this._token instanceof MutableToken) {
            // actually dispose
            this._token.dispose();
        }
    }
}
exports.CancellationTokenSource = CancellationTokenSource;
//# sourceMappingURL=cancellation.js.map

/***/ }),
/* 148 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ReadableStreamMessageReader = exports.AbstractMessageReader = exports.MessageReader = void 0;
const ral_1 = __webpack_require__(138);
const Is = __webpack_require__(144);
const events_1 = __webpack_require__(146);
var MessageReader;
(function (MessageReader) {
    function is(value) {
        let candidate = value;
        return candidate && Is.func(candidate.listen) && Is.func(candidate.dispose) &&
            Is.func(candidate.onError) && Is.func(candidate.onClose) && Is.func(candidate.onPartialMessage);
    }
    MessageReader.is = is;
})(MessageReader = exports.MessageReader || (exports.MessageReader = {}));
class AbstractMessageReader {
    constructor() {
        this.errorEmitter = new events_1.Emitter();
        this.closeEmitter = new events_1.Emitter();
        this.partialMessageEmitter = new events_1.Emitter();
    }
    dispose() {
        this.errorEmitter.dispose();
        this.closeEmitter.dispose();
    }
    get onError() {
        return this.errorEmitter.event;
    }
    fireError(error) {
        this.errorEmitter.fire(this.asError(error));
    }
    get onClose() {
        return this.closeEmitter.event;
    }
    fireClose() {
        this.closeEmitter.fire(undefined);
    }
    get onPartialMessage() {
        return this.partialMessageEmitter.event;
    }
    firePartialMessage(info) {
        this.partialMessageEmitter.fire(info);
    }
    asError(error) {
        if (error instanceof Error) {
            return error;
        }
        else {
            return new Error(`Reader received error. Reason: ${Is.string(error.message) ? error.message : 'unknown'}`);
        }
    }
}
exports.AbstractMessageReader = AbstractMessageReader;
var ResolvedMessageReaderOptions;
(function (ResolvedMessageReaderOptions) {
    function fromOptions(options) {
        var _a;
        let charset;
        let result;
        let contentDecoder;
        const contentDecoders = new Map();
        let contentTypeDecoder;
        const contentTypeDecoders = new Map();
        if (options === undefined || typeof options === 'string') {
            charset = options !== null && options !== void 0 ? options : 'utf-8';
        }
        else {
            charset = (_a = options.charset) !== null && _a !== void 0 ? _a : 'utf-8';
            if (options.contentDecoder !== undefined) {
                contentDecoder = options.contentDecoder;
                contentDecoders.set(contentDecoder.name, contentDecoder);
            }
            if (options.contentDecoders !== undefined) {
                for (const decoder of options.contentDecoders) {
                    contentDecoders.set(decoder.name, decoder);
                }
            }
            if (options.contentTypeDecoder !== undefined) {
                contentTypeDecoder = options.contentTypeDecoder;
                contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
            }
            if (options.contentTypeDecoders !== undefined) {
                for (const decoder of options.contentTypeDecoders) {
                    contentTypeDecoders.set(decoder.name, decoder);
                }
            }
        }
        if (contentTypeDecoder === undefined) {
            contentTypeDecoder = ral_1.default().applicationJson.decoder;
            contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
        }
        return { charset, contentDecoder, contentDecoders, contentTypeDecoder, contentTypeDecoders };
    }
    ResolvedMessageReaderOptions.fromOptions = fromOptions;
})(ResolvedMessageReaderOptions || (ResolvedMessageReaderOptions = {}));
class ReadableStreamMessageReader extends AbstractMessageReader {
    constructor(readable, options) {
        super();
        this.readable = readable;
        this.options = ResolvedMessageReaderOptions.fromOptions(options);
        this.buffer = ral_1.default().messageBuffer.create(this.options.charset);
        this._partialMessageTimeout = 10000;
        this.nextMessageLength = -1;
        this.messageToken = 0;
    }
    set partialMessageTimeout(timeout) {
        this._partialMessageTimeout = timeout;
    }
    get partialMessageTimeout() {
        return this._partialMessageTimeout;
    }
    listen(callback) {
        this.nextMessageLength = -1;
        this.messageToken = 0;
        this.partialMessageTimer = undefined;
        this.callback = callback;
        const result = this.readable.onData((data) => {
            this.onData(data);
        });
        this.readable.onError((error) => this.fireError(error));
        this.readable.onClose(() => this.fireClose());
        return result;
    }
    onData(data) {
        this.buffer.append(data);
        while (true) {
            if (this.nextMessageLength === -1) {
                const headers = this.buffer.tryReadHeaders();
                if (!headers) {
                    return;
                }
                const contentLength = headers.get('Content-Length');
                if (!contentLength) {
                    throw new Error('Header must provide a Content-Length property.');
                }
                const length = parseInt(contentLength);
                if (isNaN(length)) {
                    throw new Error('Content-Length value must be a number.');
                }
                this.nextMessageLength = length;
            }
            const body = this.buffer.tryReadBody(this.nextMessageLength);
            if (body === undefined) {
                /** We haven't received the full message yet. */
                this.setPartialMessageTimer();
                return;
            }
            this.clearPartialMessageTimer();
            this.nextMessageLength = -1;
            let p;
            if (this.options.contentDecoder !== undefined) {
                p = this.options.contentDecoder.decode(body);
            }
            else {
                p = Promise.resolve(body);
            }
            p.then((value) => {
                this.options.contentTypeDecoder.decode(value, this.options).then((msg) => {
                    this.callback(msg);
                }, (error) => {
                    this.fireError(error);
                });
            }, (error) => {
                this.fireError(error);
            });
        }
    }
    clearPartialMessageTimer() {
        if (this.partialMessageTimer) {
            this.partialMessageTimer.dispose();
            this.partialMessageTimer = undefined;
        }
    }
    setPartialMessageTimer() {
        this.clearPartialMessageTimer();
        if (this._partialMessageTimeout <= 0) {
            return;
        }
        this.partialMessageTimer = ral_1.default().timer.setTimeout((token, timeout) => {
            this.partialMessageTimer = undefined;
            if (token === this.messageToken) {
                this.firePartialMessage({ messageToken: token, waitingTime: timeout });
                this.setPartialMessageTimer();
            }
        }, this._partialMessageTimeout, this.messageToken, this._partialMessageTimeout);
    }
}
exports.ReadableStreamMessageReader = ReadableStreamMessageReader;
//# sourceMappingURL=messageReader.js.map

/***/ }),
/* 149 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WriteableStreamMessageWriter = exports.AbstractMessageWriter = exports.MessageWriter = void 0;
const ral_1 = __webpack_require__(138);
const Is = __webpack_require__(144);
const semaphore_1 = __webpack_require__(150);
const events_1 = __webpack_require__(146);
const ContentLength = 'Content-Length: ';
const CRLF = '\r\n';
var MessageWriter;
(function (MessageWriter) {
    function is(value) {
        let candidate = value;
        return candidate && Is.func(candidate.dispose) && Is.func(candidate.onClose) &&
            Is.func(candidate.onError) && Is.func(candidate.write);
    }
    MessageWriter.is = is;
})(MessageWriter = exports.MessageWriter || (exports.MessageWriter = {}));
class AbstractMessageWriter {
    constructor() {
        this.errorEmitter = new events_1.Emitter();
        this.closeEmitter = new events_1.Emitter();
    }
    dispose() {
        this.errorEmitter.dispose();
        this.closeEmitter.dispose();
    }
    get onError() {
        return this.errorEmitter.event;
    }
    fireError(error, message, count) {
        this.errorEmitter.fire([this.asError(error), message, count]);
    }
    get onClose() {
        return this.closeEmitter.event;
    }
    fireClose() {
        this.closeEmitter.fire(undefined);
    }
    asError(error) {
        if (error instanceof Error) {
            return error;
        }
        else {
            return new Error(`Writer received error. Reason: ${Is.string(error.message) ? error.message : 'unknown'}`);
        }
    }
}
exports.AbstractMessageWriter = AbstractMessageWriter;
var ResolvedMessageWriterOptions;
(function (ResolvedMessageWriterOptions) {
    function fromOptions(options) {
        var _a, _b;
        if (options === undefined || typeof options === 'string') {
            return { charset: options !== null && options !== void 0 ? options : 'utf-8', contentTypeEncoder: ral_1.default().applicationJson.encoder };
        }
        else {
            return { charset: (_a = options.charset) !== null && _a !== void 0 ? _a : 'utf-8', contentEncoder: options.contentEncoder, contentTypeEncoder: (_b = options.contentTypeEncoder) !== null && _b !== void 0 ? _b : ral_1.default().applicationJson.encoder };
        }
    }
    ResolvedMessageWriterOptions.fromOptions = fromOptions;
})(ResolvedMessageWriterOptions || (ResolvedMessageWriterOptions = {}));
class WriteableStreamMessageWriter extends AbstractMessageWriter {
    constructor(writable, options) {
        super();
        this.writable = writable;
        this.options = ResolvedMessageWriterOptions.fromOptions(options);
        this.errorCount = 0;
        this.writeSemaphore = new semaphore_1.Semaphore(1);
        this.writable.onError((error) => this.fireError(error));
        this.writable.onClose(() => this.fireClose());
    }
    async write(msg) {
        return this.writeSemaphore.lock(async () => {
            const payload = this.options.contentTypeEncoder.encode(msg, this.options).then((buffer) => {
                if (this.options.contentEncoder !== undefined) {
                    return this.options.contentEncoder.encode(buffer);
                }
                else {
                    return buffer;
                }
            });
            return payload.then((buffer) => {
                const headers = [];
                headers.push(ContentLength, buffer.byteLength.toString(), CRLF);
                headers.push(CRLF);
                return this.doWrite(msg, headers, buffer);
            }, (error) => {
                this.fireError(error);
                throw error;
            });
        });
    }
    async doWrite(msg, headers, data) {
        try {
            await this.writable.write(headers.join(''), 'ascii');
            return this.writable.write(data);
        }
        catch (error) {
            this.handleError(error, msg);
            return Promise.reject(error);
        }
    }
    handleError(error, msg) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
    }
    end() {
        this.writable.end();
    }
}
exports.WriteableStreamMessageWriter = WriteableStreamMessageWriter;
//# sourceMappingURL=messageWriter.js.map

/***/ }),
/* 150 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Semaphore = void 0;
const ral_1 = __webpack_require__(138);
class Semaphore {
    constructor(capacity = 1) {
        if (capacity <= 0) {
            throw new Error('Capacity must be greater than 0');
        }
        this._capacity = capacity;
        this._active = 0;
        this._waiting = [];
    }
    lock(thunk) {
        return new Promise((resolve, reject) => {
            this._waiting.push({ thunk, resolve, reject });
            this.runNext();
        });
    }
    get active() {
        return this._active;
    }
    runNext() {
        if (this._waiting.length === 0 || this._active === this._capacity) {
            return;
        }
        ral_1.default().timer.setImmediate(() => this.doRunNext());
    }
    doRunNext() {
        if (this._waiting.length === 0 || this._active === this._capacity) {
            return;
        }
        const next = this._waiting.shift();
        this._active++;
        if (this._active > this._capacity) {
            throw new Error(`To many thunks active`);
        }
        try {
            const result = next.thunk();
            if (result instanceof Promise) {
                result.then((value) => {
                    this._active--;
                    next.resolve(value);
                    this.runNext();
                }, (err) => {
                    this._active--;
                    next.reject(err);
                    this.runNext();
                });
            }
            else {
                this._active--;
                next.resolve(result);
                this.runNext();
            }
        }
        catch (err) {
            this._active--;
            next.reject(err);
            this.runNext();
        }
    }
}
exports.Semaphore = Semaphore;
//# sourceMappingURL=semaphore.js.map

/***/ }),
/* 151 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createMessageConnection = exports.ConnectionOptions = exports.CancellationStrategy = exports.CancellationSenderStrategy = exports.CancellationReceiverStrategy = exports.ConnectionStrategy = exports.ConnectionError = exports.ConnectionErrors = exports.LogTraceNotification = exports.SetTraceNotification = exports.TraceFormat = exports.Trace = exports.NullLogger = exports.ProgressType = void 0;
const ral_1 = __webpack_require__(138);
const Is = __webpack_require__(144);
const messages_1 = __webpack_require__(143);
const linkedMap_1 = __webpack_require__(145);
const events_1 = __webpack_require__(146);
const cancellation_1 = __webpack_require__(147);
var CancelNotification;
(function (CancelNotification) {
    CancelNotification.type = new messages_1.NotificationType('$/cancelRequest');
})(CancelNotification || (CancelNotification = {}));
var ProgressNotification;
(function (ProgressNotification) {
    ProgressNotification.type = new messages_1.NotificationType('$/progress');
})(ProgressNotification || (ProgressNotification = {}));
class ProgressType {
    constructor() {
    }
}
exports.ProgressType = ProgressType;
var StarRequestHandler;
(function (StarRequestHandler) {
    function is(value) {
        return Is.func(value);
    }
    StarRequestHandler.is = is;
})(StarRequestHandler || (StarRequestHandler = {}));
exports.NullLogger = Object.freeze({
    error: () => { },
    warn: () => { },
    info: () => { },
    log: () => { }
});
var Trace;
(function (Trace) {
    Trace[Trace["Off"] = 0] = "Off";
    Trace[Trace["Messages"] = 1] = "Messages";
    Trace[Trace["Verbose"] = 2] = "Verbose";
})(Trace = exports.Trace || (exports.Trace = {}));
(function (Trace) {
    function fromString(value) {
        if (!Is.string(value)) {
            return Trace.Off;
        }
        value = value.toLowerCase();
        switch (value) {
            case 'off':
                return Trace.Off;
            case 'messages':
                return Trace.Messages;
            case 'verbose':
                return Trace.Verbose;
            default:
                return Trace.Off;
        }
    }
    Trace.fromString = fromString;
    function toString(value) {
        switch (value) {
            case Trace.Off:
                return 'off';
            case Trace.Messages:
                return 'messages';
            case Trace.Verbose:
                return 'verbose';
            default:
                return 'off';
        }
    }
    Trace.toString = toString;
})(Trace = exports.Trace || (exports.Trace = {}));
var TraceFormat;
(function (TraceFormat) {
    TraceFormat["Text"] = "text";
    TraceFormat["JSON"] = "json";
})(TraceFormat = exports.TraceFormat || (exports.TraceFormat = {}));
(function (TraceFormat) {
    function fromString(value) {
        if (!Is.string(value)) {
            return TraceFormat.Text;
        }
        value = value.toLowerCase();
        if (value === 'json') {
            return TraceFormat.JSON;
        }
        else {
            return TraceFormat.Text;
        }
    }
    TraceFormat.fromString = fromString;
})(TraceFormat = exports.TraceFormat || (exports.TraceFormat = {}));
var SetTraceNotification;
(function (SetTraceNotification) {
    SetTraceNotification.type = new messages_1.NotificationType('$/setTrace');
})(SetTraceNotification = exports.SetTraceNotification || (exports.SetTraceNotification = {}));
var LogTraceNotification;
(function (LogTraceNotification) {
    LogTraceNotification.type = new messages_1.NotificationType('$/logTrace');
})(LogTraceNotification = exports.LogTraceNotification || (exports.LogTraceNotification = {}));
var ConnectionErrors;
(function (ConnectionErrors) {
    /**
     * The connection is closed.
     */
    ConnectionErrors[ConnectionErrors["Closed"] = 1] = "Closed";
    /**
     * The connection got disposed.
     */
    ConnectionErrors[ConnectionErrors["Disposed"] = 2] = "Disposed";
    /**
     * The connection is already in listening mode.
     */
    ConnectionErrors[ConnectionErrors["AlreadyListening"] = 3] = "AlreadyListening";
})(ConnectionErrors = exports.ConnectionErrors || (exports.ConnectionErrors = {}));
class ConnectionError extends Error {
    constructor(code, message) {
        super(message);
        this.code = code;
        Object.setPrototypeOf(this, ConnectionError.prototype);
    }
}
exports.ConnectionError = ConnectionError;
var ConnectionStrategy;
(function (ConnectionStrategy) {
    function is(value) {
        const candidate = value;
        return candidate && Is.func(candidate.cancelUndispatched);
    }
    ConnectionStrategy.is = is;
})(ConnectionStrategy = exports.ConnectionStrategy || (exports.ConnectionStrategy = {}));
var CancellationReceiverStrategy;
(function (CancellationReceiverStrategy) {
    CancellationReceiverStrategy.Message = Object.freeze({
        createCancellationTokenSource(_) {
            return new cancellation_1.CancellationTokenSource();
        }
    });
    function is(value) {
        const candidate = value;
        return candidate && Is.func(candidate.createCancellationTokenSource);
    }
    CancellationReceiverStrategy.is = is;
})(CancellationReceiverStrategy = exports.CancellationReceiverStrategy || (exports.CancellationReceiverStrategy = {}));
var CancellationSenderStrategy;
(function (CancellationSenderStrategy) {
    CancellationSenderStrategy.Message = Object.freeze({
        sendCancellation(conn, id) {
            conn.sendNotification(CancelNotification.type, { id });
        },
        cleanup(_) { }
    });
    function is(value) {
        const candidate = value;
        return candidate && Is.func(candidate.sendCancellation) && Is.func(candidate.cleanup);
    }
    CancellationSenderStrategy.is = is;
})(CancellationSenderStrategy = exports.CancellationSenderStrategy || (exports.CancellationSenderStrategy = {}));
var CancellationStrategy;
(function (CancellationStrategy) {
    CancellationStrategy.Message = Object.freeze({
        receiver: CancellationReceiverStrategy.Message,
        sender: CancellationSenderStrategy.Message
    });
    function is(value) {
        const candidate = value;
        return candidate && CancellationReceiverStrategy.is(candidate.receiver) && CancellationSenderStrategy.is(candidate.sender);
    }
    CancellationStrategy.is = is;
})(CancellationStrategy = exports.CancellationStrategy || (exports.CancellationStrategy = {}));
var ConnectionOptions;
(function (ConnectionOptions) {
    function is(value) {
        const candidate = value;
        return candidate && (CancellationStrategy.is(candidate.cancellationStrategy) || ConnectionStrategy.is(candidate.connectionStrategy));
    }
    ConnectionOptions.is = is;
})(ConnectionOptions = exports.ConnectionOptions || (exports.ConnectionOptions = {}));
var ConnectionState;
(function (ConnectionState) {
    ConnectionState[ConnectionState["New"] = 1] = "New";
    ConnectionState[ConnectionState["Listening"] = 2] = "Listening";
    ConnectionState[ConnectionState["Closed"] = 3] = "Closed";
    ConnectionState[ConnectionState["Disposed"] = 4] = "Disposed";
})(ConnectionState || (ConnectionState = {}));
function createMessageConnection(messageReader, messageWriter, _logger, options) {
    const logger = _logger !== undefined ? _logger : exports.NullLogger;
    let sequenceNumber = 0;
    let notificationSequenceNumber = 0;
    let unknownResponseSequenceNumber = 0;
    const version = '2.0';
    let starRequestHandler = undefined;
    const requestHandlers = Object.create(null);
    let starNotificationHandler = undefined;
    const notificationHandlers = Object.create(null);
    const progressHandlers = new Map();
    let timer;
    let messageQueue = new linkedMap_1.LinkedMap();
    let responsePromises = Object.create(null);
    let knownCanceledRequests = new Set();
    let requestTokens = Object.create(null);
    let trace = Trace.Off;
    let traceFormat = TraceFormat.Text;
    let tracer;
    let state = ConnectionState.New;
    const errorEmitter = new events_1.Emitter();
    const closeEmitter = new events_1.Emitter();
    const unhandledNotificationEmitter = new events_1.Emitter();
    const unhandledProgressEmitter = new events_1.Emitter();
    const disposeEmitter = new events_1.Emitter();
    const cancellationStrategy = (options && options.cancellationStrategy) ? options.cancellationStrategy : CancellationStrategy.Message;
    function createRequestQueueKey(id) {
        if (id === null) {
            throw new Error(`Can't send requests with id null since the response can't be correlated.`);
        }
        return 'req-' + id.toString();
    }
    function createResponseQueueKey(id) {
        if (id === null) {
            return 'res-unknown-' + (++unknownResponseSequenceNumber).toString();
        }
        else {
            return 'res-' + id.toString();
        }
    }
    function createNotificationQueueKey() {
        return 'not-' + (++notificationSequenceNumber).toString();
    }
    function addMessageToQueue(queue, message) {
        if (messages_1.isRequestMessage(message)) {
            queue.set(createRequestQueueKey(message.id), message);
        }
        else if (messages_1.isResponseMessage(message)) {
            queue.set(createResponseQueueKey(message.id), message);
        }
        else {
            queue.set(createNotificationQueueKey(), message);
        }
    }
    function cancelUndispatched(_message) {
        return undefined;
    }
    function isListening() {
        return state === ConnectionState.Listening;
    }
    function isClosed() {
        return state === ConnectionState.Closed;
    }
    function isDisposed() {
        return state === ConnectionState.Disposed;
    }
    function closeHandler() {
        if (state === ConnectionState.New || state === ConnectionState.Listening) {
            state = ConnectionState.Closed;
            closeEmitter.fire(undefined);
        }
        // If the connection is disposed don't sent close events.
    }
    function readErrorHandler(error) {
        errorEmitter.fire([error, undefined, undefined]);
    }
    function writeErrorHandler(data) {
        errorEmitter.fire(data);
    }
    messageReader.onClose(closeHandler);
    messageReader.onError(readErrorHandler);
    messageWriter.onClose(closeHandler);
    messageWriter.onError(writeErrorHandler);
    function triggerMessageQueue() {
        if (timer || messageQueue.size === 0) {
            return;
        }
        timer = ral_1.default().timer.setImmediate(() => {
            timer = undefined;
            processMessageQueue();
        });
    }
    function processMessageQueue() {
        if (messageQueue.size === 0) {
            return;
        }
        const message = messageQueue.shift();
        try {
            if (messages_1.isRequestMessage(message)) {
                handleRequest(message);
            }
            else if (messages_1.isNotificationMessage(message)) {
                handleNotification(message);
            }
            else if (messages_1.isResponseMessage(message)) {
                handleResponse(message);
            }
            else {
                handleInvalidMessage(message);
            }
        }
        finally {
            triggerMessageQueue();
        }
    }
    const callback = (message) => {
        try {
            // We have received a cancellation message. Check if the message is still in the queue
            // and cancel it if allowed to do so.
            if (messages_1.isNotificationMessage(message) && message.method === CancelNotification.type.method) {
                const cancelId = message.params.id;
                const key = createRequestQueueKey(cancelId);
                const toCancel = messageQueue.get(key);
                if (messages_1.isRequestMessage(toCancel)) {
                    const strategy = options === null || options === void 0 ? void 0 : options.connectionStrategy;
                    const response = (strategy && strategy.cancelUndispatched) ? strategy.cancelUndispatched(toCancel, cancelUndispatched) : cancelUndispatched(toCancel);
                    if (response && (response.error !== undefined || response.result !== undefined)) {
                        messageQueue.delete(key);
                        response.id = toCancel.id;
                        traceSendingResponse(response, message.method, Date.now());
                        messageWriter.write(response);
                        return;
                    }
                }
                const tokenKey = String(cancelId);
                const cancellationToken = requestTokens[tokenKey];
                // The request is already running. Cancel the token
                if (cancellationToken !== undefined) {
                    cancellationToken.cancel();
                    traceReceivedNotification(message);
                    return;
                }
                else {
                    // Remember the cancel but still queue the message to
                    // clean up state in process message.
                    knownCanceledRequests.add(cancelId);
                }
            }
            addMessageToQueue(messageQueue, message);
        }
        finally {
            triggerMessageQueue();
        }
    };
    function handleRequest(requestMessage) {
        if (isDisposed()) {
            // we return here silently since we fired an event when the
            // connection got disposed.
            return;
        }
        function reply(resultOrError, method, startTime) {
            const message = {
                jsonrpc: version,
                id: requestMessage.id
            };
            if (resultOrError instanceof messages_1.ResponseError) {
                message.error = resultOrError.toJson();
            }
            else {
                message.result = resultOrError === undefined ? null : resultOrError;
            }
            traceSendingResponse(message, method, startTime);
            messageWriter.write(message);
        }
        function replyError(error, method, startTime) {
            const message = {
                jsonrpc: version,
                id: requestMessage.id,
                error: error.toJson()
            };
            traceSendingResponse(message, method, startTime);
            messageWriter.write(message);
        }
        function replySuccess(result, method, startTime) {
            // The JSON RPC defines that a response must either have a result or an error
            // So we can't treat undefined as a valid response result.
            if (result === undefined) {
                result = null;
            }
            const message = {
                jsonrpc: version,
                id: requestMessage.id,
                result: result
            };
            traceSendingResponse(message, method, startTime);
            messageWriter.write(message);
        }
        traceReceivedRequest(requestMessage);
        const element = requestHandlers[requestMessage.method];
        let type;
        let requestHandler;
        if (element) {
            type = element.type;
            requestHandler = element.handler;
        }
        const startTime = Date.now();
        if (requestHandler || starRequestHandler) {
            const tokenKey = String(requestMessage.id);
            const cancellationSource = cancellationStrategy.receiver.createCancellationTokenSource(tokenKey);
            if (requestMessage.id !== null && knownCanceledRequests.has(requestMessage.id)) {
                cancellationSource.cancel();
            }
            requestTokens[tokenKey] = cancellationSource;
            try {
                let handlerResult;
                if (requestHandler) {
                    if (requestMessage.params === undefined) {
                        if (type !== undefined && type.numberOfParams !== 0) {
                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines ${type.numberOfParams} params but received none.`), requestMessage.method, startTime);
                            return;
                        }
                        handlerResult = requestHandler(cancellationSource.token);
                    }
                    else if (Array.isArray(requestMessage.params)) {
                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byName) {
                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by name but received parameters by position`), requestMessage.method, startTime);
                            return;
                        }
                        handlerResult = requestHandler(...requestMessage.params, cancellationSource.token);
                    }
                    else {
                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by position but received parameters by name`), requestMessage.method, startTime);
                            return;
                        }
                        handlerResult = requestHandler(requestMessage.params, cancellationSource.token);
                    }
                }
                else if (starRequestHandler) {
                    handlerResult = starRequestHandler(requestMessage.method, requestMessage.params, cancellationSource.token);
                }
                const promise = handlerResult;
                if (!handlerResult) {
                    delete requestTokens[tokenKey];
                    replySuccess(handlerResult, requestMessage.method, startTime);
                }
                else if (promise.then) {
                    promise.then((resultOrError) => {
                        delete requestTokens[tokenKey];
                        reply(resultOrError, requestMessage.method, startTime);
                    }, error => {
                        delete requestTokens[tokenKey];
                        if (error instanceof messages_1.ResponseError) {
                            replyError(error, requestMessage.method, startTime);
                        }
                        else if (error && Is.string(error.message)) {
                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
                        }
                        else {
                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
                        }
                    });
                }
                else {
                    delete requestTokens[tokenKey];
                    reply(handlerResult, requestMessage.method, startTime);
                }
            }
            catch (error) {
                delete requestTokens[tokenKey];
                if (error instanceof messages_1.ResponseError) {
                    reply(error, requestMessage.method, startTime);
                }
                else if (error && Is.string(error.message)) {
                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
                }
                else {
                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
                }
            }
        }
        else {
            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.MethodNotFound, `Unhandled method ${requestMessage.method}`), requestMessage.method, startTime);
        }
    }
    function handleResponse(responseMessage) {
        if (isDisposed()) {
            // See handle request.
            return;
        }
        if (responseMessage.id === null) {
            if (responseMessage.error) {
                logger.error(`Received response message without id: Error is: \n${JSON.stringify(responseMessage.error, undefined, 4)}`);
            }
            else {
                logger.error(`Received response message without id. No further error information provided.`);
            }
        }
        else {
            const key = String(responseMessage.id);
            const responsePromise = responsePromises[key];
            traceReceivedResponse(responseMessage, responsePromise);
            if (responsePromise) {
                delete responsePromises[key];
                try {
                    if (responseMessage.error) {
                        const error = responseMessage.error;
                        responsePromise.reject(new messages_1.ResponseError(error.code, error.message, error.data));
                    }
                    else if (responseMessage.result !== undefined) {
                        responsePromise.resolve(responseMessage.result);
                    }
                    else {
                        throw new Error('Should never happen.');
                    }
                }
                catch (error) {
                    if (error.message) {
                        logger.error(`Response handler '${responsePromise.method}' failed with message: ${error.message}`);
                    }
                    else {
                        logger.error(`Response handler '${responsePromise.method}' failed unexpectedly.`);
                    }
                }
            }
        }
    }
    function handleNotification(message) {
        if (isDisposed()) {
            // See handle request.
            return;
        }
        let type = undefined;
        let notificationHandler;
        if (message.method === CancelNotification.type.method) {
            const cancelId = message.params.id;
            knownCanceledRequests.delete(cancelId);
            traceReceivedNotification(message);
            return;
        }
        else {
            const element = notificationHandlers[message.method];
            if (element) {
                notificationHandler = element.handler;
                type = element.type;
            }
        }
        if (notificationHandler || starNotificationHandler) {
            try {
                traceReceivedNotification(message);
                if (notificationHandler) {
                    if (message.params === undefined) {
                        if (type !== undefined) {
                            if (type.numberOfParams !== 0 && type.parameterStructures !== messages_1.ParameterStructures.byName) {
                                logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received none.`);
                            }
                        }
                        notificationHandler();
                    }
                    else if (Array.isArray(message.params)) {
                        if (type !== undefined) {
                            if (type.parameterStructures === messages_1.ParameterStructures.byName) {
                                logger.error(`Notification ${message.method} defines parameters by name but received parameters by position`);
                            }
                            if (type.numberOfParams !== message.params.length) {
                                logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received ${message.params.length} arguments`);
                            }
                        }
                        notificationHandler(...message.params);
                    }
                    else {
                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                            logger.error(`Notification ${message.method} defines parameters by position but received parameters by name`);
                        }
                        notificationHandler(message.params);
                    }
                }
                else if (starNotificationHandler) {
                    starNotificationHandler(message.method, message.params);
                }
            }
            catch (error) {
                if (error.message) {
                    logger.error(`Notification handler '${message.method}' failed with message: ${error.message}`);
                }
                else {
                    logger.error(`Notification handler '${message.method}' failed unexpectedly.`);
                }
            }
        }
        else {
            unhandledNotificationEmitter.fire(message);
        }
    }
    function handleInvalidMessage(message) {
        if (!message) {
            logger.error('Received empty message.');
            return;
        }
        logger.error(`Received message which is neither a response nor a notification message:\n${JSON.stringify(message, null, 4)}`);
        // Test whether we find an id to reject the promise
        const responseMessage = message;
        if (Is.string(responseMessage.id) || Is.number(responseMessage.id)) {
            const key = String(responseMessage.id);
            const responseHandler = responsePromises[key];
            if (responseHandler) {
                responseHandler.reject(new Error('The received response has neither a result nor an error property.'));
            }
        }
    }
    function traceSendingRequest(message) {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if (trace === Trace.Verbose && message.params) {
                data = `Params: ${JSON.stringify(message.params, null, 4)}\n\n`;
            }
            tracer.log(`Sending request '${message.method} - (${message.id})'.`, data);
        }
        else {
            logLSPMessage('send-request', message);
        }
    }
    function traceSendingNotification(message) {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if (trace === Trace.Verbose) {
                if (message.params) {
                    data = `Params: ${JSON.stringify(message.params, null, 4)}\n\n`;
                }
                else {
                    data = 'No parameters provided.\n\n';
                }
            }
            tracer.log(`Sending notification '${message.method}'.`, data);
        }
        else {
            logLSPMessage('send-notification', message);
        }
    }
    function traceSendingResponse(message, method, startTime) {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if (trace === Trace.Verbose) {
                if (message.error && message.error.data) {
                    data = `Error data: ${JSON.stringify(message.error.data, null, 4)}\n\n`;
                }
                else {
                    if (message.result) {
                        data = `Result: ${JSON.stringify(message.result, null, 4)}\n\n`;
                    }
                    else if (message.error === undefined) {
                        data = 'No result returned.\n\n';
                    }
                }
            }
            tracer.log(`Sending response '${method} - (${message.id})'. Processing request took ${Date.now() - startTime}ms`, data);
        }
        else {
            logLSPMessage('send-response', message);
        }
    }
    function traceReceivedRequest(message) {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if (trace === Trace.Verbose && message.params) {
                data = `Params: ${JSON.stringify(message.params, null, 4)}\n\n`;
            }
            tracer.log(`Received request '${message.method} - (${message.id})'.`, data);
        }
        else {
            logLSPMessage('receive-request', message);
        }
    }
    function traceReceivedNotification(message) {
        if (trace === Trace.Off || !tracer || message.method === LogTraceNotification.type.method) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if (trace === Trace.Verbose) {
                if (message.params) {
                    data = `Params: ${JSON.stringify(message.params, null, 4)}\n\n`;
                }
                else {
                    data = 'No parameters provided.\n\n';
                }
            }
            tracer.log(`Received notification '${message.method}'.`, data);
        }
        else {
            logLSPMessage('receive-notification', message);
        }
    }
    function traceReceivedResponse(message, responsePromise) {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if (trace === Trace.Verbose) {
                if (message.error && message.error.data) {
                    data = `Error data: ${JSON.stringify(message.error.data, null, 4)}\n\n`;
                }
                else {
                    if (message.result) {
                        data = `Result: ${JSON.stringify(message.result, null, 4)}\n\n`;
                    }
                    else if (message.error === undefined) {
                        data = 'No result returned.\n\n';
                    }
                }
            }
            if (responsePromise) {
                const error = message.error ? ` Request failed: ${message.error.message} (${message.error.code}).` : '';
                tracer.log(`Received response '${responsePromise.method} - (${message.id})' in ${Date.now() - responsePromise.timerStart}ms.${error}`, data);
            }
            else {
                tracer.log(`Received response ${message.id} without active response promise.`, data);
            }
        }
        else {
            logLSPMessage('receive-response', message);
        }
    }
    function logLSPMessage(type, message) {
        if (!tracer || trace === Trace.Off) {
            return;
        }
        const lspMessage = {
            isLSPMessage: true,
            type,
            message,
            timestamp: Date.now()
        };
        tracer.log(lspMessage);
    }
    function throwIfClosedOrDisposed() {
        if (isClosed()) {
            throw new ConnectionError(ConnectionErrors.Closed, 'Connection is closed.');
        }
        if (isDisposed()) {
            throw new ConnectionError(ConnectionErrors.Disposed, 'Connection is disposed.');
        }
    }
    function throwIfListening() {
        if (isListening()) {
            throw new ConnectionError(ConnectionErrors.AlreadyListening, 'Connection is already listening');
        }
    }
    function throwIfNotListening() {
        if (!isListening()) {
            throw new Error('Call listen() first.');
        }
    }
    function undefinedToNull(param) {
        if (param === undefined) {
            return null;
        }
        else {
            return param;
        }
    }
    function nullToUndefined(param) {
        if (param === null) {
            return undefined;
        }
        else {
            return param;
        }
    }
    function isNamedParam(param) {
        return param !== undefined && param !== null && !Array.isArray(param) && typeof param === 'object';
    }
    function computeSingleParam(parameterStructures, param) {
        switch (parameterStructures) {
            case messages_1.ParameterStructures.auto:
                if (isNamedParam(param)) {
                    return nullToUndefined(param);
                }
                else {
                    return [undefinedToNull(param)];
                }
            case messages_1.ParameterStructures.byName:
                if (!isNamedParam(param)) {
                    throw new Error(`Received parameters by name but param is not an object literal.`);
                }
                return nullToUndefined(param);
            case messages_1.ParameterStructures.byPosition:
                return [undefinedToNull(param)];
            default:
                throw new Error(`Unknown parameter structure ${parameterStructures.toString()}`);
        }
    }
    function computeMessageParams(type, params) {
        let result;
        const numberOfParams = type.numberOfParams;
        switch (numberOfParams) {
            case 0:
                result = undefined;
                break;
            case 1:
                result = computeSingleParam(type.parameterStructures, params[0]);
                break;
            default:
                result = [];
                for (let i = 0; i < params.length && i < numberOfParams; i++) {
                    result.push(undefinedToNull(params[i]));
                }
                if (params.length < numberOfParams) {
                    for (let i = params.length; i < numberOfParams; i++) {
                        result.push(null);
                    }
                }
                break;
        }
        return result;
    }
    const connection = {
        sendNotification: (type, ...args) => {
            throwIfClosedOrDisposed();
            let method;
            let messageParams;
            if (Is.string(type)) {
                method = type;
                const first = args[0];
                let paramStart = 0;
                let parameterStructures = messages_1.ParameterStructures.auto;
                if (messages_1.ParameterStructures.is(first)) {
                    paramStart = 1;
                    parameterStructures = first;
                }
                let paramEnd = args.length;
                const numberOfParams = paramEnd - paramStart;
                switch (numberOfParams) {
                    case 0:
                        messageParams = undefined;
                        break;
                    case 1:
                        messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                        break;
                    default:
                        if (parameterStructures === messages_1.ParameterStructures.byName) {
                            throw new Error(`Received ${numberOfParams} parameters for 'by Name' notification parameter structure.`);
                        }
                        messageParams = args.slice(paramStart, paramEnd).map(value => undefinedToNull(value));
                        break;
                }
            }
            else {
                const params = args;
                method = type.method;
                messageParams = computeMessageParams(type, params);
            }
            const notificationMessage = {
                jsonrpc: version,
                method: method,
                params: messageParams
            };
            traceSendingNotification(notificationMessage);
            messageWriter.write(notificationMessage);
        },
        onNotification: (type, handler) => {
            throwIfClosedOrDisposed();
            let method;
            if (Is.func(type)) {
                starNotificationHandler = type;
            }
            else if (handler) {
                if (Is.string(type)) {
                    method = type;
                    notificationHandlers[type] = { type: undefined, handler };
                }
                else {
                    method = type.method;
                    notificationHandlers[type.method] = { type, handler };
                }
            }
            return {
                dispose: () => {
                    if (method !== undefined) {
                        delete notificationHandlers[method];
                    }
                    else {
                        starNotificationHandler = undefined;
                    }
                }
            };
        },
        onProgress: (_type, token, handler) => {
            if (progressHandlers.has(token)) {
                throw new Error(`Progress handler for token ${token} already registered`);
            }
            progressHandlers.set(token, handler);
            return {
                dispose: () => {
                    progressHandlers.delete(token);
                }
            };
        },
        sendProgress: (_type, token, value) => {
            connection.sendNotification(ProgressNotification.type, { token, value });
        },
        onUnhandledProgress: unhandledProgressEmitter.event,
        sendRequest: (type, ...args) => {
            throwIfClosedOrDisposed();
            throwIfNotListening();
            let method;
            let messageParams;
            let token = undefined;
            if (Is.string(type)) {
                method = type;
                const first = args[0];
                const last = args[args.length - 1];
                let paramStart = 0;
                let parameterStructures = messages_1.ParameterStructures.auto;
                if (messages_1.ParameterStructures.is(first)) {
                    paramStart = 1;
                    parameterStructures = first;
                }
                let paramEnd = args.length;
                if (cancellation_1.CancellationToken.is(last)) {
                    paramEnd = paramEnd - 1;
                    token = last;
                }
                const numberOfParams = paramEnd - paramStart;
                switch (numberOfParams) {
                    case 0:
                        messageParams = undefined;
                        break;
                    case 1:
                        messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                        break;
                    default:
                        if (parameterStructures === messages_1.ParameterStructures.byName) {
                            throw new Error(`Received ${numberOfParams} parameters for 'by Name' request parameter structure.`);
                        }
                        messageParams = args.slice(paramStart, paramEnd).map(value => undefinedToNull(value));
                        break;
                }
            }
            else {
                const params = args;
                method = type.method;
                messageParams = computeMessageParams(type, params);
                const numberOfParams = type.numberOfParams;
                token = cancellation_1.CancellationToken.is(params[numberOfParams]) ? params[numberOfParams] : undefined;
            }
            const id = sequenceNumber++;
            let disposable;
            if (token) {
                disposable = token.onCancellationRequested(() => {
                    cancellationStrategy.sender.sendCancellation(connection, id);
                });
            }
            const result = new Promise((resolve, reject) => {
                const requestMessage = {
                    jsonrpc: version,
                    id: id,
                    method: method,
                    params: messageParams
                };
                const resolveWithCleanup = (r) => {
                    resolve(r);
                    cancellationStrategy.sender.cleanup(id);
                    disposable === null || disposable === void 0 ? void 0 : disposable.dispose();
                };
                const rejectWithCleanup = (r) => {
                    reject(r);
                    cancellationStrategy.sender.cleanup(id);
                    disposable === null || disposable === void 0 ? void 0 : disposable.dispose();
                };
                let responsePromise = { method: method, timerStart: Date.now(), resolve: resolveWithCleanup, reject: rejectWithCleanup };
                traceSendingRequest(requestMessage);
                try {
                    messageWriter.write(requestMessage);
                }
                catch (e) {
                    // Writing the message failed. So we need to reject the promise.
                    responsePromise.reject(new messages_1.ResponseError(messages_1.ErrorCodes.MessageWriteError, e.message ? e.message : 'Unknown reason'));
                    responsePromise = null;
                }
                if (responsePromise) {
                    responsePromises[String(id)] = responsePromise;
                }
            });
            return result;
        },
        onRequest: (type, handler) => {
            throwIfClosedOrDisposed();
            let method = null;
            if (StarRequestHandler.is(type)) {
                method = undefined;
                starRequestHandler = type;
            }
            else if (Is.string(type)) {
                method = null;
                if (handler !== undefined) {
                    method = type;
                    requestHandlers[type] = { handler: handler, type: undefined };
                }
            }
            else {
                if (handler !== undefined) {
                    method = type.method;
                    requestHandlers[type.method] = { type, handler };
                }
            }
            return {
                dispose: () => {
                    if (method === null) {
                        return;
                    }
                    if (method !== undefined) {
                        delete requestHandlers[method];
                    }
                    else {
                        starRequestHandler = undefined;
                    }
                }
            };
        },
        trace: (_value, _tracer, sendNotificationOrTraceOptions) => {
            let _sendNotification = false;
            let _traceFormat = TraceFormat.Text;
            if (sendNotificationOrTraceOptions !== undefined) {
                if (Is.boolean(sendNotificationOrTraceOptions)) {
                    _sendNotification = sendNotificationOrTraceOptions;
                }
                else {
                    _sendNotification = sendNotificationOrTraceOptions.sendNotification || false;
                    _traceFormat = sendNotificationOrTraceOptions.traceFormat || TraceFormat.Text;
                }
            }
            trace = _value;
            traceFormat = _traceFormat;
            if (trace === Trace.Off) {
                tracer = undefined;
            }
            else {
                tracer = _tracer;
            }
            if (_sendNotification && !isClosed() && !isDisposed()) {
                connection.sendNotification(SetTraceNotification.type, { value: Trace.toString(_value) });
            }
        },
        onError: errorEmitter.event,
        onClose: closeEmitter.event,
        onUnhandledNotification: unhandledNotificationEmitter.event,
        onDispose: disposeEmitter.event,
        end: () => {
            messageWriter.end();
        },
        dispose: () => {
            if (isDisposed()) {
                return;
            }
            state = ConnectionState.Disposed;
            disposeEmitter.fire(undefined);
            const error = new Error('Connection got disposed.');
            Object.keys(responsePromises).forEach((key) => {
                responsePromises[key].reject(error);
            });
            responsePromises = Object.create(null);
            requestTokens = Object.create(null);
            knownCanceledRequests = new Set();
            messageQueue = new linkedMap_1.LinkedMap();
            // Test for backwards compatibility
            if (Is.func(messageWriter.dispose)) {
                messageWriter.dispose();
            }
            if (Is.func(messageReader.dispose)) {
                messageReader.dispose();
            }
        },
        listen: () => {
            throwIfClosedOrDisposed();
            throwIfListening();
            state = ConnectionState.Listening;
            messageReader.listen(callback);
        },
        inspect: () => {
            // eslint-disable-next-line no-console
            ral_1.default().console.log('inspect');
        }
    };
    connection.onNotification(LogTraceNotification.type, (params) => {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        tracer.log(params.message, trace === Trace.Verbose ? params.verbose : undefined);
    });
    connection.onNotification(ProgressNotification.type, (params) => {
        const handler = progressHandlers.get(params.token);
        if (handler) {
            handler(params.value);
        }
        else {
            unhandledProgressEmitter.fire(params);
        }
    });
    return connection;
}
exports.createMessageConnection = createMessageConnection;
//# sourceMappingURL=connection.js.map

/***/ }),
/* 152 */
/***/ ((module) => {

module.exports = require("path");

/***/ }),
/* 153 */
/***/ ((module) => {

module.exports = require("net");

/***/ }),
/* 154 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Proposed = exports.LSPErrorCodes = exports.createProtocolConnection = void 0;
__exportStar(__webpack_require__(136), exports);
__exportStar(__webpack_require__(155), exports);
__exportStar(__webpack_require__(156), exports);
__exportStar(__webpack_require__(157), exports);
var connection_1 = __webpack_require__(174);
Object.defineProperty(exports, "createProtocolConnection", ({ enumerable: true, get: function () { return connection_1.createProtocolConnection; } }));
var LSPErrorCodes;
(function (LSPErrorCodes) {
    /**
    * This is the start range of LSP reserved error codes.
    * It doesn't denote a real error code.
    *
    * @since 3.16.0
    */
    LSPErrorCodes.lspReservedErrorRangeStart = -32899;
    /**
     * The server cancelled the request. This error code should
     * only be used for requests that explicitly support being
     * server cancellable.
     *
     * @since 3.17.0
     */
    LSPErrorCodes.ServerCancelled = -32802;
    /**
     * The server detected that the content of a document got
     * modified outside normal conditions. A server should
     * NOT send this error code if it detects a content change
     * in it unprocessed messages. The result even computed
     * on an older state might still be useful for the client.
     *
     * If a client decides that a result is not of any use anymore
     * the client should cancel the request.
     */
    LSPErrorCodes.ContentModified = -32801;
    /**
     * The client has canceled a request and a server as detected
     * the cancel.
     */
    LSPErrorCodes.RequestCancelled = -32800;
    /**
    * This is the end range of LSP reserved error codes.
    * It doesn't denote a real error code.
    *
    * @since 3.16.0
    */
    LSPErrorCodes.lspReservedErrorRangeEnd = -32800;
})(LSPErrorCodes = exports.LSPErrorCodes || (exports.LSPErrorCodes = {}));
const diag = __webpack_require__(175);
var Proposed;
(function (Proposed) {
    Proposed.DiagnosticServerCancellationData = diag.DiagnosticServerCancellationData;
    Proposed.DocumentDiagnosticReportKind = diag.DocumentDiagnosticReportKind;
    Proposed.DocumentDiagnosticRequest = diag.DocumentDiagnosticRequest;
    Proposed.WorkspaceDiagnosticRequest = diag.WorkspaceDiagnosticRequest;
    Proposed.DiagnosticRefreshRequest = diag.DiagnosticRefreshRequest;
})(Proposed = exports.Proposed || (exports.Proposed = {}));
//# sourceMappingURL=api.js.map

/***/ }),
/* 155 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AnnotatedTextEdit": () => (/* binding */ AnnotatedTextEdit),
/* harmony export */   "ChangeAnnotation": () => (/* binding */ ChangeAnnotation),
/* harmony export */   "ChangeAnnotationIdentifier": () => (/* binding */ ChangeAnnotationIdentifier),
/* harmony export */   "CodeAction": () => (/* binding */ CodeAction),
/* harmony export */   "CodeActionContext": () => (/* binding */ CodeActionContext),
/* harmony export */   "CodeActionKind": () => (/* binding */ CodeActionKind),
/* harmony export */   "CodeDescription": () => (/* binding */ CodeDescription),
/* harmony export */   "CodeLens": () => (/* binding */ CodeLens),
/* harmony export */   "Color": () => (/* binding */ Color),
/* harmony export */   "ColorInformation": () => (/* binding */ ColorInformation),
/* harmony export */   "ColorPresentation": () => (/* binding */ ColorPresentation),
/* harmony export */   "Command": () => (/* binding */ Command),
/* harmony export */   "CompletionItem": () => (/* binding */ CompletionItem),
/* harmony export */   "CompletionItemKind": () => (/* binding */ CompletionItemKind),
/* harmony export */   "CompletionItemLabelDetails": () => (/* binding */ CompletionItemLabelDetails),
/* harmony export */   "CompletionItemTag": () => (/* binding */ CompletionItemTag),
/* harmony export */   "CompletionList": () => (/* binding */ CompletionList),
/* harmony export */   "CreateFile": () => (/* binding */ CreateFile),
/* harmony export */   "DeleteFile": () => (/* binding */ DeleteFile),
/* harmony export */   "Diagnostic": () => (/* binding */ Diagnostic),
/* harmony export */   "DiagnosticRelatedInformation": () => (/* binding */ DiagnosticRelatedInformation),
/* harmony export */   "DiagnosticSeverity": () => (/* binding */ DiagnosticSeverity),
/* harmony export */   "DiagnosticTag": () => (/* binding */ DiagnosticTag),
/* harmony export */   "DocumentHighlight": () => (/* binding */ DocumentHighlight),
/* harmony export */   "DocumentHighlightKind": () => (/* binding */ DocumentHighlightKind),
/* harmony export */   "DocumentLink": () => (/* binding */ DocumentLink),
/* harmony export */   "DocumentSymbol": () => (/* binding */ DocumentSymbol),
/* harmony export */   "EOL": () => (/* binding */ EOL),
/* harmony export */   "FoldingRange": () => (/* binding */ FoldingRange),
/* harmony export */   "FoldingRangeKind": () => (/* binding */ FoldingRangeKind),
/* harmony export */   "FormattingOptions": () => (/* binding */ FormattingOptions),
/* harmony export */   "Hover": () => (/* binding */ Hover),
/* harmony export */   "InsertReplaceEdit": () => (/* binding */ InsertReplaceEdit),
/* harmony export */   "InsertTextFormat": () => (/* binding */ InsertTextFormat),
/* harmony export */   "InsertTextMode": () => (/* binding */ InsertTextMode),
/* harmony export */   "Location": () => (/* binding */ Location),
/* harmony export */   "LocationLink": () => (/* binding */ LocationLink),
/* harmony export */   "MarkedString": () => (/* binding */ MarkedString),
/* harmony export */   "MarkupContent": () => (/* binding */ MarkupContent),
/* harmony export */   "MarkupKind": () => (/* binding */ MarkupKind),
/* harmony export */   "OptionalVersionedTextDocumentIdentifier": () => (/* binding */ OptionalVersionedTextDocumentIdentifier),
/* harmony export */   "ParameterInformation": () => (/* binding */ ParameterInformation),
/* harmony export */   "Position": () => (/* binding */ Position),
/* harmony export */   "Range": () => (/* binding */ Range),
/* harmony export */   "RenameFile": () => (/* binding */ RenameFile),
/* harmony export */   "SelectionRange": () => (/* binding */ SelectionRange),
/* harmony export */   "SemanticTokenModifiers": () => (/* binding */ SemanticTokenModifiers),
/* harmony export */   "SemanticTokenTypes": () => (/* binding */ SemanticTokenTypes),
/* harmony export */   "SemanticTokens": () => (/* binding */ SemanticTokens),
/* harmony export */   "SignatureInformation": () => (/* binding */ SignatureInformation),
/* harmony export */   "SymbolInformation": () => (/* binding */ SymbolInformation),
/* harmony export */   "SymbolKind": () => (/* binding */ SymbolKind),
/* harmony export */   "SymbolTag": () => (/* binding */ SymbolTag),
/* harmony export */   "TextDocument": () => (/* binding */ TextDocument),
/* harmony export */   "TextDocumentEdit": () => (/* binding */ TextDocumentEdit),
/* harmony export */   "TextDocumentIdentifier": () => (/* binding */ TextDocumentIdentifier),
/* harmony export */   "TextDocumentItem": () => (/* binding */ TextDocumentItem),
/* harmony export */   "TextEdit": () => (/* binding */ TextEdit),
/* harmony export */   "VersionedTextDocumentIdentifier": () => (/* binding */ VersionedTextDocumentIdentifier),
/* harmony export */   "WorkspaceChange": () => (/* binding */ WorkspaceChange),
/* harmony export */   "WorkspaceEdit": () => (/* binding */ WorkspaceEdit),
/* harmony export */   "integer": () => (/* binding */ integer),
/* harmony export */   "uinteger": () => (/* binding */ uinteger)
/* harmony export */ });
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

var integer;
(function (integer) {
    integer.MIN_VALUE = -2147483648;
    integer.MAX_VALUE = 2147483647;
})(integer || (integer = {}));
var uinteger;
(function (uinteger) {
    uinteger.MIN_VALUE = 0;
    uinteger.MAX_VALUE = 2147483647;
})(uinteger || (uinteger = {}));
/**
 * The Position namespace provides helper functions to work with
 * [Position](#Position) literals.
 */
var Position;
(function (Position) {
    /**
     * Creates a new Position literal from the given line and character.
     * @param line The position's line.
     * @param character The position's character.
     */
    function create(line, character) {
        if (line === Number.MAX_VALUE) {
            line = uinteger.MAX_VALUE;
        }
        if (character === Number.MAX_VALUE) {
            character = uinteger.MAX_VALUE;
        }
        return { line: line, character: character };
    }
    Position.create = create;
    /**
     * Checks whether the given literal conforms to the [Position](#Position) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Is.uinteger(candidate.line) && Is.uinteger(candidate.character);
    }
    Position.is = is;
})(Position || (Position = {}));
/**
 * The Range namespace provides helper functions to work with
 * [Range](#Range) literals.
 */
var Range;
(function (Range) {
    function create(one, two, three, four) {
        if (Is.uinteger(one) && Is.uinteger(two) && Is.uinteger(three) && Is.uinteger(four)) {
            return { start: Position.create(one, two), end: Position.create(three, four) };
        }
        else if (Position.is(one) && Position.is(two)) {
            return { start: one, end: two };
        }
        else {
            throw new Error("Range#create called with invalid arguments[" + one + ", " + two + ", " + three + ", " + four + "]");
        }
    }
    Range.create = create;
    /**
     * Checks whether the given literal conforms to the [Range](#Range) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Position.is(candidate.start) && Position.is(candidate.end);
    }
    Range.is = is;
})(Range || (Range = {}));
/**
 * The Location namespace provides helper functions to work with
 * [Location](#Location) literals.
 */
var Location;
(function (Location) {
    /**
     * Creates a Location literal.
     * @param uri The location's uri.
     * @param range The location's range.
     */
    function create(uri, range) {
        return { uri: uri, range: range };
    }
    Location.create = create;
    /**
     * Checks whether the given literal conforms to the [Location](#Location) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Range.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));
    }
    Location.is = is;
})(Location || (Location = {}));
/**
 * The LocationLink namespace provides helper functions to work with
 * [LocationLink](#LocationLink) literals.
 */
var LocationLink;
(function (LocationLink) {
    /**
     * Creates a LocationLink literal.
     * @param targetUri The definition's uri.
     * @param targetRange The full range of the definition.
     * @param targetSelectionRange The span of the symbol definition at the target.
     * @param originSelectionRange The span of the symbol being defined in the originating source file.
     */
    function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {
        return { targetUri: targetUri, targetRange: targetRange, targetSelectionRange: targetSelectionRange, originSelectionRange: originSelectionRange };
    }
    LocationLink.create = create;
    /**
     * Checks whether the given literal conforms to the [LocationLink](#LocationLink) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Range.is(candidate.targetRange) && Is.string(candidate.targetUri)
            && (Range.is(candidate.targetSelectionRange) || Is.undefined(candidate.targetSelectionRange))
            && (Range.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));
    }
    LocationLink.is = is;
})(LocationLink || (LocationLink = {}));
/**
 * The Color namespace provides helper functions to work with
 * [Color](#Color) literals.
 */
var Color;
(function (Color) {
    /**
     * Creates a new Color literal.
     */
    function create(red, green, blue, alpha) {
        return {
            red: red,
            green: green,
            blue: blue,
            alpha: alpha,
        };
    }
    Color.create = create;
    /**
     * Checks whether the given literal conforms to the [Color](#Color) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.numberRange(candidate.red, 0, 1)
            && Is.numberRange(candidate.green, 0, 1)
            && Is.numberRange(candidate.blue, 0, 1)
            && Is.numberRange(candidate.alpha, 0, 1);
    }
    Color.is = is;
})(Color || (Color = {}));
/**
 * The ColorInformation namespace provides helper functions to work with
 * [ColorInformation](#ColorInformation) literals.
 */
var ColorInformation;
(function (ColorInformation) {
    /**
     * Creates a new ColorInformation literal.
     */
    function create(range, color) {
        return {
            range: range,
            color: color,
        };
    }
    ColorInformation.create = create;
    /**
     * Checks whether the given literal conforms to the [ColorInformation](#ColorInformation) interface.
     */
    function is(value) {
        var candidate = value;
        return Range.is(candidate.range) && Color.is(candidate.color);
    }
    ColorInformation.is = is;
})(ColorInformation || (ColorInformation = {}));
/**
 * The Color namespace provides helper functions to work with
 * [ColorPresentation](#ColorPresentation) literals.
 */
var ColorPresentation;
(function (ColorPresentation) {
    /**
     * Creates a new ColorInformation literal.
     */
    function create(label, textEdit, additionalTextEdits) {
        return {
            label: label,
            textEdit: textEdit,
            additionalTextEdits: additionalTextEdits,
        };
    }
    ColorPresentation.create = create;
    /**
     * Checks whether the given literal conforms to the [ColorInformation](#ColorInformation) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.string(candidate.label)
            && (Is.undefined(candidate.textEdit) || TextEdit.is(candidate))
            && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit.is));
    }
    ColorPresentation.is = is;
})(ColorPresentation || (ColorPresentation = {}));
/**
 * Enum of known range kinds
 */
var FoldingRangeKind;
(function (FoldingRangeKind) {
    /**
     * Folding range for a comment
     */
    FoldingRangeKind["Comment"] = "comment";
    /**
     * Folding range for a imports or includes
     */
    FoldingRangeKind["Imports"] = "imports";
    /**
     * Folding range for a region (e.g. `#region`)
     */
    FoldingRangeKind["Region"] = "region";
})(FoldingRangeKind || (FoldingRangeKind = {}));
/**
 * The folding range namespace provides helper functions to work with
 * [FoldingRange](#FoldingRange) literals.
 */
var FoldingRange;
(function (FoldingRange) {
    /**
     * Creates a new FoldingRange literal.
     */
    function create(startLine, endLine, startCharacter, endCharacter, kind) {
        var result = {
            startLine: startLine,
            endLine: endLine
        };
        if (Is.defined(startCharacter)) {
            result.startCharacter = startCharacter;
        }
        if (Is.defined(endCharacter)) {
            result.endCharacter = endCharacter;
        }
        if (Is.defined(kind)) {
            result.kind = kind;
        }
        return result;
    }
    FoldingRange.create = create;
    /**
     * Checks whether the given literal conforms to the [FoldingRange](#FoldingRange) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.uinteger(candidate.startLine) && Is.uinteger(candidate.startLine)
            && (Is.undefined(candidate.startCharacter) || Is.uinteger(candidate.startCharacter))
            && (Is.undefined(candidate.endCharacter) || Is.uinteger(candidate.endCharacter))
            && (Is.undefined(candidate.kind) || Is.string(candidate.kind));
    }
    FoldingRange.is = is;
})(FoldingRange || (FoldingRange = {}));
/**
 * The DiagnosticRelatedInformation namespace provides helper functions to work with
 * [DiagnosticRelatedInformation](#DiagnosticRelatedInformation) literals.
 */
var DiagnosticRelatedInformation;
(function (DiagnosticRelatedInformation) {
    /**
     * Creates a new DiagnosticRelatedInformation literal.
     */
    function create(location, message) {
        return {
            location: location,
            message: message
        };
    }
    DiagnosticRelatedInformation.create = create;
    /**
     * Checks whether the given literal conforms to the [DiagnosticRelatedInformation](#DiagnosticRelatedInformation) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Location.is(candidate.location) && Is.string(candidate.message);
    }
    DiagnosticRelatedInformation.is = is;
})(DiagnosticRelatedInformation || (DiagnosticRelatedInformation = {}));
/**
 * The diagnostic's severity.
 */
var DiagnosticSeverity;
(function (DiagnosticSeverity) {
    /**
     * Reports an error.
     */
    DiagnosticSeverity.Error = 1;
    /**
     * Reports a warning.
     */
    DiagnosticSeverity.Warning = 2;
    /**
     * Reports an information.
     */
    DiagnosticSeverity.Information = 3;
    /**
     * Reports a hint.
     */
    DiagnosticSeverity.Hint = 4;
})(DiagnosticSeverity || (DiagnosticSeverity = {}));
/**
 * The diagnostic tags.
 *
 * @since 3.15.0
 */
var DiagnosticTag;
(function (DiagnosticTag) {
    /**
     * Unused or unnecessary code.
     *
     * Clients are allowed to render diagnostics with this tag faded out instead of having
     * an error squiggle.
     */
    DiagnosticTag.Unnecessary = 1;
    /**
     * Deprecated or obsolete code.
     *
     * Clients are allowed to rendered diagnostics with this tag strike through.
     */
    DiagnosticTag.Deprecated = 2;
})(DiagnosticTag || (DiagnosticTag = {}));
/**
 * The CodeDescription namespace provides functions to deal with descriptions for diagnostic codes.
 *
 * @since 3.16.0
 */
var CodeDescription;
(function (CodeDescription) {
    function is(value) {
        var candidate = value;
        return candidate !== undefined && candidate !== null && Is.string(candidate.href);
    }
    CodeDescription.is = is;
})(CodeDescription || (CodeDescription = {}));
/**
 * The Diagnostic namespace provides helper functions to work with
 * [Diagnostic](#Diagnostic) literals.
 */
var Diagnostic;
(function (Diagnostic) {
    /**
     * Creates a new Diagnostic literal.
     */
    function create(range, message, severity, code, source, relatedInformation) {
        var result = { range: range, message: message };
        if (Is.defined(severity)) {
            result.severity = severity;
        }
        if (Is.defined(code)) {
            result.code = code;
        }
        if (Is.defined(source)) {
            result.source = source;
        }
        if (Is.defined(relatedInformation)) {
            result.relatedInformation = relatedInformation;
        }
        return result;
    }
    Diagnostic.create = create;
    /**
     * Checks whether the given literal conforms to the [Diagnostic](#Diagnostic) interface.
     */
    function is(value) {
        var _a;
        var candidate = value;
        return Is.defined(candidate)
            && Range.is(candidate.range)
            && Is.string(candidate.message)
            && (Is.number(candidate.severity) || Is.undefined(candidate.severity))
            && (Is.integer(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code))
            && (Is.undefined(candidate.codeDescription) || (Is.string((_a = candidate.codeDescription) === null || _a === void 0 ? void 0 : _a.href)))
            && (Is.string(candidate.source) || Is.undefined(candidate.source))
            && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));
    }
    Diagnostic.is = is;
})(Diagnostic || (Diagnostic = {}));
/**
 * The Command namespace provides helper functions to work with
 * [Command](#Command) literals.
 */
var Command;
(function (Command) {
    /**
     * Creates a new Command literal.
     */
    function create(title, command) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        var result = { title: title, command: command };
        if (Is.defined(args) && args.length > 0) {
            result.arguments = args;
        }
        return result;
    }
    Command.create = create;
    /**
     * Checks whether the given literal conforms to the [Command](#Command) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);
    }
    Command.is = is;
})(Command || (Command = {}));
/**
 * The TextEdit namespace provides helper function to create replace,
 * insert and delete edits more easily.
 */
var TextEdit;
(function (TextEdit) {
    /**
     * Creates a replace text edit.
     * @param range The range of text to be replaced.
     * @param newText The new text.
     */
    function replace(range, newText) {
        return { range: range, newText: newText };
    }
    TextEdit.replace = replace;
    /**
     * Creates a insert text edit.
     * @param position The position to insert the text at.
     * @param newText The text to be inserted.
     */
    function insert(position, newText) {
        return { range: { start: position, end: position }, newText: newText };
    }
    TextEdit.insert = insert;
    /**
     * Creates a delete text edit.
     * @param range The range of text to be deleted.
     */
    function del(range) {
        return { range: range, newText: '' };
    }
    TextEdit.del = del;
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate)
            && Is.string(candidate.newText)
            && Range.is(candidate.range);
    }
    TextEdit.is = is;
})(TextEdit || (TextEdit = {}));
var ChangeAnnotation;
(function (ChangeAnnotation) {
    function create(label, needsConfirmation, description) {
        var result = { label: label };
        if (needsConfirmation !== undefined) {
            result.needsConfirmation = needsConfirmation;
        }
        if (description !== undefined) {
            result.description = description;
        }
        return result;
    }
    ChangeAnnotation.create = create;
    function is(value) {
        var candidate = value;
        return candidate !== undefined && Is.objectLiteral(candidate) && Is.string(candidate.label) &&
            (Is.boolean(candidate.needsConfirmation) || candidate.needsConfirmation === undefined) &&
            (Is.string(candidate.description) || candidate.description === undefined);
    }
    ChangeAnnotation.is = is;
})(ChangeAnnotation || (ChangeAnnotation = {}));
var ChangeAnnotationIdentifier;
(function (ChangeAnnotationIdentifier) {
    function is(value) {
        var candidate = value;
        return typeof candidate === 'string';
    }
    ChangeAnnotationIdentifier.is = is;
})(ChangeAnnotationIdentifier || (ChangeAnnotationIdentifier = {}));
var AnnotatedTextEdit;
(function (AnnotatedTextEdit) {
    /**
     * Creates an annotated replace text edit.
     *
     * @param range The range of text to be replaced.
     * @param newText The new text.
     * @param annotation The annotation.
     */
    function replace(range, newText, annotation) {
        return { range: range, newText: newText, annotationId: annotation };
    }
    AnnotatedTextEdit.replace = replace;
    /**
     * Creates an annotated insert text edit.
     *
     * @param position The position to insert the text at.
     * @param newText The text to be inserted.
     * @param annotation The annotation.
     */
    function insert(position, newText, annotation) {
        return { range: { start: position, end: position }, newText: newText, annotationId: annotation };
    }
    AnnotatedTextEdit.insert = insert;
    /**
     * Creates an annotated delete text edit.
     *
     * @param range The range of text to be deleted.
     * @param annotation The annotation.
     */
    function del(range, annotation) {
        return { range: range, newText: '', annotationId: annotation };
    }
    AnnotatedTextEdit.del = del;
    function is(value) {
        var candidate = value;
        return TextEdit.is(candidate) && (ChangeAnnotation.is(candidate.annotationId) || ChangeAnnotationIdentifier.is(candidate.annotationId));
    }
    AnnotatedTextEdit.is = is;
})(AnnotatedTextEdit || (AnnotatedTextEdit = {}));
/**
 * The TextDocumentEdit namespace provides helper function to create
 * an edit that manipulates a text document.
 */
var TextDocumentEdit;
(function (TextDocumentEdit) {
    /**
     * Creates a new `TextDocumentEdit`
     */
    function create(textDocument, edits) {
        return { textDocument: textDocument, edits: edits };
    }
    TextDocumentEdit.create = create;
    function is(value) {
        var candidate = value;
        return Is.defined(candidate)
            && OptionalVersionedTextDocumentIdentifier.is(candidate.textDocument)
            && Array.isArray(candidate.edits);
    }
    TextDocumentEdit.is = is;
})(TextDocumentEdit || (TextDocumentEdit = {}));
var CreateFile;
(function (CreateFile) {
    function create(uri, options, annotation) {
        var result = {
            kind: 'create',
            uri: uri
        };
        if (options !== undefined && (options.overwrite !== undefined || options.ignoreIfExists !== undefined)) {
            result.options = options;
        }
        if (annotation !== undefined) {
            result.annotationId = annotation;
        }
        return result;
    }
    CreateFile.create = create;
    function is(value) {
        var candidate = value;
        return candidate && candidate.kind === 'create' && Is.string(candidate.uri) && (candidate.options === undefined ||
            ((candidate.options.overwrite === undefined || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === undefined || Is.boolean(candidate.options.ignoreIfExists)))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));
    }
    CreateFile.is = is;
})(CreateFile || (CreateFile = {}));
var RenameFile;
(function (RenameFile) {
    function create(oldUri, newUri, options, annotation) {
        var result = {
            kind: 'rename',
            oldUri: oldUri,
            newUri: newUri
        };
        if (options !== undefined && (options.overwrite !== undefined || options.ignoreIfExists !== undefined)) {
            result.options = options;
        }
        if (annotation !== undefined) {
            result.annotationId = annotation;
        }
        return result;
    }
    RenameFile.create = create;
    function is(value) {
        var candidate = value;
        return candidate && candidate.kind === 'rename' && Is.string(candidate.oldUri) && Is.string(candidate.newUri) && (candidate.options === undefined ||
            ((candidate.options.overwrite === undefined || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === undefined || Is.boolean(candidate.options.ignoreIfExists)))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));
    }
    RenameFile.is = is;
})(RenameFile || (RenameFile = {}));
var DeleteFile;
(function (DeleteFile) {
    function create(uri, options, annotation) {
        var result = {
            kind: 'delete',
            uri: uri
        };
        if (options !== undefined && (options.recursive !== undefined || options.ignoreIfNotExists !== undefined)) {
            result.options = options;
        }
        if (annotation !== undefined) {
            result.annotationId = annotation;
        }
        return result;
    }
    DeleteFile.create = create;
    function is(value) {
        var candidate = value;
        return candidate && candidate.kind === 'delete' && Is.string(candidate.uri) && (candidate.options === undefined ||
            ((candidate.options.recursive === undefined || Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === undefined || Is.boolean(candidate.options.ignoreIfNotExists)))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));
    }
    DeleteFile.is = is;
})(DeleteFile || (DeleteFile = {}));
var WorkspaceEdit;
(function (WorkspaceEdit) {
    function is(value) {
        var candidate = value;
        return candidate &&
            (candidate.changes !== undefined || candidate.documentChanges !== undefined) &&
            (candidate.documentChanges === undefined || candidate.documentChanges.every(function (change) {
                if (Is.string(change.kind)) {
                    return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);
                }
                else {
                    return TextDocumentEdit.is(change);
                }
            }));
    }
    WorkspaceEdit.is = is;
})(WorkspaceEdit || (WorkspaceEdit = {}));
var TextEditChangeImpl = /** @class */ (function () {
    function TextEditChangeImpl(edits, changeAnnotations) {
        this.edits = edits;
        this.changeAnnotations = changeAnnotations;
    }
    TextEditChangeImpl.prototype.insert = function (position, newText, annotation) {
        var edit;
        var id;
        if (annotation === undefined) {
            edit = TextEdit.insert(position, newText);
        }
        else if (ChangeAnnotationIdentifier.is(annotation)) {
            id = annotation;
            edit = AnnotatedTextEdit.insert(position, newText, annotation);
        }
        else {
            this.assertChangeAnnotations(this.changeAnnotations);
            id = this.changeAnnotations.manage(annotation);
            edit = AnnotatedTextEdit.insert(position, newText, id);
        }
        this.edits.push(edit);
        if (id !== undefined) {
            return id;
        }
    };
    TextEditChangeImpl.prototype.replace = function (range, newText, annotation) {
        var edit;
        var id;
        if (annotation === undefined) {
            edit = TextEdit.replace(range, newText);
        }
        else if (ChangeAnnotationIdentifier.is(annotation)) {
            id = annotation;
            edit = AnnotatedTextEdit.replace(range, newText, annotation);
        }
        else {
            this.assertChangeAnnotations(this.changeAnnotations);
            id = this.changeAnnotations.manage(annotation);
            edit = AnnotatedTextEdit.replace(range, newText, id);
        }
        this.edits.push(edit);
        if (id !== undefined) {
            return id;
        }
    };
    TextEditChangeImpl.prototype.delete = function (range, annotation) {
        var edit;
        var id;
        if (annotation === undefined) {
            edit = TextEdit.del(range);
        }
        else if (ChangeAnnotationIdentifier.is(annotation)) {
            id = annotation;
            edit = AnnotatedTextEdit.del(range, annotation);
        }
        else {
            this.assertChangeAnnotations(this.changeAnnotations);
            id = this.changeAnnotations.manage(annotation);
            edit = AnnotatedTextEdit.del(range, id);
        }
        this.edits.push(edit);
        if (id !== undefined) {
            return id;
        }
    };
    TextEditChangeImpl.prototype.add = function (edit) {
        this.edits.push(edit);
    };
    TextEditChangeImpl.prototype.all = function () {
        return this.edits;
    };
    TextEditChangeImpl.prototype.clear = function () {
        this.edits.splice(0, this.edits.length);
    };
    TextEditChangeImpl.prototype.assertChangeAnnotations = function (value) {
        if (value === undefined) {
            throw new Error("Text edit change is not configured to manage change annotations.");
        }
    };
    return TextEditChangeImpl;
}());
/**
 * A helper class
 */
var ChangeAnnotations = /** @class */ (function () {
    function ChangeAnnotations(annotations) {
        this._annotations = annotations === undefined ? Object.create(null) : annotations;
        this._counter = 0;
        this._size = 0;
    }
    ChangeAnnotations.prototype.all = function () {
        return this._annotations;
    };
    Object.defineProperty(ChangeAnnotations.prototype, "size", {
        get: function () {
            return this._size;
        },
        enumerable: false,
        configurable: true
    });
    ChangeAnnotations.prototype.manage = function (idOrAnnotation, annotation) {
        var id;
        if (ChangeAnnotationIdentifier.is(idOrAnnotation)) {
            id = idOrAnnotation;
        }
        else {
            id = this.nextId();
            annotation = idOrAnnotation;
        }
        if (this._annotations[id] !== undefined) {
            throw new Error("Id " + id + " is already in use.");
        }
        if (annotation === undefined) {
            throw new Error("No annotation provided for id " + id);
        }
        this._annotations[id] = annotation;
        this._size++;
        return id;
    };
    ChangeAnnotations.prototype.nextId = function () {
        this._counter++;
        return this._counter.toString();
    };
    return ChangeAnnotations;
}());
/**
 * A workspace change helps constructing changes to a workspace.
 */
var WorkspaceChange = /** @class */ (function () {
    function WorkspaceChange(workspaceEdit) {
        var _this = this;
        this._textEditChanges = Object.create(null);
        if (workspaceEdit !== undefined) {
            this._workspaceEdit = workspaceEdit;
            if (workspaceEdit.documentChanges) {
                this._changeAnnotations = new ChangeAnnotations(workspaceEdit.changeAnnotations);
                workspaceEdit.changeAnnotations = this._changeAnnotations.all();
                workspaceEdit.documentChanges.forEach(function (change) {
                    if (TextDocumentEdit.is(change)) {
                        var textEditChange = new TextEditChangeImpl(change.edits, _this._changeAnnotations);
                        _this._textEditChanges[change.textDocument.uri] = textEditChange;
                    }
                });
            }
            else if (workspaceEdit.changes) {
                Object.keys(workspaceEdit.changes).forEach(function (key) {
                    var textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);
                    _this._textEditChanges[key] = textEditChange;
                });
            }
        }
        else {
            this._workspaceEdit = {};
        }
    }
    Object.defineProperty(WorkspaceChange.prototype, "edit", {
        /**
         * Returns the underlying [WorkspaceEdit](#WorkspaceEdit) literal
         * use to be returned from a workspace edit operation like rename.
         */
        get: function () {
            this.initDocumentChanges();
            if (this._changeAnnotations !== undefined) {
                if (this._changeAnnotations.size === 0) {
                    this._workspaceEdit.changeAnnotations = undefined;
                }
                else {
                    this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
                }
            }
            return this._workspaceEdit;
        },
        enumerable: false,
        configurable: true
    });
    WorkspaceChange.prototype.getTextEditChange = function (key) {
        if (OptionalVersionedTextDocumentIdentifier.is(key)) {
            this.initDocumentChanges();
            if (this._workspaceEdit.documentChanges === undefined) {
                throw new Error('Workspace edit is not configured for document changes.');
            }
            var textDocument = { uri: key.uri, version: key.version };
            var result = this._textEditChanges[textDocument.uri];
            if (!result) {
                var edits = [];
                var textDocumentEdit = {
                    textDocument: textDocument,
                    edits: edits
                };
                this._workspaceEdit.documentChanges.push(textDocumentEdit);
                result = new TextEditChangeImpl(edits, this._changeAnnotations);
                this._textEditChanges[textDocument.uri] = result;
            }
            return result;
        }
        else {
            this.initChanges();
            if (this._workspaceEdit.changes === undefined) {
                throw new Error('Workspace edit is not configured for normal text edit changes.');
            }
            var result = this._textEditChanges[key];
            if (!result) {
                var edits = [];
                this._workspaceEdit.changes[key] = edits;
                result = new TextEditChangeImpl(edits);
                this._textEditChanges[key] = result;
            }
            return result;
        }
    };
    WorkspaceChange.prototype.initDocumentChanges = function () {
        if (this._workspaceEdit.documentChanges === undefined && this._workspaceEdit.changes === undefined) {
            this._changeAnnotations = new ChangeAnnotations();
            this._workspaceEdit.documentChanges = [];
            this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
        }
    };
    WorkspaceChange.prototype.initChanges = function () {
        if (this._workspaceEdit.documentChanges === undefined && this._workspaceEdit.changes === undefined) {
            this._workspaceEdit.changes = Object.create(null);
        }
    };
    WorkspaceChange.prototype.createFile = function (uri, optionsOrAnnotation, options) {
        this.initDocumentChanges();
        if (this._workspaceEdit.documentChanges === undefined) {
            throw new Error('Workspace edit is not configured for document changes.');
        }
        var annotation;
        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
            annotation = optionsOrAnnotation;
        }
        else {
            options = optionsOrAnnotation;
        }
        var operation;
        var id;
        if (annotation === undefined) {
            operation = CreateFile.create(uri, options);
        }
        else {
            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
            operation = CreateFile.create(uri, options, id);
        }
        this._workspaceEdit.documentChanges.push(operation);
        if (id !== undefined) {
            return id;
        }
    };
    WorkspaceChange.prototype.renameFile = function (oldUri, newUri, optionsOrAnnotation, options) {
        this.initDocumentChanges();
        if (this._workspaceEdit.documentChanges === undefined) {
            throw new Error('Workspace edit is not configured for document changes.');
        }
        var annotation;
        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
            annotation = optionsOrAnnotation;
        }
        else {
            options = optionsOrAnnotation;
        }
        var operation;
        var id;
        if (annotation === undefined) {
            operation = RenameFile.create(oldUri, newUri, options);
        }
        else {
            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
            operation = RenameFile.create(oldUri, newUri, options, id);
        }
        this._workspaceEdit.documentChanges.push(operation);
        if (id !== undefined) {
            return id;
        }
    };
    WorkspaceChange.prototype.deleteFile = function (uri, optionsOrAnnotation, options) {
        this.initDocumentChanges();
        if (this._workspaceEdit.documentChanges === undefined) {
            throw new Error('Workspace edit is not configured for document changes.');
        }
        var annotation;
        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
            annotation = optionsOrAnnotation;
        }
        else {
            options = optionsOrAnnotation;
        }
        var operation;
        var id;
        if (annotation === undefined) {
            operation = DeleteFile.create(uri, options);
        }
        else {
            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
            operation = DeleteFile.create(uri, options, id);
        }
        this._workspaceEdit.documentChanges.push(operation);
        if (id !== undefined) {
            return id;
        }
    };
    return WorkspaceChange;
}());

/**
 * The TextDocumentIdentifier namespace provides helper functions to work with
 * [TextDocumentIdentifier](#TextDocumentIdentifier) literals.
 */
var TextDocumentIdentifier;
(function (TextDocumentIdentifier) {
    /**
     * Creates a new TextDocumentIdentifier literal.
     * @param uri The document's uri.
     */
    function create(uri) {
        return { uri: uri };
    }
    TextDocumentIdentifier.create = create;
    /**
     * Checks whether the given literal conforms to the [TextDocumentIdentifier](#TextDocumentIdentifier) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri);
    }
    TextDocumentIdentifier.is = is;
})(TextDocumentIdentifier || (TextDocumentIdentifier = {}));
/**
 * The VersionedTextDocumentIdentifier namespace provides helper functions to work with
 * [VersionedTextDocumentIdentifier](#VersionedTextDocumentIdentifier) literals.
 */
var VersionedTextDocumentIdentifier;
(function (VersionedTextDocumentIdentifier) {
    /**
     * Creates a new VersionedTextDocumentIdentifier literal.
     * @param uri The document's uri.
     * @param uri The document's text.
     */
    function create(uri, version) {
        return { uri: uri, version: version };
    }
    VersionedTextDocumentIdentifier.create = create;
    /**
     * Checks whether the given literal conforms to the [VersionedTextDocumentIdentifier](#VersionedTextDocumentIdentifier) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && Is.integer(candidate.version);
    }
    VersionedTextDocumentIdentifier.is = is;
})(VersionedTextDocumentIdentifier || (VersionedTextDocumentIdentifier = {}));
/**
 * The OptionalVersionedTextDocumentIdentifier namespace provides helper functions to work with
 * [OptionalVersionedTextDocumentIdentifier](#OptionalVersionedTextDocumentIdentifier) literals.
 */
var OptionalVersionedTextDocumentIdentifier;
(function (OptionalVersionedTextDocumentIdentifier) {
    /**
     * Creates a new OptionalVersionedTextDocumentIdentifier literal.
     * @param uri The document's uri.
     * @param uri The document's text.
     */
    function create(uri, version) {
        return { uri: uri, version: version };
    }
    OptionalVersionedTextDocumentIdentifier.create = create;
    /**
     * Checks whether the given literal conforms to the [OptionalVersionedTextDocumentIdentifier](#OptionalVersionedTextDocumentIdentifier) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && (candidate.version === null || Is.integer(candidate.version));
    }
    OptionalVersionedTextDocumentIdentifier.is = is;
})(OptionalVersionedTextDocumentIdentifier || (OptionalVersionedTextDocumentIdentifier = {}));
/**
 * The TextDocumentItem namespace provides helper functions to work with
 * [TextDocumentItem](#TextDocumentItem) literals.
 */
var TextDocumentItem;
(function (TextDocumentItem) {
    /**
     * Creates a new TextDocumentItem literal.
     * @param uri The document's uri.
     * @param languageId The document's language identifier.
     * @param version The document's version number.
     * @param text The document's text.
     */
    function create(uri, languageId, version, text) {
        return { uri: uri, languageId: languageId, version: version, text: text };
    }
    TextDocumentItem.create = create;
    /**
     * Checks whether the given literal conforms to the [TextDocumentItem](#TextDocumentItem) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.integer(candidate.version) && Is.string(candidate.text);
    }
    TextDocumentItem.is = is;
})(TextDocumentItem || (TextDocumentItem = {}));
/**
 * Describes the content type that a client supports in various
 * result literals like `Hover`, `ParameterInfo` or `CompletionItem`.
 *
 * Please note that `MarkupKinds` must not start with a `$`. This kinds
 * are reserved for internal usage.
 */
var MarkupKind;
(function (MarkupKind) {
    /**
     * Plain text is supported as a content format
     */
    MarkupKind.PlainText = 'plaintext';
    /**
     * Markdown is supported as a content format
     */
    MarkupKind.Markdown = 'markdown';
})(MarkupKind || (MarkupKind = {}));
(function (MarkupKind) {
    /**
     * Checks whether the given value is a value of the [MarkupKind](#MarkupKind) type.
     */
    function is(value) {
        var candidate = value;
        return candidate === MarkupKind.PlainText || candidate === MarkupKind.Markdown;
    }
    MarkupKind.is = is;
})(MarkupKind || (MarkupKind = {}));
var MarkupContent;
(function (MarkupContent) {
    /**
     * Checks whether the given value conforms to the [MarkupContent](#MarkupContent) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(value) && MarkupKind.is(candidate.kind) && Is.string(candidate.value);
    }
    MarkupContent.is = is;
})(MarkupContent || (MarkupContent = {}));
/**
 * The kind of a completion entry.
 */
var CompletionItemKind;
(function (CompletionItemKind) {
    CompletionItemKind.Text = 1;
    CompletionItemKind.Method = 2;
    CompletionItemKind.Function = 3;
    CompletionItemKind.Constructor = 4;
    CompletionItemKind.Field = 5;
    CompletionItemKind.Variable = 6;
    CompletionItemKind.Class = 7;
    CompletionItemKind.Interface = 8;
    CompletionItemKind.Module = 9;
    CompletionItemKind.Property = 10;
    CompletionItemKind.Unit = 11;
    CompletionItemKind.Value = 12;
    CompletionItemKind.Enum = 13;
    CompletionItemKind.Keyword = 14;
    CompletionItemKind.Snippet = 15;
    CompletionItemKind.Color = 16;
    CompletionItemKind.File = 17;
    CompletionItemKind.Reference = 18;
    CompletionItemKind.Folder = 19;
    CompletionItemKind.EnumMember = 20;
    CompletionItemKind.Constant = 21;
    CompletionItemKind.Struct = 22;
    CompletionItemKind.Event = 23;
    CompletionItemKind.Operator = 24;
    CompletionItemKind.TypeParameter = 25;
})(CompletionItemKind || (CompletionItemKind = {}));
/**
 * Defines whether the insert text in a completion item should be interpreted as
 * plain text or a snippet.
 */
var InsertTextFormat;
(function (InsertTextFormat) {
    /**
     * The primary text to be inserted is treated as a plain string.
     */
    InsertTextFormat.PlainText = 1;
    /**
     * The primary text to be inserted is treated as a snippet.
     *
     * A snippet can define tab stops and placeholders with `$1`, `$2`
     * and `${3:foo}`. `$0` defines the final tab stop, it defaults to
     * the end of the snippet. Placeholders with equal identifiers are linked,
     * that is typing in one will update others too.
     *
     * See also: https://microsoft.github.io/language-server-protocol/specifications/specification-current/#snippet_syntax
     */
    InsertTextFormat.Snippet = 2;
})(InsertTextFormat || (InsertTextFormat = {}));
/**
 * Completion item tags are extra annotations that tweak the rendering of a completion
 * item.
 *
 * @since 3.15.0
 */
var CompletionItemTag;
(function (CompletionItemTag) {
    /**
     * Render a completion as obsolete, usually using a strike-out.
     */
    CompletionItemTag.Deprecated = 1;
})(CompletionItemTag || (CompletionItemTag = {}));
/**
 * The InsertReplaceEdit namespace provides functions to deal with insert / replace edits.
 *
 * @since 3.16.0
 */
var InsertReplaceEdit;
(function (InsertReplaceEdit) {
    /**
     * Creates a new insert / replace edit
     */
    function create(newText, insert, replace) {
        return { newText: newText, insert: insert, replace: replace };
    }
    InsertReplaceEdit.create = create;
    /**
     * Checks whether the given literal conforms to the [InsertReplaceEdit](#InsertReplaceEdit) interface.
     */
    function is(value) {
        var candidate = value;
        return candidate && Is.string(candidate.newText) && Range.is(candidate.insert) && Range.is(candidate.replace);
    }
    InsertReplaceEdit.is = is;
})(InsertReplaceEdit || (InsertReplaceEdit = {}));
/**
 * How whitespace and indentation is handled during completion
 * item insertion.
 *
 * @since 3.16.0
 */
var InsertTextMode;
(function (InsertTextMode) {
    /**
     * The insertion or replace strings is taken as it is. If the
     * value is multi line the lines below the cursor will be
     * inserted using the indentation defined in the string value.
     * The client will not apply any kind of adjustments to the
     * string.
     */
    InsertTextMode.asIs = 1;
    /**
     * The editor adjusts leading whitespace of new lines so that
     * they match the indentation up to the cursor of the line for
     * which the item is accepted.
     *
     * Consider a line like this: <2tabs><cursor><3tabs>foo. Accepting a
     * multi line completion item is indented using 2 tabs and all
     * following lines inserted will be indented using 2 tabs as well.
     */
    InsertTextMode.adjustIndentation = 2;
})(InsertTextMode || (InsertTextMode = {}));
var CompletionItemLabelDetails;
(function (CompletionItemLabelDetails) {
    function is(value) {
        var candidate = value;
        return candidate && (Is.string(candidate.parameters) || candidate.parameters === undefined) &&
            (Is.string(candidate.qualifier) || candidate.qualifier === undefined) && (Is.string(candidate.type) || candidate.type === undefined);
    }
    CompletionItemLabelDetails.is = is;
})(CompletionItemLabelDetails || (CompletionItemLabelDetails = {}));
/**
 * The CompletionItem namespace provides functions to deal with
 * completion items.
 */
var CompletionItem;
(function (CompletionItem) {
    /**
     * Create a completion item and seed it with a label.
     * @param label The completion item's label
     */
    function create(label) {
        return { label: label };
    }
    CompletionItem.create = create;
})(CompletionItem || (CompletionItem = {}));
/**
 * The CompletionList namespace provides functions to deal with
 * completion lists.
 */
var CompletionList;
(function (CompletionList) {
    /**
     * Creates a new completion list.
     *
     * @param items The completion items.
     * @param isIncomplete The list is not complete.
     */
    function create(items, isIncomplete) {
        return { items: items ? items : [], isIncomplete: !!isIncomplete };
    }
    CompletionList.create = create;
})(CompletionList || (CompletionList = {}));
var MarkedString;
(function (MarkedString) {
    /**
     * Creates a marked string from plain text.
     *
     * @param plainText The plain text.
     */
    function fromPlainText(plainText) {
        return plainText.replace(/[\\`*_{}[\]()#+\-.!]/g, '\\$&'); // escape markdown syntax tokens: http://daringfireball.net/projects/markdown/syntax#backslash
    }
    MarkedString.fromPlainText = fromPlainText;
    /**
     * Checks whether the given value conforms to the [MarkedString](#MarkedString) type.
     */
    function is(value) {
        var candidate = value;
        return Is.string(candidate) || (Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value));
    }
    MarkedString.is = is;
})(MarkedString || (MarkedString = {}));
var Hover;
(function (Hover) {
    /**
     * Checks whether the given value conforms to the [Hover](#Hover) interface.
     */
    function is(value) {
        var candidate = value;
        return !!candidate && Is.objectLiteral(candidate) && (MarkupContent.is(candidate.contents) ||
            MarkedString.is(candidate.contents) ||
            Is.typedArray(candidate.contents, MarkedString.is)) && (value.range === undefined || Range.is(value.range));
    }
    Hover.is = is;
})(Hover || (Hover = {}));
/**
 * The ParameterInformation namespace provides helper functions to work with
 * [ParameterInformation](#ParameterInformation) literals.
 */
var ParameterInformation;
(function (ParameterInformation) {
    /**
     * Creates a new parameter information literal.
     *
     * @param label A label string.
     * @param documentation A doc string.
     */
    function create(label, documentation) {
        return documentation ? { label: label, documentation: documentation } : { label: label };
    }
    ParameterInformation.create = create;
})(ParameterInformation || (ParameterInformation = {}));
/**
 * The SignatureInformation namespace provides helper functions to work with
 * [SignatureInformation](#SignatureInformation) literals.
 */
var SignatureInformation;
(function (SignatureInformation) {
    function create(label, documentation) {
        var parameters = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            parameters[_i - 2] = arguments[_i];
        }
        var result = { label: label };
        if (Is.defined(documentation)) {
            result.documentation = documentation;
        }
        if (Is.defined(parameters)) {
            result.parameters = parameters;
        }
        else {
            result.parameters = [];
        }
        return result;
    }
    SignatureInformation.create = create;
})(SignatureInformation || (SignatureInformation = {}));
/**
 * A document highlight kind.
 */
var DocumentHighlightKind;
(function (DocumentHighlightKind) {
    /**
     * A textual occurrence.
     */
    DocumentHighlightKind.Text = 1;
    /**
     * Read-access of a symbol, like reading a variable.
     */
    DocumentHighlightKind.Read = 2;
    /**
     * Write-access of a symbol, like writing to a variable.
     */
    DocumentHighlightKind.Write = 3;
})(DocumentHighlightKind || (DocumentHighlightKind = {}));
/**
 * DocumentHighlight namespace to provide helper functions to work with
 * [DocumentHighlight](#DocumentHighlight) literals.
 */
var DocumentHighlight;
(function (DocumentHighlight) {
    /**
     * Create a DocumentHighlight object.
     * @param range The range the highlight applies to.
     */
    function create(range, kind) {
        var result = { range: range };
        if (Is.number(kind)) {
            result.kind = kind;
        }
        return result;
    }
    DocumentHighlight.create = create;
})(DocumentHighlight || (DocumentHighlight = {}));
/**
 * A symbol kind.
 */
var SymbolKind;
(function (SymbolKind) {
    SymbolKind.File = 1;
    SymbolKind.Module = 2;
    SymbolKind.Namespace = 3;
    SymbolKind.Package = 4;
    SymbolKind.Class = 5;
    SymbolKind.Method = 6;
    SymbolKind.Property = 7;
    SymbolKind.Field = 8;
    SymbolKind.Constructor = 9;
    SymbolKind.Enum = 10;
    SymbolKind.Interface = 11;
    SymbolKind.Function = 12;
    SymbolKind.Variable = 13;
    SymbolKind.Constant = 14;
    SymbolKind.String = 15;
    SymbolKind.Number = 16;
    SymbolKind.Boolean = 17;
    SymbolKind.Array = 18;
    SymbolKind.Object = 19;
    SymbolKind.Key = 20;
    SymbolKind.Null = 21;
    SymbolKind.EnumMember = 22;
    SymbolKind.Struct = 23;
    SymbolKind.Event = 24;
    SymbolKind.Operator = 25;
    SymbolKind.TypeParameter = 26;
})(SymbolKind || (SymbolKind = {}));
/**
 * Symbol tags are extra annotations that tweak the rendering of a symbol.
 * @since 3.16
 */
var SymbolTag;
(function (SymbolTag) {
    /**
     * Render a symbol as obsolete, usually using a strike-out.
     */
    SymbolTag.Deprecated = 1;
})(SymbolTag || (SymbolTag = {}));
var SymbolInformation;
(function (SymbolInformation) {
    /**
     * Creates a new symbol information literal.
     *
     * @param name The name of the symbol.
     * @param kind The kind of the symbol.
     * @param range The range of the location of the symbol.
     * @param uri The resource of the location of symbol, defaults to the current document.
     * @param containerName The name of the symbol containing the symbol.
     */
    function create(name, kind, range, uri, containerName) {
        var result = {
            name: name,
            kind: kind,
            location: { uri: uri, range: range }
        };
        if (containerName) {
            result.containerName = containerName;
        }
        return result;
    }
    SymbolInformation.create = create;
})(SymbolInformation || (SymbolInformation = {}));
var DocumentSymbol;
(function (DocumentSymbol) {
    /**
     * Creates a new symbol information literal.
     *
     * @param name The name of the symbol.
     * @param detail The detail of the symbol.
     * @param kind The kind of the symbol.
     * @param range The range of the symbol.
     * @param selectionRange The selectionRange of the symbol.
     * @param children Children of the symbol.
     */
    function create(name, detail, kind, range, selectionRange, children) {
        var result = {
            name: name,
            detail: detail,
            kind: kind,
            range: range,
            selectionRange: selectionRange
        };
        if (children !== undefined) {
            result.children = children;
        }
        return result;
    }
    DocumentSymbol.create = create;
    /**
     * Checks whether the given literal conforms to the [DocumentSymbol](#DocumentSymbol) interface.
     */
    function is(value) {
        var candidate = value;
        return candidate &&
            Is.string(candidate.name) && Is.number(candidate.kind) &&
            Range.is(candidate.range) && Range.is(candidate.selectionRange) &&
            (candidate.detail === undefined || Is.string(candidate.detail)) &&
            (candidate.deprecated === undefined || Is.boolean(candidate.deprecated)) &&
            (candidate.children === undefined || Array.isArray(candidate.children)) &&
            (candidate.tags === undefined || Array.isArray(candidate.tags));
    }
    DocumentSymbol.is = is;
})(DocumentSymbol || (DocumentSymbol = {}));
/**
 * A set of predefined code action kinds
 */
var CodeActionKind;
(function (CodeActionKind) {
    /**
     * Empty kind.
     */
    CodeActionKind.Empty = '';
    /**
     * Base kind for quickfix actions: 'quickfix'
     */
    CodeActionKind.QuickFix = 'quickfix';
    /**
     * Base kind for refactoring actions: 'refactor'
     */
    CodeActionKind.Refactor = 'refactor';
    /**
     * Base kind for refactoring extraction actions: 'refactor.extract'
     *
     * Example extract actions:
     *
     * - Extract method
     * - Extract function
     * - Extract variable
     * - Extract interface from class
     * - ...
     */
    CodeActionKind.RefactorExtract = 'refactor.extract';
    /**
     * Base kind for refactoring inline actions: 'refactor.inline'
     *
     * Example inline actions:
     *
     * - Inline function
     * - Inline variable
     * - Inline constant
     * - ...
     */
    CodeActionKind.RefactorInline = 'refactor.inline';
    /**
     * Base kind for refactoring rewrite actions: 'refactor.rewrite'
     *
     * Example rewrite actions:
     *
     * - Convert JavaScript function to class
     * - Add or remove parameter
     * - Encapsulate field
     * - Make method static
     * - Move method to base class
     * - ...
     */
    CodeActionKind.RefactorRewrite = 'refactor.rewrite';
    /**
     * Base kind for source actions: `source`
     *
     * Source code actions apply to the entire file.
     */
    CodeActionKind.Source = 'source';
    /**
     * Base kind for an organize imports source action: `source.organizeImports`
     */
    CodeActionKind.SourceOrganizeImports = 'source.organizeImports';
    /**
     * Base kind for auto-fix source actions: `source.fixAll`.
     *
     * Fix all actions automatically fix errors that have a clear fix that do not require user input.
     * They should not suppress errors or perform unsafe fixes such as generating new types or classes.
     *
     * @since 3.15.0
     */
    CodeActionKind.SourceFixAll = 'source.fixAll';
})(CodeActionKind || (CodeActionKind = {}));
/**
 * The CodeActionContext namespace provides helper functions to work with
 * [CodeActionContext](#CodeActionContext) literals.
 */
var CodeActionContext;
(function (CodeActionContext) {
    /**
     * Creates a new CodeActionContext literal.
     */
    function create(diagnostics, only) {
        var result = { diagnostics: diagnostics };
        if (only !== undefined && only !== null) {
            result.only = only;
        }
        return result;
    }
    CodeActionContext.create = create;
    /**
     * Checks whether the given literal conforms to the [CodeActionContext](#CodeActionContext) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic.is) && (candidate.only === undefined || Is.typedArray(candidate.only, Is.string));
    }
    CodeActionContext.is = is;
})(CodeActionContext || (CodeActionContext = {}));
var CodeAction;
(function (CodeAction) {
    function create(title, kindOrCommandOrEdit, kind) {
        var result = { title: title };
        var checkKind = true;
        if (typeof kindOrCommandOrEdit === 'string') {
            checkKind = false;
            result.kind = kindOrCommandOrEdit;
        }
        else if (Command.is(kindOrCommandOrEdit)) {
            result.command = kindOrCommandOrEdit;
        }
        else {
            result.edit = kindOrCommandOrEdit;
        }
        if (checkKind && kind !== undefined) {
            result.kind = kind;
        }
        return result;
    }
    CodeAction.create = create;
    function is(value) {
        var candidate = value;
        return candidate && Is.string(candidate.title) &&
            (candidate.diagnostics === undefined || Is.typedArray(candidate.diagnostics, Diagnostic.is)) &&
            (candidate.kind === undefined || Is.string(candidate.kind)) &&
            (candidate.edit !== undefined || candidate.command !== undefined) &&
            (candidate.command === undefined || Command.is(candidate.command)) &&
            (candidate.isPreferred === undefined || Is.boolean(candidate.isPreferred)) &&
            (candidate.edit === undefined || WorkspaceEdit.is(candidate.edit));
    }
    CodeAction.is = is;
})(CodeAction || (CodeAction = {}));
/**
 * The CodeLens namespace provides helper functions to work with
 * [CodeLens](#CodeLens) literals.
 */
var CodeLens;
(function (CodeLens) {
    /**
     * Creates a new CodeLens literal.
     */
    function create(range, data) {
        var result = { range: range };
        if (Is.defined(data)) {
            result.data = data;
        }
        return result;
    }
    CodeLens.create = create;
    /**
     * Checks whether the given literal conforms to the [CodeLens](#CodeLens) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.command) || Command.is(candidate.command));
    }
    CodeLens.is = is;
})(CodeLens || (CodeLens = {}));
/**
 * The FormattingOptions namespace provides helper functions to work with
 * [FormattingOptions](#FormattingOptions) literals.
 */
var FormattingOptions;
(function (FormattingOptions) {
    /**
     * Creates a new FormattingOptions literal.
     */
    function create(tabSize, insertSpaces) {
        return { tabSize: tabSize, insertSpaces: insertSpaces };
    }
    FormattingOptions.create = create;
    /**
     * Checks whether the given literal conforms to the [FormattingOptions](#FormattingOptions) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.uinteger(candidate.tabSize) && Is.boolean(candidate.insertSpaces);
    }
    FormattingOptions.is = is;
})(FormattingOptions || (FormattingOptions = {}));
/**
 * The DocumentLink namespace provides helper functions to work with
 * [DocumentLink](#DocumentLink) literals.
 */
var DocumentLink;
(function (DocumentLink) {
    /**
     * Creates a new DocumentLink literal.
     */
    function create(range, target, data) {
        return { range: range, target: target, data: data };
    }
    DocumentLink.create = create;
    /**
     * Checks whether the given literal conforms to the [DocumentLink](#DocumentLink) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));
    }
    DocumentLink.is = is;
})(DocumentLink || (DocumentLink = {}));
/**
 * The SelectionRange namespace provides helper function to work with
 * SelectionRange literals.
 */
var SelectionRange;
(function (SelectionRange) {
    /**
     * Creates a new SelectionRange
     * @param range the range.
     * @param parent an optional parent.
     */
    function create(range, parent) {
        return { range: range, parent: parent };
    }
    SelectionRange.create = create;
    function is(value) {
        var candidate = value;
        return candidate !== undefined && Range.is(candidate.range) && (candidate.parent === undefined || SelectionRange.is(candidate.parent));
    }
    SelectionRange.is = is;
})(SelectionRange || (SelectionRange = {}));
/**
 * A set of predefined token types. This set is not fixed
 * an clients can specify additional token types via the
 * corresponding client capabilities.
 *
 * @since 3.16.0
 */
var SemanticTokenTypes;
(function (SemanticTokenTypes) {
    SemanticTokenTypes["namespace"] = "namespace";
    /**
     * Represents a generic type. Acts as a fallback for types which can't be mapped to
     * a specific type like class or enum.
     */
    SemanticTokenTypes["type"] = "type";
    SemanticTokenTypes["class"] = "class";
    SemanticTokenTypes["enum"] = "enum";
    SemanticTokenTypes["interface"] = "interface";
    SemanticTokenTypes["struct"] = "struct";
    SemanticTokenTypes["typeParameter"] = "typeParameter";
    SemanticTokenTypes["parameter"] = "parameter";
    SemanticTokenTypes["variable"] = "variable";
    SemanticTokenTypes["property"] = "property";
    SemanticTokenTypes["enumMember"] = "enumMember";
    SemanticTokenTypes["event"] = "event";
    SemanticTokenTypes["function"] = "function";
    SemanticTokenTypes["method"] = "method";
    SemanticTokenTypes["macro"] = "macro";
    SemanticTokenTypes["keyword"] = "keyword";
    SemanticTokenTypes["modifier"] = "modifier";
    SemanticTokenTypes["comment"] = "comment";
    SemanticTokenTypes["string"] = "string";
    SemanticTokenTypes["number"] = "number";
    SemanticTokenTypes["regexp"] = "regexp";
    SemanticTokenTypes["operator"] = "operator";
})(SemanticTokenTypes || (SemanticTokenTypes = {}));
/**
 * A set of predefined token modifiers. This set is not fixed
 * an clients can specify additional token types via the
 * corresponding client capabilities.
 *
 * @since 3.16.0
 */
var SemanticTokenModifiers;
(function (SemanticTokenModifiers) {
    SemanticTokenModifiers["declaration"] = "declaration";
    SemanticTokenModifiers["definition"] = "definition";
    SemanticTokenModifiers["readonly"] = "readonly";
    SemanticTokenModifiers["static"] = "static";
    SemanticTokenModifiers["deprecated"] = "deprecated";
    SemanticTokenModifiers["abstract"] = "abstract";
    SemanticTokenModifiers["async"] = "async";
    SemanticTokenModifiers["modification"] = "modification";
    SemanticTokenModifiers["documentation"] = "documentation";
    SemanticTokenModifiers["defaultLibrary"] = "defaultLibrary";
})(SemanticTokenModifiers || (SemanticTokenModifiers = {}));
/**
 * @since 3.16.0
 */
var SemanticTokens;
(function (SemanticTokens) {
    function is(value) {
        var candidate = value;
        return candidate !== undefined && (candidate.resultId === undefined || typeof candidate.resultId === 'string') &&
            Array.isArray(candidate.data) && (candidate.data.length === 0 || typeof candidate.data[0] === 'number');
    }
    SemanticTokens.is = is;
})(SemanticTokens || (SemanticTokens = {}));
var EOL = ['\n', '\r\n', '\r'];
/**
 * @deprecated Use the text document from the new vscode-languageserver-textdocument package.
 */
var TextDocument;
(function (TextDocument) {
    /**
     * Creates a new ITextDocument literal from the given uri and content.
     * @param uri The document's uri.
     * @param languageId  The document's language Id.
     * @param content The document's content.
     */
    function create(uri, languageId, version, content) {
        return new FullTextDocument(uri, languageId, version, content);
    }
    TextDocument.create = create;
    /**
     * Checks whether the given literal conforms to the [ITextDocument](#ITextDocument) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.uinteger(candidate.lineCount)
            && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;
    }
    TextDocument.is = is;
    function applyEdits(document, edits) {
        var text = document.getText();
        var sortedEdits = mergeSort(edits, function (a, b) {
            var diff = a.range.start.line - b.range.start.line;
            if (diff === 0) {
                return a.range.start.character - b.range.start.character;
            }
            return diff;
        });
        var lastModifiedOffset = text.length;
        for (var i = sortedEdits.length - 1; i >= 0; i--) {
            var e = sortedEdits[i];
            var startOffset = document.offsetAt(e.range.start);
            var endOffset = document.offsetAt(e.range.end);
            if (endOffset <= lastModifiedOffset) {
                text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);
            }
            else {
                throw new Error('Overlapping edit');
            }
            lastModifiedOffset = startOffset;
        }
        return text;
    }
    TextDocument.applyEdits = applyEdits;
    function mergeSort(data, compare) {
        if (data.length <= 1) {
            // sorted
            return data;
        }
        var p = (data.length / 2) | 0;
        var left = data.slice(0, p);
        var right = data.slice(p);
        mergeSort(left, compare);
        mergeSort(right, compare);
        var leftIdx = 0;
        var rightIdx = 0;
        var i = 0;
        while (leftIdx < left.length && rightIdx < right.length) {
            var ret = compare(left[leftIdx], right[rightIdx]);
            if (ret <= 0) {
                // smaller_equal -> take left to preserve order
                data[i++] = left[leftIdx++];
            }
            else {
                // greater -> take right
                data[i++] = right[rightIdx++];
            }
        }
        while (leftIdx < left.length) {
            data[i++] = left[leftIdx++];
        }
        while (rightIdx < right.length) {
            data[i++] = right[rightIdx++];
        }
        return data;
    }
})(TextDocument || (TextDocument = {}));
/**
 * @deprecated Use the text document from the new vscode-languageserver-textdocument package.
 */
var FullTextDocument = /** @class */ (function () {
    function FullTextDocument(uri, languageId, version, content) {
        this._uri = uri;
        this._languageId = languageId;
        this._version = version;
        this._content = content;
        this._lineOffsets = undefined;
    }
    Object.defineProperty(FullTextDocument.prototype, "uri", {
        get: function () {
            return this._uri;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(FullTextDocument.prototype, "languageId", {
        get: function () {
            return this._languageId;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(FullTextDocument.prototype, "version", {
        get: function () {
            return this._version;
        },
        enumerable: false,
        configurable: true
    });
    FullTextDocument.prototype.getText = function (range) {
        if (range) {
            var start = this.offsetAt(range.start);
            var end = this.offsetAt(range.end);
            return this._content.substring(start, end);
        }
        return this._content;
    };
    FullTextDocument.prototype.update = function (event, version) {
        this._content = event.text;
        this._version = version;
        this._lineOffsets = undefined;
    };
    FullTextDocument.prototype.getLineOffsets = function () {
        if (this._lineOffsets === undefined) {
            var lineOffsets = [];
            var text = this._content;
            var isLineStart = true;
            for (var i = 0; i < text.length; i++) {
                if (isLineStart) {
                    lineOffsets.push(i);
                    isLineStart = false;
                }
                var ch = text.charAt(i);
                isLineStart = (ch === '\r' || ch === '\n');
                if (ch === '\r' && i + 1 < text.length && text.charAt(i + 1) === '\n') {
                    i++;
                }
            }
            if (isLineStart && text.length > 0) {
                lineOffsets.push(text.length);
            }
            this._lineOffsets = lineOffsets;
        }
        return this._lineOffsets;
    };
    FullTextDocument.prototype.positionAt = function (offset) {
        offset = Math.max(Math.min(offset, this._content.length), 0);
        var lineOffsets = this.getLineOffsets();
        var low = 0, high = lineOffsets.length;
        if (high === 0) {
            return Position.create(0, offset);
        }
        while (low < high) {
            var mid = Math.floor((low + high) / 2);
            if (lineOffsets[mid] > offset) {
                high = mid;
            }
            else {
                low = mid + 1;
            }
        }
        // low is the least x for which the line offset is larger than the current offset
        // or array.length if no line offset is larger than the current offset
        var line = low - 1;
        return Position.create(line, offset - lineOffsets[line]);
    };
    FullTextDocument.prototype.offsetAt = function (position) {
        var lineOffsets = this.getLineOffsets();
        if (position.line >= lineOffsets.length) {
            return this._content.length;
        }
        else if (position.line < 0) {
            return 0;
        }
        var lineOffset = lineOffsets[position.line];
        var nextLineOffset = (position.line + 1 < lineOffsets.length) ? lineOffsets[position.line + 1] : this._content.length;
        return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
    };
    Object.defineProperty(FullTextDocument.prototype, "lineCount", {
        get: function () {
            return this.getLineOffsets().length;
        },
        enumerable: false,
        configurable: true
    });
    return FullTextDocument;
}());
var Is;
(function (Is) {
    var toString = Object.prototype.toString;
    function defined(value) {
        return typeof value !== 'undefined';
    }
    Is.defined = defined;
    function undefined(value) {
        return typeof value === 'undefined';
    }
    Is.undefined = undefined;
    function boolean(value) {
        return value === true || value === false;
    }
    Is.boolean = boolean;
    function string(value) {
        return toString.call(value) === '[object String]';
    }
    Is.string = string;
    function number(value) {
        return toString.call(value) === '[object Number]';
    }
    Is.number = number;
    function numberRange(value, min, max) {
        return toString.call(value) === '[object Number]' && min <= value && value <= max;
    }
    Is.numberRange = numberRange;
    function integer(value) {
        return toString.call(value) === '[object Number]' && -2147483648 <= value && value <= 2147483647;
    }
    Is.integer = integer;
    function uinteger(value) {
        return toString.call(value) === '[object Number]' && 0 <= value && value <= 2147483647;
    }
    Is.uinteger = uinteger;
    function func(value) {
        return toString.call(value) === '[object Function]';
    }
    Is.func = func;
    function objectLiteral(value) {
        // Strictly speaking class instances pass this check as well. Since the LSP
        // doesn't use classes we ignore this for now. If we do we need to add something
        // like this: `Object.getPrototypeOf(Object.getPrototypeOf(x)) === null`
        return value !== null && typeof value === 'object';
    }
    Is.objectLiteral = objectLiteral;
    function typedArray(value, check) {
        return Array.isArray(value) && value.every(check);
    }
    Is.typedArray = typedArray;
})(Is || (Is = {}));


/***/ }),
/* 156 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProtocolNotificationType = exports.ProtocolNotificationType0 = exports.ProtocolRequestType = exports.ProtocolRequestType0 = exports.RegistrationType = void 0;
const vscode_jsonrpc_1 = __webpack_require__(136);
class RegistrationType {
    constructor(method) {
        this.method = method;
    }
}
exports.RegistrationType = RegistrationType;
class ProtocolRequestType0 extends vscode_jsonrpc_1.RequestType0 {
    constructor(method) {
        super(method);
    }
}
exports.ProtocolRequestType0 = ProtocolRequestType0;
class ProtocolRequestType extends vscode_jsonrpc_1.RequestType {
    constructor(method) {
        super(method, vscode_jsonrpc_1.ParameterStructures.byName);
    }
}
exports.ProtocolRequestType = ProtocolRequestType;
class ProtocolNotificationType0 extends vscode_jsonrpc_1.NotificationType0 {
    constructor(method) {
        super(method);
    }
}
exports.ProtocolNotificationType0 = ProtocolNotificationType0;
class ProtocolNotificationType extends vscode_jsonrpc_1.NotificationType {
    constructor(method) {
        super(method, vscode_jsonrpc_1.ParameterStructures.byName);
    }
}
exports.ProtocolNotificationType = ProtocolNotificationType;
// let x: ProtocolNotificationType<number, { value: number}>;
// let y: ProtocolNotificationType<string, { value: number}>;
// x = y;
//# sourceMappingURL=messages.js.map

/***/ }),
/* 157 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DocumentLinkRequest = exports.CodeLensRefreshRequest = exports.CodeLensResolveRequest = exports.CodeLensRequest = exports.WorkspaceSymbolRequest = exports.CodeActionResolveRequest = exports.CodeActionRequest = exports.DocumentSymbolRequest = exports.DocumentHighlightRequest = exports.ReferencesRequest = exports.DefinitionRequest = exports.SignatureHelpRequest = exports.SignatureHelpTriggerKind = exports.HoverRequest = exports.CompletionResolveRequest = exports.CompletionRequest = exports.CompletionTriggerKind = exports.PublishDiagnosticsNotification = exports.WatchKind = exports.FileChangeType = exports.DidChangeWatchedFilesNotification = exports.WillSaveTextDocumentWaitUntilRequest = exports.WillSaveTextDocumentNotification = exports.TextDocumentSaveReason = exports.DidSaveTextDocumentNotification = exports.DidCloseTextDocumentNotification = exports.DidChangeTextDocumentNotification = exports.TextDocumentContentChangeEvent = exports.DidOpenTextDocumentNotification = exports.TextDocumentSyncKind = exports.TelemetryEventNotification = exports.LogMessageNotification = exports.ShowMessageRequest = exports.ShowMessageNotification = exports.MessageType = exports.DidChangeConfigurationNotification = exports.ExitNotification = exports.ShutdownRequest = exports.InitializedNotification = exports.InitializeError = exports.InitializeRequest = exports.WorkDoneProgressOptions = exports.TextDocumentRegistrationOptions = exports.StaticRegistrationOptions = exports.FailureHandlingKind = exports.ResourceOperationKind = exports.UnregistrationRequest = exports.RegistrationRequest = exports.DocumentSelector = exports.DocumentFilter = void 0;
exports.MonikerRequest = exports.MonikerKind = exports.UniquenessLevel = exports.WillDeleteFilesRequest = exports.DidDeleteFilesNotification = exports.WillRenameFilesRequest = exports.DidRenameFilesNotification = exports.WillCreateFilesRequest = exports.DidCreateFilesNotification = exports.FileOperationPatternKind = exports.LinkedEditingRangeRequest = exports.ShowDocumentRequest = exports.SemanticTokensRegistrationType = exports.SemanticTokensRefreshRequest = exports.SemanticTokensRangeRequest = exports.SemanticTokensDeltaRequest = exports.SemanticTokensRequest = exports.TokenFormat = exports.CallHierarchyPrepareRequest = exports.CallHierarchyOutgoingCallsRequest = exports.CallHierarchyIncomingCallsRequest = exports.WorkDoneProgressCancelNotification = exports.WorkDoneProgressCreateRequest = exports.WorkDoneProgress = exports.SelectionRangeRequest = exports.DeclarationRequest = exports.FoldingRangeRequest = exports.ColorPresentationRequest = exports.DocumentColorRequest = exports.ConfigurationRequest = exports.DidChangeWorkspaceFoldersNotification = exports.WorkspaceFoldersRequest = exports.TypeDefinitionRequest = exports.ImplementationRequest = exports.ApplyWorkspaceEditRequest = exports.ExecuteCommandRequest = exports.PrepareRenameRequest = exports.RenameRequest = exports.PrepareSupportDefaultBehavior = exports.DocumentOnTypeFormattingRequest = exports.DocumentRangeFormattingRequest = exports.DocumentFormattingRequest = exports.DocumentLinkResolveRequest = void 0;
const messages_1 = __webpack_require__(156);
const Is = __webpack_require__(158);
const protocol_implementation_1 = __webpack_require__(159);
Object.defineProperty(exports, "ImplementationRequest", ({ enumerable: true, get: function () { return protocol_implementation_1.ImplementationRequest; } }));
const protocol_typeDefinition_1 = __webpack_require__(160);
Object.defineProperty(exports, "TypeDefinitionRequest", ({ enumerable: true, get: function () { return protocol_typeDefinition_1.TypeDefinitionRequest; } }));
const protocol_workspaceFolders_1 = __webpack_require__(161);
Object.defineProperty(exports, "WorkspaceFoldersRequest", ({ enumerable: true, get: function () { return protocol_workspaceFolders_1.WorkspaceFoldersRequest; } }));
Object.defineProperty(exports, "DidChangeWorkspaceFoldersNotification", ({ enumerable: true, get: function () { return protocol_workspaceFolders_1.DidChangeWorkspaceFoldersNotification; } }));
const protocol_configuration_1 = __webpack_require__(162);
Object.defineProperty(exports, "ConfigurationRequest", ({ enumerable: true, get: function () { return protocol_configuration_1.ConfigurationRequest; } }));
const protocol_colorProvider_1 = __webpack_require__(163);
Object.defineProperty(exports, "DocumentColorRequest", ({ enumerable: true, get: function () { return protocol_colorProvider_1.DocumentColorRequest; } }));
Object.defineProperty(exports, "ColorPresentationRequest", ({ enumerable: true, get: function () { return protocol_colorProvider_1.ColorPresentationRequest; } }));
const protocol_foldingRange_1 = __webpack_require__(164);
Object.defineProperty(exports, "FoldingRangeRequest", ({ enumerable: true, get: function () { return protocol_foldingRange_1.FoldingRangeRequest; } }));
const protocol_declaration_1 = __webpack_require__(165);
Object.defineProperty(exports, "DeclarationRequest", ({ enumerable: true, get: function () { return protocol_declaration_1.DeclarationRequest; } }));
const protocol_selectionRange_1 = __webpack_require__(166);
Object.defineProperty(exports, "SelectionRangeRequest", ({ enumerable: true, get: function () { return protocol_selectionRange_1.SelectionRangeRequest; } }));
const protocol_progress_1 = __webpack_require__(167);
Object.defineProperty(exports, "WorkDoneProgress", ({ enumerable: true, get: function () { return protocol_progress_1.WorkDoneProgress; } }));
Object.defineProperty(exports, "WorkDoneProgressCreateRequest", ({ enumerable: true, get: function () { return protocol_progress_1.WorkDoneProgressCreateRequest; } }));
Object.defineProperty(exports, "WorkDoneProgressCancelNotification", ({ enumerable: true, get: function () { return protocol_progress_1.WorkDoneProgressCancelNotification; } }));
const protocol_callHierarchy_1 = __webpack_require__(168);
Object.defineProperty(exports, "CallHierarchyIncomingCallsRequest", ({ enumerable: true, get: function () { return protocol_callHierarchy_1.CallHierarchyIncomingCallsRequest; } }));
Object.defineProperty(exports, "CallHierarchyOutgoingCallsRequest", ({ enumerable: true, get: function () { return protocol_callHierarchy_1.CallHierarchyOutgoingCallsRequest; } }));
Object.defineProperty(exports, "CallHierarchyPrepareRequest", ({ enumerable: true, get: function () { return protocol_callHierarchy_1.CallHierarchyPrepareRequest; } }));
const protocol_semanticTokens_1 = __webpack_require__(169);
Object.defineProperty(exports, "TokenFormat", ({ enumerable: true, get: function () { return protocol_semanticTokens_1.TokenFormat; } }));
Object.defineProperty(exports, "SemanticTokensRequest", ({ enumerable: true, get: function () { return protocol_semanticTokens_1.SemanticTokensRequest; } }));
Object.defineProperty(exports, "SemanticTokensDeltaRequest", ({ enumerable: true, get: function () { return protocol_semanticTokens_1.SemanticTokensDeltaRequest; } }));
Object.defineProperty(exports, "SemanticTokensRangeRequest", ({ enumerable: true, get: function () { return protocol_semanticTokens_1.SemanticTokensRangeRequest; } }));
Object.defineProperty(exports, "SemanticTokensRefreshRequest", ({ enumerable: true, get: function () { return protocol_semanticTokens_1.SemanticTokensRefreshRequest; } }));
Object.defineProperty(exports, "SemanticTokensRegistrationType", ({ enumerable: true, get: function () { return protocol_semanticTokens_1.SemanticTokensRegistrationType; } }));
const protocol_showDocument_1 = __webpack_require__(170);
Object.defineProperty(exports, "ShowDocumentRequest", ({ enumerable: true, get: function () { return protocol_showDocument_1.ShowDocumentRequest; } }));
const protocol_linkedEditingRange_1 = __webpack_require__(171);
Object.defineProperty(exports, "LinkedEditingRangeRequest", ({ enumerable: true, get: function () { return protocol_linkedEditingRange_1.LinkedEditingRangeRequest; } }));
const protocol_fileOperations_1 = __webpack_require__(172);
Object.defineProperty(exports, "FileOperationPatternKind", ({ enumerable: true, get: function () { return protocol_fileOperations_1.FileOperationPatternKind; } }));
Object.defineProperty(exports, "DidCreateFilesNotification", ({ enumerable: true, get: function () { return protocol_fileOperations_1.DidCreateFilesNotification; } }));
Object.defineProperty(exports, "WillCreateFilesRequest", ({ enumerable: true, get: function () { return protocol_fileOperations_1.WillCreateFilesRequest; } }));
Object.defineProperty(exports, "DidRenameFilesNotification", ({ enumerable: true, get: function () { return protocol_fileOperations_1.DidRenameFilesNotification; } }));
Object.defineProperty(exports, "WillRenameFilesRequest", ({ enumerable: true, get: function () { return protocol_fileOperations_1.WillRenameFilesRequest; } }));
Object.defineProperty(exports, "DidDeleteFilesNotification", ({ enumerable: true, get: function () { return protocol_fileOperations_1.DidDeleteFilesNotification; } }));
Object.defineProperty(exports, "WillDeleteFilesRequest", ({ enumerable: true, get: function () { return protocol_fileOperations_1.WillDeleteFilesRequest; } }));
const protocol_moniker_1 = __webpack_require__(173);
Object.defineProperty(exports, "UniquenessLevel", ({ enumerable: true, get: function () { return protocol_moniker_1.UniquenessLevel; } }));
Object.defineProperty(exports, "MonikerKind", ({ enumerable: true, get: function () { return protocol_moniker_1.MonikerKind; } }));
Object.defineProperty(exports, "MonikerRequest", ({ enumerable: true, get: function () { return protocol_moniker_1.MonikerRequest; } }));
// @ts-ignore: to avoid inlining LocationLink as dynamic import
let __noDynamicImport;
/**
 * The DocumentFilter namespace provides helper functions to work with
 * [DocumentFilter](#DocumentFilter) literals.
 */
var DocumentFilter;
(function (DocumentFilter) {
    function is(value) {
        const candidate = value;
        return Is.string(candidate.language) || Is.string(candidate.scheme) || Is.string(candidate.pattern);
    }
    DocumentFilter.is = is;
})(DocumentFilter = exports.DocumentFilter || (exports.DocumentFilter = {}));
/**
 * The DocumentSelector namespace provides helper functions to work with
 * [DocumentSelector](#DocumentSelector)s.
 */
var DocumentSelector;
(function (DocumentSelector) {
    function is(value) {
        if (!Array.isArray(value)) {
            return false;
        }
        for (let elem of value) {
            if (!Is.string(elem) && !DocumentFilter.is(elem)) {
                return false;
            }
        }
        return true;
    }
    DocumentSelector.is = is;
})(DocumentSelector = exports.DocumentSelector || (exports.DocumentSelector = {}));
/**
 * The `client/registerCapability` request is sent from the server to the client to register a new capability
 * handler on the client side.
 */
var RegistrationRequest;
(function (RegistrationRequest) {
    RegistrationRequest.type = new messages_1.ProtocolRequestType('client/registerCapability');
})(RegistrationRequest = exports.RegistrationRequest || (exports.RegistrationRequest = {}));
/**
 * The `client/unregisterCapability` request is sent from the server to the client to unregister a previously registered capability
 * handler on the client side.
 */
var UnregistrationRequest;
(function (UnregistrationRequest) {
    UnregistrationRequest.type = new messages_1.ProtocolRequestType('client/unregisterCapability');
})(UnregistrationRequest = exports.UnregistrationRequest || (exports.UnregistrationRequest = {}));
var ResourceOperationKind;
(function (ResourceOperationKind) {
    /**
     * Supports creating new files and folders.
     */
    ResourceOperationKind.Create = 'create';
    /**
     * Supports renaming existing files and folders.
     */
    ResourceOperationKind.Rename = 'rename';
    /**
     * Supports deleting existing files and folders.
     */
    ResourceOperationKind.Delete = 'delete';
})(ResourceOperationKind = exports.ResourceOperationKind || (exports.ResourceOperationKind = {}));
var FailureHandlingKind;
(function (FailureHandlingKind) {
    /**
     * Applying the workspace change is simply aborted if one of the changes provided
     * fails. All operations executed before the failing operation stay executed.
     */
    FailureHandlingKind.Abort = 'abort';
    /**
     * All operations are executed transactional. That means they either all
     * succeed or no changes at all are applied to the workspace.
     */
    FailureHandlingKind.Transactional = 'transactional';
    /**
     * If the workspace edit contains only textual file changes they are executed transactional.
     * If resource changes (create, rename or delete file) are part of the change the failure
     * handling strategy is abort.
     */
    FailureHandlingKind.TextOnlyTransactional = 'textOnlyTransactional';
    /**
     * The client tries to undo the operations already executed. But there is no
     * guarantee that this is succeeding.
     */
    FailureHandlingKind.Undo = 'undo';
})(FailureHandlingKind = exports.FailureHandlingKind || (exports.FailureHandlingKind = {}));
/**
 * The StaticRegistrationOptions namespace provides helper functions to work with
 * [StaticRegistrationOptions](#StaticRegistrationOptions) literals.
 */
var StaticRegistrationOptions;
(function (StaticRegistrationOptions) {
    function hasId(value) {
        const candidate = value;
        return candidate && Is.string(candidate.id) && candidate.id.length > 0;
    }
    StaticRegistrationOptions.hasId = hasId;
})(StaticRegistrationOptions = exports.StaticRegistrationOptions || (exports.StaticRegistrationOptions = {}));
/**
 * The TextDocumentRegistrationOptions namespace provides helper functions to work with
 * [TextDocumentRegistrationOptions](#TextDocumentRegistrationOptions) literals.
 */
var TextDocumentRegistrationOptions;
(function (TextDocumentRegistrationOptions) {
    function is(value) {
        const candidate = value;
        return candidate && (candidate.documentSelector === null || DocumentSelector.is(candidate.documentSelector));
    }
    TextDocumentRegistrationOptions.is = is;
})(TextDocumentRegistrationOptions = exports.TextDocumentRegistrationOptions || (exports.TextDocumentRegistrationOptions = {}));
/**
 * The WorkDoneProgressOptions namespace provides helper functions to work with
 * [WorkDoneProgressOptions](#WorkDoneProgressOptions) literals.
 */
var WorkDoneProgressOptions;
(function (WorkDoneProgressOptions) {
    function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && (candidate.workDoneProgress === undefined || Is.boolean(candidate.workDoneProgress));
    }
    WorkDoneProgressOptions.is = is;
    function hasWorkDoneProgress(value) {
        const candidate = value;
        return candidate && Is.boolean(candidate.workDoneProgress);
    }
    WorkDoneProgressOptions.hasWorkDoneProgress = hasWorkDoneProgress;
})(WorkDoneProgressOptions = exports.WorkDoneProgressOptions || (exports.WorkDoneProgressOptions = {}));
/**
 * The initialize request is sent from the client to the server.
 * It is sent once as the request after starting up the server.
 * The requests parameter is of type [InitializeParams](#InitializeParams)
 * the response if of type [InitializeResult](#InitializeResult) of a Thenable that
 * resolves to such.
 */
var InitializeRequest;
(function (InitializeRequest) {
    InitializeRequest.type = new messages_1.ProtocolRequestType('initialize');
})(InitializeRequest = exports.InitializeRequest || (exports.InitializeRequest = {}));
/**
 * Known error codes for an `InitializeError`;
 */
var InitializeError;
(function (InitializeError) {
    /**
     * If the protocol version provided by the client can't be handled by the server.
     * @deprecated This initialize error got replaced by client capabilities. There is
     * no version handshake in version 3.0x
     */
    InitializeError.unknownProtocolVersion = 1;
})(InitializeError = exports.InitializeError || (exports.InitializeError = {}));
/**
 * The initialized notification is sent from the client to the
 * server after the client is fully initialized and the server
 * is allowed to send requests from the server to the client.
 */
var InitializedNotification;
(function (InitializedNotification) {
    InitializedNotification.type = new messages_1.ProtocolNotificationType('initialized');
})(InitializedNotification = exports.InitializedNotification || (exports.InitializedNotification = {}));
//---- Shutdown Method ----
/**
 * A shutdown request is sent from the client to the server.
 * It is sent once when the client decides to shutdown the
 * server. The only notification that is sent after a shutdown request
 * is the exit event.
 */
var ShutdownRequest;
(function (ShutdownRequest) {
    ShutdownRequest.type = new messages_1.ProtocolRequestType0('shutdown');
})(ShutdownRequest = exports.ShutdownRequest || (exports.ShutdownRequest = {}));
//---- Exit Notification ----
/**
 * The exit event is sent from the client to the server to
 * ask the server to exit its process.
 */
var ExitNotification;
(function (ExitNotification) {
    ExitNotification.type = new messages_1.ProtocolNotificationType0('exit');
})(ExitNotification = exports.ExitNotification || (exports.ExitNotification = {}));
/**
 * The configuration change notification is sent from the client to the server
 * when the client's configuration has changed. The notification contains
 * the changed configuration as defined by the language client.
 */
var DidChangeConfigurationNotification;
(function (DidChangeConfigurationNotification) {
    DidChangeConfigurationNotification.type = new messages_1.ProtocolNotificationType('workspace/didChangeConfiguration');
})(DidChangeConfigurationNotification = exports.DidChangeConfigurationNotification || (exports.DidChangeConfigurationNotification = {}));
//---- Message show and log notifications ----
/**
 * The message type
 */
var MessageType;
(function (MessageType) {
    /**
     * An error message.
     */
    MessageType.Error = 1;
    /**
     * A warning message.
     */
    MessageType.Warning = 2;
    /**
     * An information message.
     */
    MessageType.Info = 3;
    /**
     * A log message.
     */
    MessageType.Log = 4;
})(MessageType = exports.MessageType || (exports.MessageType = {}));
/**
 * The show message notification is sent from a server to a client to ask
 * the client to display a particular message in the user interface.
 */
var ShowMessageNotification;
(function (ShowMessageNotification) {
    ShowMessageNotification.type = new messages_1.ProtocolNotificationType('window/showMessage');
})(ShowMessageNotification = exports.ShowMessageNotification || (exports.ShowMessageNotification = {}));
/**
 * The show message request is sent from the server to the client to show a message
 * and a set of options actions to the user.
 */
var ShowMessageRequest;
(function (ShowMessageRequest) {
    ShowMessageRequest.type = new messages_1.ProtocolRequestType('window/showMessageRequest');
})(ShowMessageRequest = exports.ShowMessageRequest || (exports.ShowMessageRequest = {}));
/**
 * The log message notification is sent from the server to the client to ask
 * the client to log a particular message.
 */
var LogMessageNotification;
(function (LogMessageNotification) {
    LogMessageNotification.type = new messages_1.ProtocolNotificationType('window/logMessage');
})(LogMessageNotification = exports.LogMessageNotification || (exports.LogMessageNotification = {}));
//---- Telemetry notification
/**
 * The telemetry event notification is sent from the server to the client to ask
 * the client to log telemetry data.
 */
var TelemetryEventNotification;
(function (TelemetryEventNotification) {
    TelemetryEventNotification.type = new messages_1.ProtocolNotificationType('telemetry/event');
})(TelemetryEventNotification = exports.TelemetryEventNotification || (exports.TelemetryEventNotification = {}));
/**
 * Defines how the host (editor) should sync
 * document changes to the language server.
 */
var TextDocumentSyncKind;
(function (TextDocumentSyncKind) {
    /**
     * Documents should not be synced at all.
     */
    TextDocumentSyncKind.None = 0;
    /**
     * Documents are synced by always sending the full content
     * of the document.
     */
    TextDocumentSyncKind.Full = 1;
    /**
     * Documents are synced by sending the full content on open.
     * After that only incremental updates to the document are
     * send.
     */
    TextDocumentSyncKind.Incremental = 2;
})(TextDocumentSyncKind = exports.TextDocumentSyncKind || (exports.TextDocumentSyncKind = {}));
/**
 * The document open notification is sent from the client to the server to signal
 * newly opened text documents. The document's truth is now managed by the client
 * and the server must not try to read the document's truth using the document's
 * uri. Open in this sense means it is managed by the client. It doesn't necessarily
 * mean that its content is presented in an editor. An open notification must not
 * be sent more than once without a corresponding close notification send before.
 * This means open and close notification must be balanced and the max open count
 * is one.
 */
var DidOpenTextDocumentNotification;
(function (DidOpenTextDocumentNotification) {
    DidOpenTextDocumentNotification.method = 'textDocument/didOpen';
    DidOpenTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidOpenTextDocumentNotification.method);
})(DidOpenTextDocumentNotification = exports.DidOpenTextDocumentNotification || (exports.DidOpenTextDocumentNotification = {}));
var TextDocumentContentChangeEvent;
(function (TextDocumentContentChangeEvent) {
    /**
     * Checks whether the information describes a delta event.
     */
    function isIncremental(event) {
        let candidate = event;
        return candidate !== undefined && candidate !== null &&
            typeof candidate.text === 'string' && candidate.range !== undefined &&
            (candidate.rangeLength === undefined || typeof candidate.rangeLength === 'number');
    }
    TextDocumentContentChangeEvent.isIncremental = isIncremental;
    /**
     * Checks whether the information describes a full replacement event.
     */
    function isFull(event) {
        let candidate = event;
        return candidate !== undefined && candidate !== null &&
            typeof candidate.text === 'string' && candidate.range === undefined && candidate.rangeLength === undefined;
    }
    TextDocumentContentChangeEvent.isFull = isFull;
})(TextDocumentContentChangeEvent = exports.TextDocumentContentChangeEvent || (exports.TextDocumentContentChangeEvent = {}));
/**
 * The document change notification is sent from the client to the server to signal
 * changes to a text document.
 */
var DidChangeTextDocumentNotification;
(function (DidChangeTextDocumentNotification) {
    DidChangeTextDocumentNotification.method = 'textDocument/didChange';
    DidChangeTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidChangeTextDocumentNotification.method);
})(DidChangeTextDocumentNotification = exports.DidChangeTextDocumentNotification || (exports.DidChangeTextDocumentNotification = {}));
/**
 * The document close notification is sent from the client to the server when
 * the document got closed in the client. The document's truth now exists where
 * the document's uri points to (e.g. if the document's uri is a file uri the
 * truth now exists on disk). As with the open notification the close notification
 * is about managing the document's content. Receiving a close notification
 * doesn't mean that the document was open in an editor before. A close
 * notification requires a previous open notification to be sent.
 */
var DidCloseTextDocumentNotification;
(function (DidCloseTextDocumentNotification) {
    DidCloseTextDocumentNotification.method = 'textDocument/didClose';
    DidCloseTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidCloseTextDocumentNotification.method);
})(DidCloseTextDocumentNotification = exports.DidCloseTextDocumentNotification || (exports.DidCloseTextDocumentNotification = {}));
/**
 * The document save notification is sent from the client to the server when
 * the document got saved in the client.
 */
var DidSaveTextDocumentNotification;
(function (DidSaveTextDocumentNotification) {
    DidSaveTextDocumentNotification.method = 'textDocument/didSave';
    DidSaveTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidSaveTextDocumentNotification.method);
})(DidSaveTextDocumentNotification = exports.DidSaveTextDocumentNotification || (exports.DidSaveTextDocumentNotification = {}));
/**
 * Represents reasons why a text document is saved.
 */
var TextDocumentSaveReason;
(function (TextDocumentSaveReason) {
    /**
     * Manually triggered, e.g. by the user pressing save, by starting debugging,
     * or by an API call.
     */
    TextDocumentSaveReason.Manual = 1;
    /**
     * Automatic after a delay.
     */
    TextDocumentSaveReason.AfterDelay = 2;
    /**
     * When the editor lost focus.
     */
    TextDocumentSaveReason.FocusOut = 3;
})(TextDocumentSaveReason = exports.TextDocumentSaveReason || (exports.TextDocumentSaveReason = {}));
/**
 * A document will save notification is sent from the client to the server before
 * the document is actually saved.
 */
var WillSaveTextDocumentNotification;
(function (WillSaveTextDocumentNotification) {
    WillSaveTextDocumentNotification.method = 'textDocument/willSave';
    WillSaveTextDocumentNotification.type = new messages_1.ProtocolNotificationType(WillSaveTextDocumentNotification.method);
})(WillSaveTextDocumentNotification = exports.WillSaveTextDocumentNotification || (exports.WillSaveTextDocumentNotification = {}));
/**
 * A document will save request is sent from the client to the server before
 * the document is actually saved. The request can return an array of TextEdits
 * which will be applied to the text document before it is saved. Please note that
 * clients might drop results if computing the text edits took too long or if a
 * server constantly fails on this request. This is done to keep the save fast and
 * reliable.
 */
var WillSaveTextDocumentWaitUntilRequest;
(function (WillSaveTextDocumentWaitUntilRequest) {
    WillSaveTextDocumentWaitUntilRequest.method = 'textDocument/willSaveWaitUntil';
    WillSaveTextDocumentWaitUntilRequest.type = new messages_1.ProtocolRequestType(WillSaveTextDocumentWaitUntilRequest.method);
})(WillSaveTextDocumentWaitUntilRequest = exports.WillSaveTextDocumentWaitUntilRequest || (exports.WillSaveTextDocumentWaitUntilRequest = {}));
/**
 * The watched files notification is sent from the client to the server when
 * the client detects changes to file watched by the language client.
 */
var DidChangeWatchedFilesNotification;
(function (DidChangeWatchedFilesNotification) {
    DidChangeWatchedFilesNotification.type = new messages_1.ProtocolNotificationType('workspace/didChangeWatchedFiles');
})(DidChangeWatchedFilesNotification = exports.DidChangeWatchedFilesNotification || (exports.DidChangeWatchedFilesNotification = {}));
/**
 * The file event type
 */
var FileChangeType;
(function (FileChangeType) {
    /**
     * The file got created.
     */
    FileChangeType.Created = 1;
    /**
     * The file got changed.
     */
    FileChangeType.Changed = 2;
    /**
     * The file got deleted.
     */
    FileChangeType.Deleted = 3;
})(FileChangeType = exports.FileChangeType || (exports.FileChangeType = {}));
var WatchKind;
(function (WatchKind) {
    /**
     * Interested in create events.
     */
    WatchKind.Create = 1;
    /**
     * Interested in change events
     */
    WatchKind.Change = 2;
    /**
     * Interested in delete events
     */
    WatchKind.Delete = 4;
})(WatchKind = exports.WatchKind || (exports.WatchKind = {}));
/**
 * Diagnostics notification are sent from the server to the client to signal
 * results of validation runs.
 */
var PublishDiagnosticsNotification;
(function (PublishDiagnosticsNotification) {
    PublishDiagnosticsNotification.type = new messages_1.ProtocolNotificationType('textDocument/publishDiagnostics');
})(PublishDiagnosticsNotification = exports.PublishDiagnosticsNotification || (exports.PublishDiagnosticsNotification = {}));
/**
 * How a completion was triggered
 */
var CompletionTriggerKind;
(function (CompletionTriggerKind) {
    /**
     * Completion was triggered by typing an identifier (24x7 code
     * complete), manual invocation (e.g Ctrl+Space) or via API.
     */
    CompletionTriggerKind.Invoked = 1;
    /**
     * Completion was triggered by a trigger character specified by
     * the `triggerCharacters` properties of the `CompletionRegistrationOptions`.
     */
    CompletionTriggerKind.TriggerCharacter = 2;
    /**
     * Completion was re-triggered as current completion list is incomplete
     */
    CompletionTriggerKind.TriggerForIncompleteCompletions = 3;
})(CompletionTriggerKind = exports.CompletionTriggerKind || (exports.CompletionTriggerKind = {}));
/**
 * Request to request completion at a given text document position. The request's
 * parameter is of type [TextDocumentPosition](#TextDocumentPosition) the response
 * is of type [CompletionItem[]](#CompletionItem) or [CompletionList](#CompletionList)
 * or a Thenable that resolves to such.
 *
 * The request can delay the computation of the [`detail`](#CompletionItem.detail)
 * and [`documentation`](#CompletionItem.documentation) properties to the `completionItem/resolve`
 * request. However, properties that are needed for the initial sorting and filtering, like `sortText`,
 * `filterText`, `insertText`, and `textEdit`, must not be changed during resolve.
 */
var CompletionRequest;
(function (CompletionRequest) {
    CompletionRequest.method = 'textDocument/completion';
    CompletionRequest.type = new messages_1.ProtocolRequestType(CompletionRequest.method);
})(CompletionRequest = exports.CompletionRequest || (exports.CompletionRequest = {}));
/**
 * Request to resolve additional information for a given completion item.The request's
 * parameter is of type [CompletionItem](#CompletionItem) the response
 * is of type [CompletionItem](#CompletionItem) or a Thenable that resolves to such.
 */
var CompletionResolveRequest;
(function (CompletionResolveRequest) {
    CompletionResolveRequest.method = 'completionItem/resolve';
    CompletionResolveRequest.type = new messages_1.ProtocolRequestType(CompletionResolveRequest.method);
})(CompletionResolveRequest = exports.CompletionResolveRequest || (exports.CompletionResolveRequest = {}));
/**
 * Request to request hover information at a given text document position. The request's
 * parameter is of type [TextDocumentPosition](#TextDocumentPosition) the response is of
 * type [Hover](#Hover) or a Thenable that resolves to such.
 */
var HoverRequest;
(function (HoverRequest) {
    HoverRequest.method = 'textDocument/hover';
    HoverRequest.type = new messages_1.ProtocolRequestType(HoverRequest.method);
})(HoverRequest = exports.HoverRequest || (exports.HoverRequest = {}));
/**
 * How a signature help was triggered.
 *
 * @since 3.15.0
 */
var SignatureHelpTriggerKind;
(function (SignatureHelpTriggerKind) {
    /**
     * Signature help was invoked manually by the user or by a command.
     */
    SignatureHelpTriggerKind.Invoked = 1;
    /**
     * Signature help was triggered by a trigger character.
     */
    SignatureHelpTriggerKind.TriggerCharacter = 2;
    /**
     * Signature help was triggered by the cursor moving or by the document content changing.
     */
    SignatureHelpTriggerKind.ContentChange = 3;
})(SignatureHelpTriggerKind = exports.SignatureHelpTriggerKind || (exports.SignatureHelpTriggerKind = {}));
var SignatureHelpRequest;
(function (SignatureHelpRequest) {
    SignatureHelpRequest.method = 'textDocument/signatureHelp';
    SignatureHelpRequest.type = new messages_1.ProtocolRequestType(SignatureHelpRequest.method);
})(SignatureHelpRequest = exports.SignatureHelpRequest || (exports.SignatureHelpRequest = {}));
/**
 * A request to resolve the definition location of a symbol at a given text
 * document position. The request's parameter is of type [TextDocumentPosition]
 * (#TextDocumentPosition) the response is of either type [Definition](#Definition)
 * or a typed array of [DefinitionLink](#DefinitionLink) or a Thenable that resolves
 * to such.
 */
var DefinitionRequest;
(function (DefinitionRequest) {
    DefinitionRequest.method = 'textDocument/definition';
    DefinitionRequest.type = new messages_1.ProtocolRequestType(DefinitionRequest.method);
})(DefinitionRequest = exports.DefinitionRequest || (exports.DefinitionRequest = {}));
/**
 * A request to resolve project-wide references for the symbol denoted
 * by the given text document position. The request's parameter is of
 * type [ReferenceParams](#ReferenceParams) the response is of type
 * [Location[]](#Location) or a Thenable that resolves to such.
 */
var ReferencesRequest;
(function (ReferencesRequest) {
    ReferencesRequest.method = 'textDocument/references';
    ReferencesRequest.type = new messages_1.ProtocolRequestType(ReferencesRequest.method);
})(ReferencesRequest = exports.ReferencesRequest || (exports.ReferencesRequest = {}));
/**
 * Request to resolve a [DocumentHighlight](#DocumentHighlight) for a given
 * text document position. The request's parameter is of type [TextDocumentPosition]
 * (#TextDocumentPosition) the request response is of type [DocumentHighlight[]]
 * (#DocumentHighlight) or a Thenable that resolves to such.
 */
var DocumentHighlightRequest;
(function (DocumentHighlightRequest) {
    DocumentHighlightRequest.method = 'textDocument/documentHighlight';
    DocumentHighlightRequest.type = new messages_1.ProtocolRequestType(DocumentHighlightRequest.method);
})(DocumentHighlightRequest = exports.DocumentHighlightRequest || (exports.DocumentHighlightRequest = {}));
/**
 * A request to list all symbols found in a given text document. The request's
 * parameter is of type [TextDocumentIdentifier](#TextDocumentIdentifier) the
 * response is of type [SymbolInformation[]](#SymbolInformation) or a Thenable
 * that resolves to such.
 */
var DocumentSymbolRequest;
(function (DocumentSymbolRequest) {
    DocumentSymbolRequest.method = 'textDocument/documentSymbol';
    DocumentSymbolRequest.type = new messages_1.ProtocolRequestType(DocumentSymbolRequest.method);
})(DocumentSymbolRequest = exports.DocumentSymbolRequest || (exports.DocumentSymbolRequest = {}));
/**
 * A request to provide commands for the given text document and range.
 */
var CodeActionRequest;
(function (CodeActionRequest) {
    CodeActionRequest.method = 'textDocument/codeAction';
    CodeActionRequest.type = new messages_1.ProtocolRequestType(CodeActionRequest.method);
})(CodeActionRequest = exports.CodeActionRequest || (exports.CodeActionRequest = {}));
/**
 * Request to resolve additional information for a given code action.The request's
 * parameter is of type [CodeAction](#CodeAction) the response
 * is of type [CodeAction](#CodeAction) or a Thenable that resolves to such.
 */
var CodeActionResolveRequest;
(function (CodeActionResolveRequest) {
    CodeActionResolveRequest.method = 'codeAction/resolve';
    CodeActionResolveRequest.type = new messages_1.ProtocolRequestType(CodeActionResolveRequest.method);
})(CodeActionResolveRequest = exports.CodeActionResolveRequest || (exports.CodeActionResolveRequest = {}));
/**
 * A request to list project-wide symbols matching the query string given
 * by the [WorkspaceSymbolParams](#WorkspaceSymbolParams). The response is
 * of type [SymbolInformation[]](#SymbolInformation) or a Thenable that
 * resolves to such.
 */
var WorkspaceSymbolRequest;
(function (WorkspaceSymbolRequest) {
    WorkspaceSymbolRequest.method = 'workspace/symbol';
    WorkspaceSymbolRequest.type = new messages_1.ProtocolRequestType(WorkspaceSymbolRequest.method);
})(WorkspaceSymbolRequest = exports.WorkspaceSymbolRequest || (exports.WorkspaceSymbolRequest = {}));
/**
 * A request to provide code lens for the given text document.
 */
var CodeLensRequest;
(function (CodeLensRequest) {
    CodeLensRequest.method = 'textDocument/codeLens';
    CodeLensRequest.type = new messages_1.ProtocolRequestType(CodeLensRequest.method);
})(CodeLensRequest = exports.CodeLensRequest || (exports.CodeLensRequest = {}));
/**
 * A request to resolve a command for a given code lens.
 */
var CodeLensResolveRequest;
(function (CodeLensResolveRequest) {
    CodeLensResolveRequest.method = 'codeLens/resolve';
    CodeLensResolveRequest.type = new messages_1.ProtocolRequestType(CodeLensResolveRequest.method);
})(CodeLensResolveRequest = exports.CodeLensResolveRequest || (exports.CodeLensResolveRequest = {}));
/**
 * A request to refresh all code actions
 *
 * @since 3.16.0
 */
var CodeLensRefreshRequest;
(function (CodeLensRefreshRequest) {
    CodeLensRefreshRequest.method = `workspace/codeLens/refresh`;
    CodeLensRefreshRequest.type = new messages_1.ProtocolRequestType0(CodeLensRefreshRequest.method);
})(CodeLensRefreshRequest = exports.CodeLensRefreshRequest || (exports.CodeLensRefreshRequest = {}));
/**
 * A request to provide document links
 */
var DocumentLinkRequest;
(function (DocumentLinkRequest) {
    DocumentLinkRequest.method = 'textDocument/documentLink';
    DocumentLinkRequest.type = new messages_1.ProtocolRequestType(DocumentLinkRequest.method);
})(DocumentLinkRequest = exports.DocumentLinkRequest || (exports.DocumentLinkRequest = {}));
/**
 * Request to resolve additional information for a given document link. The request's
 * parameter is of type [DocumentLink](#DocumentLink) the response
 * is of type [DocumentLink](#DocumentLink) or a Thenable that resolves to such.
 */
var DocumentLinkResolveRequest;
(function (DocumentLinkResolveRequest) {
    DocumentLinkResolveRequest.method = 'documentLink/resolve';
    DocumentLinkResolveRequest.type = new messages_1.ProtocolRequestType(DocumentLinkResolveRequest.method);
})(DocumentLinkResolveRequest = exports.DocumentLinkResolveRequest || (exports.DocumentLinkResolveRequest = {}));
/**
 * A request to to format a whole document.
 */
var DocumentFormattingRequest;
(function (DocumentFormattingRequest) {
    DocumentFormattingRequest.method = 'textDocument/formatting';
    DocumentFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentFormattingRequest.method);
})(DocumentFormattingRequest = exports.DocumentFormattingRequest || (exports.DocumentFormattingRequest = {}));
/**
 * A request to to format a range in a document.
 */
var DocumentRangeFormattingRequest;
(function (DocumentRangeFormattingRequest) {
    DocumentRangeFormattingRequest.method = 'textDocument/rangeFormatting';
    DocumentRangeFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentRangeFormattingRequest.method);
})(DocumentRangeFormattingRequest = exports.DocumentRangeFormattingRequest || (exports.DocumentRangeFormattingRequest = {}));
/**
 * A request to format a document on type.
 */
var DocumentOnTypeFormattingRequest;
(function (DocumentOnTypeFormattingRequest) {
    DocumentOnTypeFormattingRequest.method = 'textDocument/onTypeFormatting';
    DocumentOnTypeFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentOnTypeFormattingRequest.method);
})(DocumentOnTypeFormattingRequest = exports.DocumentOnTypeFormattingRequest || (exports.DocumentOnTypeFormattingRequest = {}));
//---- Rename ----------------------------------------------
var PrepareSupportDefaultBehavior;
(function (PrepareSupportDefaultBehavior) {
    /**
     * The client's default behavior is to select the identifier
     * according the to language's syntax rule.
     */
    PrepareSupportDefaultBehavior.Identifier = 1;
})(PrepareSupportDefaultBehavior = exports.PrepareSupportDefaultBehavior || (exports.PrepareSupportDefaultBehavior = {}));
/**
 * A request to rename a symbol.
 */
var RenameRequest;
(function (RenameRequest) {
    RenameRequest.method = 'textDocument/rename';
    RenameRequest.type = new messages_1.ProtocolRequestType(RenameRequest.method);
})(RenameRequest = exports.RenameRequest || (exports.RenameRequest = {}));
/**
 * A request to test and perform the setup necessary for a rename.
 *
 * @since 3.16 - support for default behavior
 */
var PrepareRenameRequest;
(function (PrepareRenameRequest) {
    PrepareRenameRequest.method = 'textDocument/prepareRename';
    PrepareRenameRequest.type = new messages_1.ProtocolRequestType(PrepareRenameRequest.method);
})(PrepareRenameRequest = exports.PrepareRenameRequest || (exports.PrepareRenameRequest = {}));
/**
 * A request send from the client to the server to execute a command. The request might return
 * a workspace edit which the client will apply to the workspace.
 */
var ExecuteCommandRequest;
(function (ExecuteCommandRequest) {
    ExecuteCommandRequest.type = new messages_1.ProtocolRequestType('workspace/executeCommand');
})(ExecuteCommandRequest = exports.ExecuteCommandRequest || (exports.ExecuteCommandRequest = {}));
/**
 * A request sent from the server to the client to modified certain resources.
 */
var ApplyWorkspaceEditRequest;
(function (ApplyWorkspaceEditRequest) {
    ApplyWorkspaceEditRequest.type = new messages_1.ProtocolRequestType('workspace/applyEdit');
})(ApplyWorkspaceEditRequest = exports.ApplyWorkspaceEditRequest || (exports.ApplyWorkspaceEditRequest = {}));
//# sourceMappingURL=protocol.js.map

/***/ }),
/* 158 */
/***/ ((__unused_webpack_module, exports) => {

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.objectLiteral = exports.typedArray = exports.stringArray = exports.array = exports.func = exports.error = exports.number = exports.string = exports.boolean = void 0;
function boolean(value) {
    return value === true || value === false;
}
exports.boolean = boolean;
function string(value) {
    return typeof value === 'string' || value instanceof String;
}
exports.string = string;
function number(value) {
    return typeof value === 'number' || value instanceof Number;
}
exports.number = number;
function error(value) {
    return value instanceof Error;
}
exports.error = error;
function func(value) {
    return typeof value === 'function';
}
exports.func = func;
function array(value) {
    return Array.isArray(value);
}
exports.array = array;
function stringArray(value) {
    return array(value) && value.every(elem => string(elem));
}
exports.stringArray = stringArray;
function typedArray(value, check) {
    return Array.isArray(value) && value.every(check);
}
exports.typedArray = typedArray;
function objectLiteral(value) {
    // Strictly speaking class instances pass this check as well. Since the LSP
    // doesn't use classes we ignore this for now. If we do we need to add something
    // like this: `Object.getPrototypeOf(Object.getPrototypeOf(x)) === null`
    return value !== null && typeof value === 'object';
}
exports.objectLiteral = objectLiteral;
//# sourceMappingURL=is.js.map

/***/ }),
/* 159 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ImplementationRequest = void 0;
const messages_1 = __webpack_require__(156);
// @ts-ignore: to avoid inlining LocatioLink as dynamic import
let __noDynamicImport;
/**
 * A request to resolve the implementation locations of a symbol at a given text
 * document position. The request's parameter is of type [TextDocumentPositioParams]
 * (#TextDocumentPositionParams) the response is of type [Definition](#Definition) or a
 * Thenable that resolves to such.
 */
var ImplementationRequest;
(function (ImplementationRequest) {
    ImplementationRequest.method = 'textDocument/implementation';
    ImplementationRequest.type = new messages_1.ProtocolRequestType(ImplementationRequest.method);
})(ImplementationRequest = exports.ImplementationRequest || (exports.ImplementationRequest = {}));
//# sourceMappingURL=protocol.implementation.js.map

/***/ }),
/* 160 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TypeDefinitionRequest = void 0;
const messages_1 = __webpack_require__(156);
// @ts-ignore: to avoid inlining LocatioLink as dynamic import
let __noDynamicImport;
/**
 * A request to resolve the type definition locations of a symbol at a given text
 * document position. The request's parameter is of type [TextDocumentPositioParams]
 * (#TextDocumentPositionParams) the response is of type [Definition](#Definition) or a
 * Thenable that resolves to such.
 */
var TypeDefinitionRequest;
(function (TypeDefinitionRequest) {
    TypeDefinitionRequest.method = 'textDocument/typeDefinition';
    TypeDefinitionRequest.type = new messages_1.ProtocolRequestType(TypeDefinitionRequest.method);
})(TypeDefinitionRequest = exports.TypeDefinitionRequest || (exports.TypeDefinitionRequest = {}));
//# sourceMappingURL=protocol.typeDefinition.js.map

/***/ }),
/* 161 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DidChangeWorkspaceFoldersNotification = exports.WorkspaceFoldersRequest = void 0;
const messages_1 = __webpack_require__(156);
/**
 * The `workspace/workspaceFolders` is sent from the server to the client to fetch the open workspace folders.
 */
var WorkspaceFoldersRequest;
(function (WorkspaceFoldersRequest) {
    WorkspaceFoldersRequest.type = new messages_1.ProtocolRequestType0('workspace/workspaceFolders');
})(WorkspaceFoldersRequest = exports.WorkspaceFoldersRequest || (exports.WorkspaceFoldersRequest = {}));
/**
 * The `workspace/didChangeWorkspaceFolders` notification is sent from the client to the server when the workspace
 * folder configuration changes.
 */
var DidChangeWorkspaceFoldersNotification;
(function (DidChangeWorkspaceFoldersNotification) {
    DidChangeWorkspaceFoldersNotification.type = new messages_1.ProtocolNotificationType('workspace/didChangeWorkspaceFolders');
})(DidChangeWorkspaceFoldersNotification = exports.DidChangeWorkspaceFoldersNotification || (exports.DidChangeWorkspaceFoldersNotification = {}));
//# sourceMappingURL=protocol.workspaceFolders.js.map

/***/ }),
/* 162 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConfigurationRequest = void 0;
const messages_1 = __webpack_require__(156);
/**
 * The 'workspace/configuration' request is sent from the server to the client to fetch a certain
 * configuration setting.
 *
 * This pull model replaces the old push model were the client signaled configuration change via an
 * event. If the server still needs to react to configuration changes (since the server caches the
 * result of `workspace/configuration` requests) the server should register for an empty configuration
 * change event and empty the cache if such an event is received.
 */
var ConfigurationRequest;
(function (ConfigurationRequest) {
    ConfigurationRequest.type = new messages_1.ProtocolRequestType('workspace/configuration');
})(ConfigurationRequest = exports.ConfigurationRequest || (exports.ConfigurationRequest = {}));
//# sourceMappingURL=protocol.configuration.js.map

/***/ }),
/* 163 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ColorPresentationRequest = exports.DocumentColorRequest = void 0;
const messages_1 = __webpack_require__(156);
/**
 * A request to list all color symbols found in a given text document. The request's
 * parameter is of type [DocumentColorParams](#DocumentColorParams) the
 * response is of type [ColorInformation[]](#ColorInformation) or a Thenable
 * that resolves to such.
 */
var DocumentColorRequest;
(function (DocumentColorRequest) {
    DocumentColorRequest.method = 'textDocument/documentColor';
    DocumentColorRequest.type = new messages_1.ProtocolRequestType(DocumentColorRequest.method);
})(DocumentColorRequest = exports.DocumentColorRequest || (exports.DocumentColorRequest = {}));
/**
 * A request to list all presentation for a color. The request's
 * parameter is of type [ColorPresentationParams](#ColorPresentationParams) the
 * response is of type [ColorInformation[]](#ColorInformation) or a Thenable
 * that resolves to such.
 */
var ColorPresentationRequest;
(function (ColorPresentationRequest) {
    ColorPresentationRequest.type = new messages_1.ProtocolRequestType('textDocument/colorPresentation');
})(ColorPresentationRequest = exports.ColorPresentationRequest || (exports.ColorPresentationRequest = {}));
//# sourceMappingURL=protocol.colorProvider.js.map

/***/ }),
/* 164 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FoldingRangeRequest = exports.FoldingRangeKind = void 0;
const messages_1 = __webpack_require__(156);
/**
 * Enum of known range kinds
 */
var FoldingRangeKind;
(function (FoldingRangeKind) {
    /**
     * Folding range for a comment
     */
    FoldingRangeKind["Comment"] = "comment";
    /**
     * Folding range for a imports or includes
     */
    FoldingRangeKind["Imports"] = "imports";
    /**
     * Folding range for a region (e.g. `#region`)
     */
    FoldingRangeKind["Region"] = "region";
})(FoldingRangeKind = exports.FoldingRangeKind || (exports.FoldingRangeKind = {}));
/**
 * A request to provide folding ranges in a document. The request's
 * parameter is of type [FoldingRangeParams](#FoldingRangeParams), the
 * response is of type [FoldingRangeList](#FoldingRangeList) or a Thenable
 * that resolves to such.
 */
var FoldingRangeRequest;
(function (FoldingRangeRequest) {
    FoldingRangeRequest.method = 'textDocument/foldingRange';
    FoldingRangeRequest.type = new messages_1.ProtocolRequestType(FoldingRangeRequest.method);
})(FoldingRangeRequest = exports.FoldingRangeRequest || (exports.FoldingRangeRequest = {}));
//# sourceMappingURL=protocol.foldingRange.js.map

/***/ }),
/* 165 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeclarationRequest = void 0;
const messages_1 = __webpack_require__(156);
// @ts-ignore: to avoid inlining LocatioLink as dynamic import
let __noDynamicImport;
/**
 * A request to resolve the type definition locations of a symbol at a given text
 * document position. The request's parameter is of type [TextDocumentPositioParams]
 * (#TextDocumentPositionParams) the response is of type [Declaration](#Declaration)
 * or a typed array of [DeclarationLink](#DeclarationLink) or a Thenable that resolves
 * to such.
 */
var DeclarationRequest;
(function (DeclarationRequest) {
    DeclarationRequest.method = 'textDocument/declaration';
    DeclarationRequest.type = new messages_1.ProtocolRequestType(DeclarationRequest.method);
})(DeclarationRequest = exports.DeclarationRequest || (exports.DeclarationRequest = {}));
//# sourceMappingURL=protocol.declaration.js.map

/***/ }),
/* 166 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SelectionRangeRequest = void 0;
const messages_1 = __webpack_require__(156);
/**
 * A request to provide selection ranges in a document. The request's
 * parameter is of type [SelectionRangeParams](#SelectionRangeParams), the
 * response is of type [SelectionRange[]](#SelectionRange[]) or a Thenable
 * that resolves to such.
 */
var SelectionRangeRequest;
(function (SelectionRangeRequest) {
    SelectionRangeRequest.method = 'textDocument/selectionRange';
    SelectionRangeRequest.type = new messages_1.ProtocolRequestType(SelectionRangeRequest.method);
})(SelectionRangeRequest = exports.SelectionRangeRequest || (exports.SelectionRangeRequest = {}));
//# sourceMappingURL=protocol.selectionRange.js.map

/***/ }),
/* 167 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WorkDoneProgressCancelNotification = exports.WorkDoneProgressCreateRequest = exports.WorkDoneProgress = void 0;
const vscode_jsonrpc_1 = __webpack_require__(136);
const messages_1 = __webpack_require__(156);
var WorkDoneProgress;
(function (WorkDoneProgress) {
    WorkDoneProgress.type = new vscode_jsonrpc_1.ProgressType();
    function is(value) {
        return value === WorkDoneProgress.type;
    }
    WorkDoneProgress.is = is;
})(WorkDoneProgress = exports.WorkDoneProgress || (exports.WorkDoneProgress = {}));
/**
 * The `window/workDoneProgress/create` request is sent from the server to the client to initiate progress
 * reporting from the server.
 */
var WorkDoneProgressCreateRequest;
(function (WorkDoneProgressCreateRequest) {
    WorkDoneProgressCreateRequest.type = new messages_1.ProtocolRequestType('window/workDoneProgress/create');
})(WorkDoneProgressCreateRequest = exports.WorkDoneProgressCreateRequest || (exports.WorkDoneProgressCreateRequest = {}));
/**
 * The `window/workDoneProgress/cancel` notification is sent from  the client to the server to cancel a progress
 * initiated on the server side.
 */
var WorkDoneProgressCancelNotification;
(function (WorkDoneProgressCancelNotification) {
    WorkDoneProgressCancelNotification.type = new messages_1.ProtocolNotificationType('window/workDoneProgress/cancel');
})(WorkDoneProgressCancelNotification = exports.WorkDoneProgressCancelNotification || (exports.WorkDoneProgressCancelNotification = {}));
//# sourceMappingURL=protocol.progress.js.map

/***/ }),
/* 168 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/* --------------------------------------------------------------------------------------------
 * Copyright (c) TypeFox, Microsoft and others. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CallHierarchyOutgoingCallsRequest = exports.CallHierarchyIncomingCallsRequest = exports.CallHierarchyPrepareRequest = void 0;
const messages_1 = __webpack_require__(156);
/**
 * A request to result a `CallHierarchyItem` in a document at a given position.
 * Can be used as an input to a incoming or outgoing call hierarchy.
 *
 * @since 3.16.0
 */
var CallHierarchyPrepareRequest;
(function (CallHierarchyPrepareRequest) {
    CallHierarchyPrepareRequest.method = 'textDocument/prepareCallHierarchy';
    CallHierarchyPrepareRequest.type = new messages_1.ProtocolRequestType(CallHierarchyPrepareRequest.method);
})(CallHierarchyPrepareRequest = exports.CallHierarchyPrepareRequest || (exports.CallHierarchyPrepareRequest = {}));
/**
 * A request to resolve the incoming calls for a given `CallHierarchyItem`.
 *
 * @since 3.16.0
 */
var CallHierarchyIncomingCallsRequest;
(function (CallHierarchyIncomingCallsRequest) {
    CallHierarchyIncomingCallsRequest.method = 'callHierarchy/incomingCalls';
    CallHierarchyIncomingCallsRequest.type = new messages_1.ProtocolRequestType(CallHierarchyIncomingCallsRequest.method);
})(CallHierarchyIncomingCallsRequest = exports.CallHierarchyIncomingCallsRequest || (exports.CallHierarchyIncomingCallsRequest = {}));
/**
 * A request to resolve the outgoing calls for a given `CallHierarchyItem`.
 *
 * @since 3.16.0
 */
var CallHierarchyOutgoingCallsRequest;
(function (CallHierarchyOutgoingCallsRequest) {
    CallHierarchyOutgoingCallsRequest.method = 'callHierarchy/outgoingCalls';
    CallHierarchyOutgoingCallsRequest.type = new messages_1.ProtocolRequestType(CallHierarchyOutgoingCallsRequest.method);
})(CallHierarchyOutgoingCallsRequest = exports.CallHierarchyOutgoingCallsRequest || (exports.CallHierarchyOutgoingCallsRequest = {}));
//# sourceMappingURL=protocol.callHierarchy.js.map

/***/ }),
/* 169 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SemanticTokensRefreshRequest = exports.SemanticTokensRangeRequest = exports.SemanticTokensDeltaRequest = exports.SemanticTokensRequest = exports.SemanticTokensRegistrationType = exports.TokenFormat = void 0;
const messages_1 = __webpack_require__(156);
//------- 'textDocument/semanticTokens' -----
var TokenFormat;
(function (TokenFormat) {
    TokenFormat.Relative = 'relative';
})(TokenFormat = exports.TokenFormat || (exports.TokenFormat = {}));
var SemanticTokensRegistrationType;
(function (SemanticTokensRegistrationType) {
    SemanticTokensRegistrationType.method = 'textDocument/semanticTokens';
    SemanticTokensRegistrationType.type = new messages_1.RegistrationType(SemanticTokensRegistrationType.method);
})(SemanticTokensRegistrationType = exports.SemanticTokensRegistrationType || (exports.SemanticTokensRegistrationType = {}));
/**
 * @since 3.16.0
 */
var SemanticTokensRequest;
(function (SemanticTokensRequest) {
    SemanticTokensRequest.method = 'textDocument/semanticTokens/full';
    SemanticTokensRequest.type = new messages_1.ProtocolRequestType(SemanticTokensRequest.method);
})(SemanticTokensRequest = exports.SemanticTokensRequest || (exports.SemanticTokensRequest = {}));
/**
 * @since 3.16.0
 */
var SemanticTokensDeltaRequest;
(function (SemanticTokensDeltaRequest) {
    SemanticTokensDeltaRequest.method = 'textDocument/semanticTokens/full/delta';
    SemanticTokensDeltaRequest.type = new messages_1.ProtocolRequestType(SemanticTokensDeltaRequest.method);
})(SemanticTokensDeltaRequest = exports.SemanticTokensDeltaRequest || (exports.SemanticTokensDeltaRequest = {}));
/**
 * @since 3.16.0
 */
var SemanticTokensRangeRequest;
(function (SemanticTokensRangeRequest) {
    SemanticTokensRangeRequest.method = 'textDocument/semanticTokens/range';
    SemanticTokensRangeRequest.type = new messages_1.ProtocolRequestType(SemanticTokensRangeRequest.method);
})(SemanticTokensRangeRequest = exports.SemanticTokensRangeRequest || (exports.SemanticTokensRangeRequest = {}));
/**
 * @since 3.16.0
 */
var SemanticTokensRefreshRequest;
(function (SemanticTokensRefreshRequest) {
    SemanticTokensRefreshRequest.method = `workspace/semanticTokens/refresh`;
    SemanticTokensRefreshRequest.type = new messages_1.ProtocolRequestType0(SemanticTokensRefreshRequest.method);
})(SemanticTokensRefreshRequest = exports.SemanticTokensRefreshRequest || (exports.SemanticTokensRefreshRequest = {}));
//# sourceMappingURL=protocol.semanticTokens.js.map

/***/ }),
/* 170 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ShowDocumentRequest = void 0;
const messages_1 = __webpack_require__(156);
/**
 * A request to show a document. This request might open an
 * external program depending on the value of the URI to open.
 * For example a request to open `https://code.visualstudio.com/`
 * will very likely open the URI in a WEB browser.
 *
 * @since 3.16.0
*/
var ShowDocumentRequest;
(function (ShowDocumentRequest) {
    ShowDocumentRequest.method = 'window/showDocument';
    ShowDocumentRequest.type = new messages_1.ProtocolRequestType(ShowDocumentRequest.method);
})(ShowDocumentRequest = exports.ShowDocumentRequest || (exports.ShowDocumentRequest = {}));
//# sourceMappingURL=protocol.showDocument.js.map

/***/ }),
/* 171 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LinkedEditingRangeRequest = void 0;
const messages_1 = __webpack_require__(156);
/**
 * A request to provide ranges that can be edited together.
 *
 * @since 3.16.0
 */
var LinkedEditingRangeRequest;
(function (LinkedEditingRangeRequest) {
    LinkedEditingRangeRequest.method = 'textDocument/linkedEditingRange';
    LinkedEditingRangeRequest.type = new messages_1.ProtocolRequestType(LinkedEditingRangeRequest.method);
})(LinkedEditingRangeRequest = exports.LinkedEditingRangeRequest || (exports.LinkedEditingRangeRequest = {}));
//# sourceMappingURL=protocol.linkedEditingRange.js.map

/***/ }),
/* 172 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WillDeleteFilesRequest = exports.DidDeleteFilesNotification = exports.DidRenameFilesNotification = exports.WillRenameFilesRequest = exports.DidCreateFilesNotification = exports.WillCreateFilesRequest = exports.FileOperationPatternKind = void 0;
const messages_1 = __webpack_require__(156);
/**
 * A pattern kind describing if a glob pattern matches a file a folder or
 * both.
 *
 * @since 3.16.0
 */
var FileOperationPatternKind;
(function (FileOperationPatternKind) {
    /**
     * The pattern matches a file only.
     */
    FileOperationPatternKind.file = 'file';
    /**
     * The pattern matches a folder only.
     */
    FileOperationPatternKind.folder = 'folder';
})(FileOperationPatternKind = exports.FileOperationPatternKind || (exports.FileOperationPatternKind = {}));
/**
 * The will create files request is sent from the client to the server before files are actually
 * created as long as the creation is triggered from within the client.
 *
 * @since 3.16.0
 */
var WillCreateFilesRequest;
(function (WillCreateFilesRequest) {
    WillCreateFilesRequest.method = 'workspace/willCreateFiles';
    WillCreateFilesRequest.type = new messages_1.ProtocolRequestType(WillCreateFilesRequest.method);
})(WillCreateFilesRequest = exports.WillCreateFilesRequest || (exports.WillCreateFilesRequest = {}));
/**
 * The did create files notification is sent from the client to the server when
 * files were created from within the client.
 *
 * @since 3.16.0
 */
var DidCreateFilesNotification;
(function (DidCreateFilesNotification) {
    DidCreateFilesNotification.method = 'workspace/didCreateFiles';
    DidCreateFilesNotification.type = new messages_1.ProtocolNotificationType(DidCreateFilesNotification.method);
})(DidCreateFilesNotification = exports.DidCreateFilesNotification || (exports.DidCreateFilesNotification = {}));
/**
 * The will rename files request is sent from the client to the server before files are actually
 * renamed as long as the rename is triggered from within the client.
 *
 * @since 3.16.0
 */
var WillRenameFilesRequest;
(function (WillRenameFilesRequest) {
    WillRenameFilesRequest.method = 'workspace/willRenameFiles';
    WillRenameFilesRequest.type = new messages_1.ProtocolRequestType(WillRenameFilesRequest.method);
})(WillRenameFilesRequest = exports.WillRenameFilesRequest || (exports.WillRenameFilesRequest = {}));
/**
 * The did rename files notification is sent from the client to the server when
 * files were renamed from within the client.
 *
 * @since 3.16.0
 */
var DidRenameFilesNotification;
(function (DidRenameFilesNotification) {
    DidRenameFilesNotification.method = 'workspace/didRenameFiles';
    DidRenameFilesNotification.type = new messages_1.ProtocolNotificationType(DidRenameFilesNotification.method);
})(DidRenameFilesNotification = exports.DidRenameFilesNotification || (exports.DidRenameFilesNotification = {}));
/**
 * The will delete files request is sent from the client to the server before files are actually
 * deleted as long as the deletion is triggered from within the client.
 *
 * @since 3.16.0
 */
var DidDeleteFilesNotification;
(function (DidDeleteFilesNotification) {
    DidDeleteFilesNotification.method = 'workspace/didDeleteFiles';
    DidDeleteFilesNotification.type = new messages_1.ProtocolNotificationType(DidDeleteFilesNotification.method);
})(DidDeleteFilesNotification = exports.DidDeleteFilesNotification || (exports.DidDeleteFilesNotification = {}));
/**
 * The did delete files notification is sent from the client to the server when
 * files were deleted from within the client.
 *
 * @since 3.16.0
 */
var WillDeleteFilesRequest;
(function (WillDeleteFilesRequest) {
    WillDeleteFilesRequest.method = 'workspace/willDeleteFiles';
    WillDeleteFilesRequest.type = new messages_1.ProtocolRequestType(WillDeleteFilesRequest.method);
})(WillDeleteFilesRequest = exports.WillDeleteFilesRequest || (exports.WillDeleteFilesRequest = {}));
//# sourceMappingURL=protocol.fileOperations.js.map

/***/ }),
/* 173 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MonikerRequest = exports.MonikerKind = exports.UniquenessLevel = void 0;
const messages_1 = __webpack_require__(156);
/**
 * Moniker uniqueness level to define scope of the moniker.
 *
 * @since 3.16.0
 */
var UniquenessLevel;
(function (UniquenessLevel) {
    /**
     * The moniker is only unique inside a document
     */
    UniquenessLevel["document"] = "document";
    /**
     * The moniker is unique inside a project for which a dump got created
     */
    UniquenessLevel["project"] = "project";
    /**
     * The moniker is unique inside the group to which a project belongs
     */
    UniquenessLevel["group"] = "group";
    /**
     * The moniker is unique inside the moniker scheme.
     */
    UniquenessLevel["scheme"] = "scheme";
    /**
     * The moniker is globally unique
     */
    UniquenessLevel["global"] = "global";
})(UniquenessLevel = exports.UniquenessLevel || (exports.UniquenessLevel = {}));
/**
 * The moniker kind.
 *
 * @since 3.16.0
 */
var MonikerKind;
(function (MonikerKind) {
    /**
     * The moniker represent a symbol that is imported into a project
     */
    MonikerKind["import"] = "import";
    /**
     * The moniker represents a symbol that is exported from a project
     */
    MonikerKind["export"] = "export";
    /**
     * The moniker represents a symbol that is local to a project (e.g. a local
     * variable of a function, a class not visible outside the project, ...)
     */
    MonikerKind["local"] = "local";
})(MonikerKind = exports.MonikerKind || (exports.MonikerKind = {}));
/**
 * A request to get the moniker of a symbol at a given text document position.
 * The request parameter is of type [TextDocumentPositionParams](#TextDocumentPositionParams).
 * The response is of type [Moniker[]](#Moniker[]) or `null`.
 */
var MonikerRequest;
(function (MonikerRequest) {
    MonikerRequest.method = 'textDocument/moniker';
    MonikerRequest.type = new messages_1.ProtocolRequestType(MonikerRequest.method);
})(MonikerRequest = exports.MonikerRequest || (exports.MonikerRequest = {}));
//# sourceMappingURL=protocol.moniker.js.map

/***/ }),
/* 174 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createProtocolConnection = void 0;
const vscode_jsonrpc_1 = __webpack_require__(136);
function createProtocolConnection(input, output, logger, options) {
    if (vscode_jsonrpc_1.ConnectionStrategy.is(options)) {
        options = { connectionStrategy: options };
    }
    return vscode_jsonrpc_1.createMessageConnection(input, output, logger, options);
}
exports.createProtocolConnection = createProtocolConnection;
//# sourceMappingURL=connection.js.map

/***/ }),
/* 175 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DiagnosticRefreshRequest = exports.WorkspaceDiagnosticRequest = exports.DocumentDiagnosticRequest = exports.DocumentDiagnosticReportKind = exports.DiagnosticServerCancellationData = void 0;
const vscode_jsonrpc_1 = __webpack_require__(136);
const Is = __webpack_require__(158);
const messages_1 = __webpack_require__(156);
/**
 * @since 3.17.0 - proposed state
 */
var DiagnosticServerCancellationData;
(function (DiagnosticServerCancellationData) {
    function is(value) {
        const candidate = value;
        return candidate && Is.boolean(candidate.retriggerRequest);
    }
    DiagnosticServerCancellationData.is = is;
})(DiagnosticServerCancellationData = exports.DiagnosticServerCancellationData || (exports.DiagnosticServerCancellationData = {}));
/**
 * The document diagnostic report kinds.
 *
 * @since 3.17.0 - proposed state
 */
var DocumentDiagnosticReportKind;
(function (DocumentDiagnosticReportKind) {
    /**
     * A diagnostic report with a full
     * set of problems.
     */
    DocumentDiagnosticReportKind["full"] = "full";
    /**
     * A report indicating that the last
     * returned report is still accurate.
     */
    DocumentDiagnosticReportKind["unChanged"] = "unChanged";
})(DocumentDiagnosticReportKind = exports.DocumentDiagnosticReportKind || (exports.DocumentDiagnosticReportKind = {}));
/**
 * The document diagnostic request definition.
 *
 * @since 3.17.0 - proposed state
 */
var DocumentDiagnosticRequest;
(function (DocumentDiagnosticRequest) {
    DocumentDiagnosticRequest.method = 'textDocument/diagnostic';
    DocumentDiagnosticRequest.type = new messages_1.ProtocolRequestType(DocumentDiagnosticRequest.method);
    DocumentDiagnosticRequest.partialResult = new vscode_jsonrpc_1.ProgressType();
})(DocumentDiagnosticRequest = exports.DocumentDiagnosticRequest || (exports.DocumentDiagnosticRequest = {}));
/**
 * The workspace diagnostic request definition.
 *
 * @since 3.17.0 - proposed state
 */
var WorkspaceDiagnosticRequest;
(function (WorkspaceDiagnosticRequest) {
    WorkspaceDiagnosticRequest.method = 'workspace/diagnostic';
    WorkspaceDiagnosticRequest.type = new messages_1.ProtocolRequestType(WorkspaceDiagnosticRequest.method);
    WorkspaceDiagnosticRequest.partialResult = new vscode_jsonrpc_1.ProgressType();
})(WorkspaceDiagnosticRequest = exports.WorkspaceDiagnosticRequest || (exports.WorkspaceDiagnosticRequest = {}));
/**
 * The diagnostic refresh request definition.
 *
 * @since 3.17.0 - proposed state
 */
var DiagnosticRefreshRequest;
(function (DiagnosticRefreshRequest) {
    DiagnosticRefreshRequest.method = `workspace/diagnostic/refresh`;
    DiagnosticRefreshRequest.type = new messages_1.ProtocolRequestType0(DiagnosticRefreshRequest.method);
})(DiagnosticRefreshRequest = exports.DiagnosticRefreshRequest || (exports.DiagnosticRefreshRequest = {}));
//# sourceMappingURL=proposed.diagnostic.js.map

/***/ }),
/* 176 */
/***/ ((__unused_webpack_module, exports) => {


/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.asPromise = exports.thenable = exports.typedArray = exports.stringArray = exports.array = exports.func = exports.error = exports.number = exports.string = exports.boolean = void 0;
function boolean(value) {
    return value === true || value === false;
}
exports.boolean = boolean;
function string(value) {
    return typeof value === 'string' || value instanceof String;
}
exports.string = string;
function number(value) {
    return typeof value === 'number' || value instanceof Number;
}
exports.number = number;
function error(value) {
    return value instanceof Error;
}
exports.error = error;
function func(value) {
    return typeof value === 'function';
}
exports.func = func;
function array(value) {
    return Array.isArray(value);
}
exports.array = array;
function stringArray(value) {
    return array(value) && value.every(elem => string(elem));
}
exports.stringArray = stringArray;
function typedArray(value, check) {
    return Array.isArray(value) && value.every(check);
}
exports.typedArray = typedArray;
function thenable(value) {
    return value && func(value.then);
}
exports.thenable = thenable;
function asPromise(value) {
    if (value instanceof Promise) {
        return value;
    }
    else if (thenable(value)) {
        return new Promise((resolve, reject) => {
            value.then((resolved) => resolve(resolved), (error) => reject(error));
        });
    }
    else {
        return Promise.resolve(value);
    }
}
exports.asPromise = asPromise;
//# sourceMappingURL=is.js.map

/***/ }),
/* 177 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
const code = __webpack_require__(1);
class ProtocolCompletionItem extends code.CompletionItem {
    constructor(label) {
        super(label);
    }
}
exports["default"] = ProtocolCompletionItem;
//# sourceMappingURL=protocolCompletionItem.js.map

/***/ }),
/* 178 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
const code = __webpack_require__(1);
class ProtocolCodeLens extends code.CodeLens {
    constructor(range) {
        super(range);
    }
}
exports["default"] = ProtocolCodeLens;
//# sourceMappingURL=protocolCodeLens.js.map

/***/ }),
/* 179 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
const code = __webpack_require__(1);
class ProtocolDocumentLink extends code.DocumentLink {
    constructor(range, target) {
        super(range, target);
    }
}
exports["default"] = ProtocolDocumentLink;
//# sourceMappingURL=protocolDocumentLink.js.map

/***/ }),
/* 180 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
const vscode = __webpack_require__(1);
class ProtocolCodeAction extends vscode.CodeAction {
    constructor(title, data) {
        super(title);
        this.data = data;
    }
}
exports["default"] = ProtocolCodeAction;
//# sourceMappingURL=protocolCodeAction.js.map

/***/ }),
/* 181 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProtocolDiagnostic = exports.DiagnosticCode = void 0;
const vscode = __webpack_require__(1);
const Is = __webpack_require__(176);
var DiagnosticCode;
(function (DiagnosticCode) {
    function is(value) {
        const candidate = value;
        return candidate !== undefined && candidate !== null && (Is.number(candidate.value) || Is.string(candidate.value)) && Is.string(candidate.target);
    }
    DiagnosticCode.is = is;
})(DiagnosticCode = exports.DiagnosticCode || (exports.DiagnosticCode = {}));
class ProtocolDiagnostic extends vscode.Diagnostic {
    constructor(range, message, severity, data) {
        super(range, message, severity);
        this.data = data;
        this.hasDiagnosticCode = false;
    }
}
exports.ProtocolDiagnostic = ProtocolDiagnostic;
//# sourceMappingURL=protocolDiagnostic.js.map

/***/ }),
/* 182 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
const code = __webpack_require__(1);
class ProtocolCallHierarchyItem extends code.CallHierarchyItem {
    constructor(kind, name, detail, uri, range, selectionRange, data) {
        super(kind, name, detail, uri, range, selectionRange);
        if (data !== undefined) {
            this.data = data;
        }
    }
}
exports["default"] = ProtocolCallHierarchyItem;
//# sourceMappingURL=protocolCallHierarchyItem.js.map

/***/ }),
/* 183 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createConverter = void 0;
const code = __webpack_require__(1);
const proto = __webpack_require__(134);
const Is = __webpack_require__(176);
const protocolCompletionItem_1 = __webpack_require__(177);
const protocolCodeLens_1 = __webpack_require__(178);
const protocolDocumentLink_1 = __webpack_require__(179);
const protocolCodeAction_1 = __webpack_require__(180);
const protocolDiagnostic_1 = __webpack_require__(181);
const protocolCallHierarchyItem_1 = __webpack_require__(182);
const vscode_languageserver_protocol_1 = __webpack_require__(134);
var InsertReplaceRange;
(function (InsertReplaceRange) {
    function is(value) {
        const candidate = value;
        return candidate && !!candidate.inserting && !!candidate.replacing;
    }
    InsertReplaceRange.is = is;
})(InsertReplaceRange || (InsertReplaceRange = {}));
function createConverter(uriConverter) {
    const nullConverter = (value) => value.toString();
    const _uriConverter = uriConverter || nullConverter;
    function asUri(value) {
        return _uriConverter(value);
    }
    function asTextDocumentIdentifier(textDocument) {
        return {
            uri: _uriConverter(textDocument.uri)
        };
    }
    function asVersionedTextDocumentIdentifier(textDocument) {
        return {
            uri: _uriConverter(textDocument.uri),
            version: textDocument.version
        };
    }
    function asOpenTextDocumentParams(textDocument) {
        return {
            textDocument: {
                uri: _uriConverter(textDocument.uri),
                languageId: textDocument.languageId,
                version: textDocument.version,
                text: textDocument.getText()
            }
        };
    }
    function isTextDocumentChangeEvent(value) {
        let candidate = value;
        return !!candidate.document && !!candidate.contentChanges;
    }
    function isTextDocument(value) {
        let candidate = value;
        return !!candidate.uri && !!candidate.version;
    }
    function asChangeTextDocumentParams(arg) {
        if (isTextDocument(arg)) {
            let result = {
                textDocument: {
                    uri: _uriConverter(arg.uri),
                    version: arg.version
                },
                contentChanges: [{ text: arg.getText() }]
            };
            return result;
        }
        else if (isTextDocumentChangeEvent(arg)) {
            let document = arg.document;
            let result = {
                textDocument: {
                    uri: _uriConverter(document.uri),
                    version: document.version
                },
                contentChanges: arg.contentChanges.map((change) => {
                    let range = change.range;
                    return {
                        range: {
                            start: { line: range.start.line, character: range.start.character },
                            end: { line: range.end.line, character: range.end.character }
                        },
                        rangeLength: change.rangeLength,
                        text: change.text
                    };
                })
            };
            return result;
        }
        else {
            throw Error('Unsupported text document change parameter');
        }
    }
    function asCloseTextDocumentParams(textDocument) {
        return {
            textDocument: asTextDocumentIdentifier(textDocument)
        };
    }
    function asSaveTextDocumentParams(textDocument, includeContent = false) {
        let result = {
            textDocument: asTextDocumentIdentifier(textDocument)
        };
        if (includeContent) {
            result.text = textDocument.getText();
        }
        return result;
    }
    function asTextDocumentSaveReason(reason) {
        switch (reason) {
            case code.TextDocumentSaveReason.Manual:
                return proto.TextDocumentSaveReason.Manual;
            case code.TextDocumentSaveReason.AfterDelay:
                return proto.TextDocumentSaveReason.AfterDelay;
            case code.TextDocumentSaveReason.FocusOut:
                return proto.TextDocumentSaveReason.FocusOut;
        }
        return proto.TextDocumentSaveReason.Manual;
    }
    function asWillSaveTextDocumentParams(event) {
        return {
            textDocument: asTextDocumentIdentifier(event.document),
            reason: asTextDocumentSaveReason(event.reason)
        };
    }
    function asDidCreateFilesParams(event) {
        return {
            files: event.files.map((fileUri) => ({
                uri: _uriConverter(fileUri),
            })),
        };
    }
    function asDidRenameFilesParams(event) {
        return {
            files: event.files.map((file) => ({
                oldUri: _uriConverter(file.oldUri),
                newUri: _uriConverter(file.newUri),
            })),
        };
    }
    function asDidDeleteFilesParams(event) {
        return {
            files: event.files.map((fileUri) => ({
                uri: _uriConverter(fileUri),
            })),
        };
    }
    function asWillCreateFilesParams(event) {
        return {
            files: event.files.map((fileUri) => ({
                uri: _uriConverter(fileUri),
            })),
        };
    }
    function asWillRenameFilesParams(event) {
        return {
            files: event.files.map((file) => ({
                oldUri: _uriConverter(file.oldUri),
                newUri: _uriConverter(file.newUri),
            })),
        };
    }
    function asWillDeleteFilesParams(event) {
        return {
            files: event.files.map((fileUri) => ({
                uri: _uriConverter(fileUri),
            })),
        };
    }
    function asTextDocumentPositionParams(textDocument, position) {
        return {
            textDocument: asTextDocumentIdentifier(textDocument),
            position: asWorkerPosition(position)
        };
    }
    function asCompletionTriggerKind(triggerKind) {
        switch (triggerKind) {
            case code.CompletionTriggerKind.TriggerCharacter:
                return proto.CompletionTriggerKind.TriggerCharacter;
            case code.CompletionTriggerKind.TriggerForIncompleteCompletions:
                return proto.CompletionTriggerKind.TriggerForIncompleteCompletions;
            default:
                return proto.CompletionTriggerKind.Invoked;
        }
    }
    function asCompletionParams(textDocument, position, context) {
        return {
            textDocument: asTextDocumentIdentifier(textDocument),
            position: asWorkerPosition(position),
            context: {
                triggerKind: asCompletionTriggerKind(context.triggerKind),
                triggerCharacter: context.triggerCharacter
            }
        };
    }
    function asSignatureHelpTriggerKind(triggerKind) {
        switch (triggerKind) {
            case code.SignatureHelpTriggerKind.Invoke:
                return proto.SignatureHelpTriggerKind.Invoked;
            case code.SignatureHelpTriggerKind.TriggerCharacter:
                return proto.SignatureHelpTriggerKind.TriggerCharacter;
            case code.SignatureHelpTriggerKind.ContentChange:
                return proto.SignatureHelpTriggerKind.ContentChange;
        }
    }
    function asParameterInformation(value) {
        // We leave the documentation out on purpose since it usually adds no
        // value for the server.
        return {
            label: value.label
        };
    }
    function asParameterInformations(values) {
        return values.map(asParameterInformation);
    }
    function asSignatureInformation(value) {
        // We leave the documentation out on purpose since it usually adds no
        // value for the server.
        return {
            label: value.label,
            parameters: asParameterInformations(value.parameters)
        };
    }
    function asSignatureInformations(values) {
        return values.map(asSignatureInformation);
    }
    function asSignatureHelp(value) {
        if (value === undefined) {
            return value;
        }
        return {
            signatures: asSignatureInformations(value.signatures),
            activeSignature: value.activeSignature,
            activeParameter: value.activeParameter
        };
    }
    function asSignatureHelpParams(textDocument, position, context) {
        return {
            textDocument: asTextDocumentIdentifier(textDocument),
            position: asWorkerPosition(position),
            context: {
                isRetrigger: context.isRetrigger,
                triggerCharacter: context.triggerCharacter,
                triggerKind: asSignatureHelpTriggerKind(context.triggerKind),
                activeSignatureHelp: asSignatureHelp(context.activeSignatureHelp)
            }
        };
    }
    function asWorkerPosition(position) {
        return { line: position.line, character: position.character };
    }
    function asPosition(value) {
        if (value === undefined || value === null) {
            return value;
        }
        return { line: value.line > vscode_languageserver_protocol_1.uinteger.MAX_VALUE ? vscode_languageserver_protocol_1.uinteger.MAX_VALUE : value.line, character: value.character > vscode_languageserver_protocol_1.uinteger.MAX_VALUE ? vscode_languageserver_protocol_1.uinteger.MAX_VALUE : value.character };
    }
    function asPositions(value) {
        let result = [];
        for (let elem of value) {
            result.push(asPosition(elem));
        }
        return result;
    }
    function asRange(value) {
        if (value === undefined || value === null) {
            return value;
        }
        return { start: asPosition(value.start), end: asPosition(value.end) };
    }
    function asLocation(value) {
        if (value === undefined || value === null) {
            return value;
        }
        return proto.Location.create(asUri(value.uri), asRange(value.range));
    }
    function asDiagnosticSeverity(value) {
        switch (value) {
            case code.DiagnosticSeverity.Error:
                return proto.DiagnosticSeverity.Error;
            case code.DiagnosticSeverity.Warning:
                return proto.DiagnosticSeverity.Warning;
            case code.DiagnosticSeverity.Information:
                return proto.DiagnosticSeverity.Information;
            case code.DiagnosticSeverity.Hint:
                return proto.DiagnosticSeverity.Hint;
        }
    }
    function asDiagnosticTags(tags) {
        if (!tags) {
            return undefined;
        }
        let result = [];
        for (let tag of tags) {
            let converted = asDiagnosticTag(tag);
            if (converted !== undefined) {
                result.push(converted);
            }
        }
        return result.length > 0 ? result : undefined;
    }
    function asDiagnosticTag(tag) {
        switch (tag) {
            case code.DiagnosticTag.Unnecessary:
                return proto.DiagnosticTag.Unnecessary;
            case code.DiagnosticTag.Deprecated:
                return proto.DiagnosticTag.Deprecated;
            default:
                return undefined;
        }
    }
    function asRelatedInformation(item) {
        return {
            message: item.message,
            location: asLocation(item.location)
        };
    }
    function asRelatedInformations(items) {
        return items.map(asRelatedInformation);
    }
    function asDiagnosticCode(value) {
        if (value === undefined || value === null) {
            return undefined;
        }
        if (Is.number(value) || Is.string(value)) {
            return value;
        }
        return { value: value.value, target: asUri(value.target) };
    }
    function asDiagnostic(item) {
        const result = proto.Diagnostic.create(asRange(item.range), item.message);
        const protocolDiagnostic = item instanceof protocolDiagnostic_1.ProtocolDiagnostic ? item : undefined;
        if (protocolDiagnostic !== undefined && protocolDiagnostic.data !== undefined) {
            result.data = protocolDiagnostic.data;
        }
        const code = asDiagnosticCode(item.code);
        if (protocolDiagnostic_1.DiagnosticCode.is(code)) {
            if (protocolDiagnostic !== undefined && protocolDiagnostic.hasDiagnosticCode) {
                result.code = code;
            }
            else {
                result.code = code.value;
                result.codeDescription = { href: code.target };
            }
        }
        else {
            result.code = code;
        }
        if (Is.number(item.severity)) {
            result.severity = asDiagnosticSeverity(item.severity);
        }
        if (Array.isArray(item.tags)) {
            result.tags = asDiagnosticTags(item.tags);
        }
        if (item.relatedInformation) {
            result.relatedInformation = asRelatedInformations(item.relatedInformation);
        }
        if (item.source) {
            result.source = item.source;
        }
        return result;
    }
    function asDiagnostics(items) {
        if (items === undefined || items === null) {
            return items;
        }
        return items.map(asDiagnostic);
    }
    function asDocumentation(format, documentation) {
        switch (format) {
            case '$string':
                return documentation;
            case proto.MarkupKind.PlainText:
                return { kind: format, value: documentation };
            case proto.MarkupKind.Markdown:
                return { kind: format, value: documentation.value };
            default:
                return `Unsupported Markup content received. Kind is: ${format}`;
        }
    }
    function asCompletionItemTag(tag) {
        switch (tag) {
            case code.CompletionItemTag.Deprecated:
                return proto.CompletionItemTag.Deprecated;
        }
        return undefined;
    }
    function asCompletionItemTags(tags) {
        if (tags === undefined) {
            return tags;
        }
        const result = [];
        for (let tag of tags) {
            const converted = asCompletionItemTag(tag);
            if (converted !== undefined) {
                result.push(converted);
            }
        }
        return result;
    }
    function asCompletionItemKind(value, original) {
        if (original !== undefined) {
            return original;
        }
        return value + 1;
    }
    function asCompletionItem(item, labelDetailsSupport = false) {
        let labelDetails;
        let label;
        if (item.label2 !== undefined) {
            label = item.label2.name;
            if (labelDetailsSupport) {
                labelDetails = { parameters: item.label2.parameters, qualifier: item.label2.qualifier, type: item.label2.type };
            }
        }
        else {
            label = item.label;
        }
        let result = { label: label };
        if (labelDetails !== undefined) {
            result.labelDetails = labelDetails;
        }
        let protocolItem = item instanceof protocolCompletionItem_1.default ? item : undefined;
        if (item.detail) {
            result.detail = item.detail;
        }
        // We only send items back we created. So this can't be something else than
        // a string right now.
        if (item.documentation) {
            if (!protocolItem || protocolItem.documentationFormat === '$string') {
                result.documentation = item.documentation;
            }
            else {
                result.documentation = asDocumentation(protocolItem.documentationFormat, item.documentation);
            }
        }
        if (item.filterText) {
            result.filterText = item.filterText;
        }
        fillPrimaryInsertText(result, item);
        if (Is.number(item.kind)) {
            result.kind = asCompletionItemKind(item.kind, protocolItem && protocolItem.originalItemKind);
        }
        if (item.sortText) {
            result.sortText = item.sortText;
        }
        if (item.additionalTextEdits) {
            result.additionalTextEdits = asTextEdits(item.additionalTextEdits);
        }
        if (item.commitCharacters) {
            result.commitCharacters = item.commitCharacters.slice();
        }
        if (item.command) {
            result.command = asCommand(item.command);
        }
        if (item.preselect === true || item.preselect === false) {
            result.preselect = item.preselect;
        }
        const tags = asCompletionItemTags(item.tags);
        if (protocolItem) {
            if (protocolItem.data !== undefined) {
                result.data = protocolItem.data;
            }
            if (protocolItem.deprecated === true || protocolItem.deprecated === false) {
                if (protocolItem.deprecated === true && tags !== undefined && tags.length > 0) {
                    const index = tags.indexOf(code.CompletionItemTag.Deprecated);
                    if (index !== -1) {
                        tags.splice(index, 1);
                    }
                }
                result.deprecated = protocolItem.deprecated;
            }
            if (protocolItem.insertTextMode !== undefined) {
                result.insertTextMode = protocolItem.insertTextMode;
            }
        }
        if (tags !== undefined && tags.length > 0) {
            result.tags = tags;
        }
        if (result.insertTextMode === undefined && item.keepWhitespace === true) {
            result.insertTextMode = vscode_languageserver_protocol_1.InsertTextMode.adjustIndentation;
        }
        return result;
    }
    function fillPrimaryInsertText(target, source) {
        let format = proto.InsertTextFormat.PlainText;
        let text = undefined;
        let range = undefined;
        if (source.textEdit) {
            text = source.textEdit.newText;
            range = source.textEdit.range;
        }
        else if (source.insertText instanceof code.SnippetString) {
            format = proto.InsertTextFormat.Snippet;
            text = source.insertText.value;
        }
        else {
            text = source.insertText;
        }
        if (source.range) {
            range = source.range;
        }
        target.insertTextFormat = format;
        if (source.fromEdit && text !== undefined && range !== undefined) {
            target.textEdit = asCompletionTextEdit(text, range);
        }
        else {
            target.insertText = text;
        }
    }
    function asCompletionTextEdit(newText, range) {
        if (InsertReplaceRange.is(range)) {
            return proto.InsertReplaceEdit.create(newText, asRange(range.inserting), asRange(range.replacing));
        }
        else {
            return { newText, range: asRange(range) };
        }
    }
    function asTextEdit(edit) {
        return { range: asRange(edit.range), newText: edit.newText };
    }
    function asTextEdits(edits) {
        if (edits === undefined || edits === null) {
            return edits;
        }
        return edits.map(asTextEdit);
    }
    function asSymbolKind(item) {
        if (item <= code.SymbolKind.TypeParameter) {
            // Symbol kind is one based in the protocol and zero based in code.
            return (item + 1);
        }
        return proto.SymbolKind.Property;
    }
    function asSymbolTag(item) {
        return item;
    }
    function asSymbolTags(items) {
        return items.map(asSymbolTag);
    }
    function asReferenceParams(textDocument, position, options) {
        return {
            textDocument: asTextDocumentIdentifier(textDocument),
            position: asWorkerPosition(position),
            context: { includeDeclaration: options.includeDeclaration }
        };
    }
    function asCodeAction(item) {
        let result = proto.CodeAction.create(item.title);
        if (item instanceof protocolCodeAction_1.default && item.data !== undefined) {
            result.data = item.data;
        }
        if (item.kind !== undefined) {
            result.kind = asCodeActionKind(item.kind);
        }
        if (item.diagnostics !== undefined) {
            result.diagnostics = asDiagnostics(item.diagnostics);
        }
        if (item.edit !== undefined) {
            throw new Error(`VS Code code actions can only be converted to a protocol code action without an edit.`);
        }
        if (item.command !== undefined) {
            result.command = asCommand(item.command);
        }
        if (item.isPreferred !== undefined) {
            result.isPreferred = item.isPreferred;
        }
        if (item.disabled !== undefined) {
            result.disabled = { reason: item.disabled.reason };
        }
        return result;
    }
    function asCodeActionContext(context) {
        if (context === undefined || context === null) {
            return context;
        }
        let only;
        if (context.only && Is.string(context.only.value)) {
            only = [context.only.value];
        }
        return proto.CodeActionContext.create(asDiagnostics(context.diagnostics), only);
    }
    function asCodeActionKind(item) {
        if (item === undefined || item === null) {
            return undefined;
        }
        return item.value;
    }
    function asCommand(item) {
        let result = proto.Command.create(item.title, item.command);
        if (item.arguments) {
            result.arguments = item.arguments;
        }
        return result;
    }
    function asCodeLens(item) {
        let result = proto.CodeLens.create(asRange(item.range));
        if (item.command) {
            result.command = asCommand(item.command);
        }
        if (item instanceof protocolCodeLens_1.default) {
            if (item.data) {
                result.data = item.data;
            }
        }
        return result;
    }
    function asFormattingOptions(options, fileOptions) {
        const result = { tabSize: options.tabSize, insertSpaces: options.insertSpaces };
        if (fileOptions.trimTrailingWhitespace) {
            result.trimTrailingWhitespace = true;
        }
        if (fileOptions.trimFinalNewlines) {
            result.trimFinalNewlines = true;
        }
        if (fileOptions.insertFinalNewline) {
            result.insertFinalNewline = true;
        }
        return result;
    }
    function asDocumentSymbolParams(textDocument) {
        return {
            textDocument: asTextDocumentIdentifier(textDocument)
        };
    }
    function asCodeLensParams(textDocument) {
        return {
            textDocument: asTextDocumentIdentifier(textDocument)
        };
    }
    function asDocumentLink(item) {
        let result = proto.DocumentLink.create(asRange(item.range));
        if (item.target) {
            result.target = asUri(item.target);
        }
        if (item.tooltip !== undefined) {
            result.tooltip = item.tooltip;
        }
        let protocolItem = item instanceof protocolDocumentLink_1.default ? item : undefined;
        if (protocolItem && protocolItem.data) {
            result.data = protocolItem.data;
        }
        return result;
    }
    function asDocumentLinkParams(textDocument) {
        return {
            textDocument: asTextDocumentIdentifier(textDocument)
        };
    }
    function asCallHierarchyItem(value) {
        const result = {
            name: value.name,
            kind: asSymbolKind(value.kind),
            uri: asUri(value.uri),
            range: asRange(value.range),
            selectionRange: asRange(value.selectionRange)
        };
        if (value.detail !== undefined && value.detail.length > 0) {
            result.detail = value.detail;
        }
        if (value.tags !== undefined) {
            result.tags = asSymbolTags(value.tags);
        }
        if (value instanceof protocolCallHierarchyItem_1.default && value.data !== undefined) {
            result.data = value.data;
        }
        return result;
    }
    return {
        asUri,
        asTextDocumentIdentifier,
        asVersionedTextDocumentIdentifier,
        asOpenTextDocumentParams,
        asChangeTextDocumentParams,
        asCloseTextDocumentParams,
        asSaveTextDocumentParams,
        asWillSaveTextDocumentParams,
        asDidCreateFilesParams,
        asDidRenameFilesParams,
        asDidDeleteFilesParams,
        asWillCreateFilesParams,
        asWillRenameFilesParams,
        asWillDeleteFilesParams,
        asTextDocumentPositionParams,
        asCompletionParams,
        asSignatureHelpParams,
        asWorkerPosition,
        asRange,
        asPosition,
        asPositions,
        asLocation,
        asDiagnosticSeverity,
        asDiagnosticTag,
        asDiagnostic,
        asDiagnostics,
        asCompletionItem,
        asTextEdit,
        asSymbolKind,
        asSymbolTag,
        asSymbolTags,
        asReferenceParams,
        asCodeAction,
        asCodeActionContext,
        asCommand,
        asCodeLens,
        asFormattingOptions,
        asDocumentSymbolParams,
        asCodeLensParams,
        asDocumentLink,
        asDocumentLinkParams,
        asCallHierarchyItem
    };
}
exports.createConverter = createConverter;
//# sourceMappingURL=codeConverter.js.map

/***/ }),
/* 184 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getExtensionApi = exports.getJavaExtension = exports.isLombokSupportEnabled = exports.getUserSettingsPath = exports.VM_ARGS_KEY = void 0;
const vscode = __webpack_require__(1);
const constants_1 = __webpack_require__(185);
exports.VM_ARGS_KEY = "java.jdt.ls.vmargs";
function getUserSettingsPath(platform) {
    const map = {
        win32: process.env.APPDATA + '\\Code\\User\\settings.json',
        darwin: process.env.HOME + '/Library/Application Support/Code/User/settings.json',
        linux: process.env.HOME + '/.config/Code/User/settings.json'
    };
    return map[platform];
}
exports.getUserSettingsPath = getUserSettingsPath;
function isLombokSupportEnabled() {
    return vscode.workspace.getConfiguration().get("java.jdt.ls.lombokSupport.enabled");
}
exports.isLombokSupportEnabled = isLombokSupportEnabled;
function getJavaExtension() {
    return vscode.extensions.getExtension(constants_1.JAVA_EXTENSION_ID);
}
exports.getJavaExtension = getJavaExtension;
function getExtensionApi() {
    return __awaiter(this, void 0, void 0, function* () {
        const extension = getJavaExtension();
        if (extension === undefined) {
            return undefined;
        }
        const extensionApi = yield extension.activate();
        if (extensionApi.getClasspaths === undefined) {
            throw undefined;
        }
        return extensionApi;
    });
}
exports.getExtensionApi = getExtensionApi;


/***/ }),
/* 185 */
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.JAVA_EXTENSION_ID = void 0;
exports.JAVA_EXTENSION_ID = "redhat.java";


/***/ }),
/* 186 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isLombokExists = void 0;
const vscode = __webpack_require__(1);
const path = __webpack_require__(152);
const util_1 = __webpack_require__(184);
const commands_1 = __webpack_require__(132);
const lombokJarRegex = /lombok-\d+.*\.jar$/;
function isLombokExists() {
    return __awaiter(this, void 0, void 0, function* () {
        const projectUris = yield getAllJavaProjects();
        const extensionApi = yield (0, util_1.getExtensionApi)();
        if (!extensionApi) {
            return false;
        }
        for (const projectUri of projectUris) {
            const classpathResult = yield extensionApi.getClasspaths(projectUri, { scope: 'test' });
            for (const classpath of classpathResult.classpaths) {
                if (lombokJarRegex.test(classpath)) {
                    return true;
                }
            }
        }
        return false;
    });
}
exports.isLombokExists = isLombokExists;
function getAllJavaProjects(excludeDefaultProject = true) {
    return __awaiter(this, void 0, void 0, function* () {
        let projectUris = yield (0, commands_1.executeJavaLanguageServerCommand)(commands_1.Commands.GET_ALL_JAVA_PROJECTS);
        if (excludeDefaultProject) {
            projectUris = projectUris.filter((uriString) => {
                const projectPath = vscode.Uri.parse(uriString).fsPath;
                return path.basename(projectPath) !== "jdt.ls-java-project";
            });
        }
        return projectUris;
    });
}


/***/ })
/******/ 	]);
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__(0);
/******/ 	module.exports = __webpack_exports__;
/******/ 	
/******/ })()
;
//# sourceMappingURL=extension.js.map